This is info/sicstus.info, produced by makeinfo version 4.13 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 8 May 2014.


File: sicstus.info,  Node: lib-sockets,  Next: lib-structs,  Prev: lib-sets,  Up: The Prolog Library

10.22 Socket I/O--`library(sockets)'
====================================

This library package defines a number of predicates for communicating
over sockets.

   To create a (bi-directional) stream connected to a remote server,
use `socket_client_open/3'.

   To open a port for remote clients to connect to, use
`socket_server_open/[2,3]' and to open a stream to a connecting client,
use `socket_server_accept/4'.

   To be able to multiplex input and output from several streams (not
necesessarily socket streams) and incoming connections, use
`socket_select/7'.

   When opening a client or server socket a "socket address" needs to
be specified. The address specifies the address family and
family-specific information. The following formats are supported for
socket addresses:
`inet(NODENAME,SERVNAME)'
`NODENAME:SERVNAME'
`SERVNAME'
     This specifies the address for and ordinary internet socket
     (`AF_INET' or `AF_INET6').  NODENAME is the internet address of
     the remote host, as an atom, something like `'www.sics.se'' or
     `'193.10.64.51''. The empty nodename `''' (the default), has
     special meaning, see the documentation for `socket_client_open/3'
     and `socket_server_open/[2,3]'.  SERVNAME is either a port number
     as an atom of decimal digits or as an integer, e.g. `'80'', or
     `80'; alternatively some "well known port names" can be used, e.g.
     `'http''. The set of well known port names is OS specific,
     portable code should use integer port numbers.  SERVNAME can also
     be a variable when opening a server socket with
     `socket_server_open/[2,3]'. In this case a available port is
     assigned automatically and Servname is bound to it.

`unix(PATH)   "since release 4.0.3"'
     A Unix domain (`AF_UNIX') socket is opened at the specified file
     system location. This is only supported on Unix-like platforms.
     PATH is a file-name and is passed to `absolute_file_name/2'. There
     may be platform-specific restrictions on the length of the
     resulting pathname and the file system containing it.

   All streams below can be read from as well as written to.  All I/O
predicates operating on streams can be used, for example `get_code/2',
`get_byte/2', `read/2', `write/2', `format/3', `current_stream/3', etc.
The predicates that create streams take options similar to `open/4',
e.g. to specify whether the stream is binary (the default) or text.

`socket_client_open(+ADDR, -STREAM, +OPTIONS)'
     Creates a stream STREAM connected to address ADDR.  See above for
     the allowed address formats. If the nodename is empty (`''') then
     a connection is made to the local machine.

     The stream is created using options from OPTIONS. Supported
     options include:
    `type(binary)'
          Create a binary stream (the default).

    `type(text)'
          Create a text stream. The default encoding is Latin 1.

    `eof_action(ACTION)'
          end of file action, as for `open/4'.

    `encoding(ENCODING)   "since release 4.1"'
          As for open/4. Implies `type(text)'.

    `eol(EOL)   "since release 4.1"'
          As for open/4. Implies `type(text)'.

     To create a binary stream to some web server `www.sics.se', you
     would do e.g.
          | ?- socket_client_open('www.sics.se':80, Stream, [type(binary)]).

     or, to make a text (Latin 1) stream to a `daytime' service in Hong
     Kong you could do:

          | ?- socket_client_open('stdtime.gov.hk':daytime, S, [type(text)]),
               read_line(S, L),
               format('~s', [L]).

     See the source code for `library('linda/client')' for a simple
     client.

`socket_server_open(?ADDR, -SERVERSOCKET, +OPTIONS)   "since release 4.0.3"'
     Create a server socket SERVERSOCKET that listens on address ADDR.
     See above for the allowed address formats. If the nodename is
     empty (`''') then any remote client machine is allowed to connect
     unless the option `loopback(true)' is also specified.  ADDR can
     specify an internet address where the port is a variable in which
     case a free port number is used and PORT is bound to it. The
     common case is that Addr is a numeric port number or a variable
     that becomes bound to a free port number.

     The created server socket should be closed with
     `socket_server_close/1' eventually. Incoming connection can be
     accepted with `socket_server_accept/4' and waited for with
     `socket_select/7'.  See the source code for
     `library('linda/server')' for a simple server that uses this
     predicate.

     OPTIONS is a list of options, currently
    `reuseaddr(Bool)   "since release 4.0.3"'
          BOOL is either `true' or `false' (the default). If `true'
          then allow reuse of local addresses. For internet sockets
          this corresponds to the `SO_REUSEADDR' socket option. For
          unix domain sockets this means that the file will be deleted,
          if present, before opening.

    `numeric_nodename(Bool)   "since release 4.0.3"'
          BOOL is either `true' or `false' (the default). If `true'
          then the nodename of an internet address will be treated as a
          numerical address and no name lookup will be performed.

    `numeric_servname(Bool)   "since release 4.0.3"'
          BOOL is either `true' or `false' (the default). If `true'
          then the servname of an internet address will be treated as a
          numerical port number and no lookup of well known port names
          will be performed.

    `loopback(Bool)   "since release 4.0.3"'
          BOOL is either `true' or `false' (the default). If `true'
          then the nodename will be ignored and the socket will only
          listen to connection from the loopback device, i.e. the local
          machine.

`socket_server_open(?PORT, -SERVERSOCKET)'
     The same as `socket_server_open(PORT, SERVERSOCKET, [])'.

`socket_server_accept(+SERVERSOCKET, -CLIENT, -STREAM, +STREAMOPTIONS)'
     The first connection to socket SERVERSOCKET is extracted, blocking
     if necessary.  The stream STREAM is created on this connection
     using STREAMOPTIONS as for `socket_client_open/3'. CLIENT will be
     unified with an atom containing the numerical Internet host
     address of the connecting client.  Note that the stream will be
     `type(binary)' unless `type(text)' is specified either explicitly
     or implicitly with `encoding/1' or other text-only options.

`socket_server_close(+SERVERSOCKET)'
     Close the server socket SERVERSOCKET and stop listening on its
     port.

`socket_select(+SERVERSOCKETS,-SREADY, +READSTREAMS,-RREADY, +WRITESTREAMS,-WREADY, +TIMEOUT)'
     Check for server sockets with incoming connections (i.e. ready for
     `socket_server_accept/4'), streams on READSTREAMS ready for input,
     and streams on WRITESTREAMS ready for output. The streams can be
     any kind of streams, they need not be socket streams. The ready
     server sockets are returned (in the same order) in SREADY, the
     ready input streams in RREADY, and the ready output streams in
     WREADY.

     An input (output) stream is ready for input (output) when an
     "item" can be read (written) without blocking. An item is a
     character for text streams and a byte for binary streams.  Note
     that a stream is considered ready for I/O if the corresponding I/O
     operation will raise an error (such as if the stream is past end
     of stream).

     Each entry in the input lists SERVERSOCKETS, READSTREAMS, and
     WRITESTREAMS can be either a server socket or stream respectively
     or a term `TERM-ENTRY' where ENTRY is the server socket or stream
     and TERM is some arbitrary term used for book-keeping. If an entry
     is associated with a term in this way then so will the
     corresponding ready entry.

     If TIMEOUT is instantiated to `off', the predicate waits until
     something is available.  If TIMEOUT is a nonzero number (integer
     or floating point), then the predicate waits at most that number
     of seconds before returning. For backward compatibility, if
     TIMEOUT is S:U the predicate waits at most S seconds and U
     microseconds. If there is a timeout, all ready lists are unified
     with `[]'.

     See the source code for `library('linda/server')' for a simple
     server that uses this predicate.

`current_host(?HOSTNAME)'
     HOSTNAME is unified with the fully qualified name of the machine
     that the process is executing on. The call will also succeed if
     HOSTNAME is instantiated to the unqualified name of the machine in
     lower case. *Please note:* this predicate will fail if there are
     errors, e.g. if no domain has been configured.


File: sicstus.info,  Node: lib-structs,  Next: lib-system,  Prev: lib-sockets,  Up: The Prolog Library

10.23 The Structs Package--`library(structs)'
=============================================

* Menu:

* str-fty::                             Foreign Types
* str-cft::                             Checking Foreign Term Types
* str-cdf::                             Creating and Destroying Foreign Terms
* str-afd::                             Accessing and Modifying Foreign Term Contents
* str-cas::                             Casting
* str-nul::                             Null Foreign Terms
* str-ifc::                             Interfacing with Foreign Code
* str-etr::                             Examining Type Definitions at Runtime
* str-tip::                             Tips
* str-exa::                             Example

   The `structs' package allows Prolog to hold pointers to C data
structures, and to access and store into fields in those data
structures.  Currently, the only representation for a pointer supported
by SICStus Prolog is an integer, so it isn't possible to guarantee that
Prolog can't confuse a pointer with an ordinary Prolog term.  What this
package does is to represent such a pointer as a term with the type of
the structure or array as its functor and the integer that is the
address of the actual data as its only argument.  We will refer such
terms as "foreign terms".  

   The package consists of two modules, `str_decl' and `structs'. The
`str_decl' module is used at compile time to translate the
structs-related constructs.  Any file that defines or accesses structs
should include the command:

     :- load_files(library(str_decl),
                   [when(compile_time), if(changed)]).

   The `structs' module provides runtime support for structs.  A file
that accesses structs should include the command:

     :- use_module(library(structs)).

   You will probably include both in most files that define and access
structs.

   *Please note:* A file that loads `library(str_decl)' currently cannot
recursively load another file that loads `library(str_decl)', because
that would confuse the internal database being used by the package.

     *Important caveats:*

     You should not count on future versions of the structs package to
     continue to represent foreign terms as compound Prolog terms.  In
     particular, you should never explicitly take apart a foreign term
     using unification or `functor/3' and `arg/3'.  You may use the
     predicate `foreign_type/2' to find the type of a foreign term, and
     `cast/3' (casting a foreign term to address) to get the address
     part of a foreign term.  You may also use `cast/3' to cast an
     address back to a foreign term.  You should use
     `null_foreign_term/2' to check if a foreign term is null, or to
     create a null foreign term of some type.

     It should never be necessary to explicitly take apart foreign
     terms.


File: sicstus.info,  Node: str-fty,  Next: str-cft,  Up: lib-structs

10.23.1 Foreign Types
---------------------

* Menu:

* str-fty-dty::                         Declaring Types

   There are two sorts of objects that Prolog may want to handle:
"atomic" and "compound".  "Atomic" objects include numbers and atoms,
and "compound" objects include data structures and arrays.  To be more
precise about it, an atomic type is defined by one of the following:

`integer'
     signed integer, large enough to hold a pointer.

`integer_64   "since release 4.3"'
     64 bit signed integer.

`integer_32'
     32 bit signed integer.

`integer_16'
     16 bit signed integer.

`integer_8'
     8 bit signed integer.

`unsigned'
     unsigned integer, large enough to hold a pointer.

`unsigned_64   "since release 4.3"'
     64 bit unsigned integer.

`unsigned_32'
     32 bit unsigned integer.

`unsigned_16'
     16 bit unsigned integer.

`unsigned_8'
     8 bit unsigned integer.

`float'
     64 bit floating-point number.

`float_32'
     32 bit floating-point number.

`atom'
     32 bit Prolog atom number.  Unique for different atoms, but not
     consistent across Prolog sessions.  The atom is made non garbage
     collectable. *Note Atoms in C::.

`string'
     A pointer to an encoded string.  Represented as an atom in Prolog.
     *Please note*: This string must not be overwritten, as it
     constitutes the print name of an atom.  Also, the atom and string
     are made non garbage collectable. *Note Atoms in C::.

`address'
     An untyped pointer.  Like `pointer(_)', but `library(structs)'
     does no type checking for you. Represented as a Prolog integer.

`opaque'
     Unknown type.  Cannot be represented in Prolog.  A pointer to an
     opaque object may be manipulated.

   Compound types are defined by one of the following:

`pointer(TYPE)'
     a pointer to a thing of type TYPE.

`array(NUM,TYPE)'
     A chunk of memory holding NUM (an integer) things of type TYPE.

`array(TYPE)'
     A chunk of memory holding some number of things of type TYPE.
     This type does not allow bounds checking, so it should be used
     with great care.  It is also not possible to use this sort of
     array as an element in an array, or in a struct or union.

`struct(FIELDS)'
     A compound structure.  FIELDS is a list of FIELD_name:TYPE pairs.
     Each FIELD_name is an atom, and each TYPE is any valid type.

`union(MEMBERS)'
     A union as in C.  MEMBERS is a list of MEMBER_name:TYPE pairs.
     Each MEMBER_name is an atom, and each TYPE is any valid type.  The
     space allocated for one of these is the maximum of the spaces
     needed for each member.  It is not permitted to store into a union
     (you must get a member of the union to store into, as in C).

   C programmers will recognize that the kinds of data supported by
this package were designed for the C language.  They should also work
for other languages, but programmers must determine the proper type
declarations in those languages.  The table above makes clear the
storage requirements and interpretation of each type.

   Note that there is one important difference between the `structs'
package and C:  the `structs' package permits declarations of pointers
to arrays.  A pointer to an array is distinguished from a pointer to a
single element.  For example
     pointer(array(integer_8))

is probably a more appropriate declaration of a C string type than
     pointer(integer_8)

which is the orthodox way to declare a string in C.


File: sicstus.info,  Node: str-fty-dty,  Up: str-fty

10.23.1.1 Declaring Types
.........................

Programmers may declare new named data structures with the following
procedure:
     :- foreign_type
         Type_name = Type,
         ...,
         Type_name = Type.

where TYPE_NAME is an atom, and TYPE defines either an atomic or
compound type, or is a previously-defined type name.

   In Prolog, atomic types are represented by the natural atomic term
(integer, float, or atom).  Compound structures are represented by
terms whose functor is the name of the type, and whose only argument is
the address of the data.  So a term `foo(123456)' represents the thing
of type `foo' that exists at machine address 123456.  And a term
`integer(123456)' represents the integer that lives in memeory at
address 123456, _not_ the number 123456.

   For types that are not named, a type name is generated using the
names of associated types and the dollar sign character (`$'), and
possibly a number.  Therefore, users should not use `$' in their type
names.


File: sicstus.info,  Node: str-cft,  Next: str-cdf,  Prev: str-fty,  Up: lib-structs

10.23.2 Checking Foreign Term Types
-----------------------------------

The type of a foreign term may determined by the goal
     foreign_type(+FOREIGN_TERM, -TYPE_NAME)

   Note that `foreign_type/2' will fail if FOREIGN_TERM is not a
foreign term.


File: sicstus.info,  Node: str-cdf,  Next: str-afd,  Prev: str-cft,  Up: lib-structs

10.23.3 Creating and Destroying Foreign Terms
---------------------------------------------

Prolog can create or destroy foreign terms using
     new(+TYPE, -DATUM),
     new(+TYPE, +SIZE, -DATUM) and
     dispose(+DATUM)

where TYPE is an atom specifying what type of foreign term is to be
allocated, and DATUM is the foreign term.  TYPE should be an atomic
type or a previously-defined type name.  The DATUM returned by
`new/[2,3]' is initialized to all zeroes.  `dispose/1' is a dangerous
operation, since once the memory is disposed, it may be used for
something else later.  If DATUM is later accessed, the results will be
unpredictable.  `new/3' is only used to allocate arrays whose size is
not known beforehand, as defined by `array(TYPE)', rather than
`array(NUM,TYPE)'.


File: sicstus.info,  Node: str-afd,  Next: str-cas,  Prev: str-cdf,  Up: lib-structs

10.23.4 Accessing and Modifying Foreign Term Contents
-----------------------------------------------------

Prolog can get or modify the contents of a foreign term with the
procedures
     get_contents(+DATUM, ?PART, ?VALUE)
     put_contents(+DATUM, +PART, +VALUE).

   It can also get a pointer to a field or element of a foreign term
with the procedure
     get_address(+DATUM, ?PART, ?VALUE).

   For all three of these, DATUM must be a foreign term, and PART
specifies what part of DATUM VALUE is.  If DATUM is an array, PART
should be an integer index into the array, where 0 is the first
element.  For a pointer, PART should be the atom `contents' and VALUE
will be what the pointer points to.  For a struct, PART should be a
field name, and VALUE will be the contents of that field.  In the case
of `get_contents/3' and `get_address/3', if PART is unbound,
`get_contents/3' will backtrack through all the valid parts of DATUM,
binding both PART and VALUE.  A C programmer might think of the
following pairs as corresponding to each other:
     Prolog: get_contents(Foo, Bar, Baz)
          C: Baz = Foo->Bar

     Prolog: put_contents(Foo, Bar, Baz)
          C: Foo->Bar = Baz

     Prolog: get_address(Foo, Bar, Baz)
          C: Baz = &Foo->Bar.

   The hitch is that only atomic and pointer types can be got and put
by `get_contents/3' and `put_contents/3'.  This is because Prolog can
only hold pointers to C structures, not the structures themselves.
This isn't quite as bad as it might seem, though, since usually
structures contain pointers to other structures, anyway.  When a
structure directly contains another structure, Prolog can get a pointer
to it with `get_address/3'.


File: sicstus.info,  Node: str-cas,  Next: str-nul,  Prev: str-afd,  Up: lib-structs

10.23.5 Casting
---------------

Prolog can "cast" one type of foreign term to another.  This means that
the foreign term is treated just as if it where the other type.  This is
done with the following procedure:
     cast(+FOREIGN0, +NEW_TYPE, -FOREIGN)

where FOREIGN is the foreign term that is the same data as FOREIGN0,
only is of foreign type NEW_TYPE.  FOREIGN0 is not affected.  This is
much like casting in C.

   Casting a foreign term to `address' will get you the raw address of a
foreign term.  This is not often necessary, but it is occasionally
useful in order to obtain an indexable value to use in the first
argument of a dynamic predicate you are maintaining.  An `address' may
also be casted to a proper foreign type.

   This predicate should be used with great care, as it is quite easy to
get into trouble with this.


File: sicstus.info,  Node: str-nul,  Next: str-ifc,  Prev: str-cas,  Up: lib-structs

10.23.6 Null Foreign Terms
--------------------------

"NULL" foreign terms may be handled.  The predicate
     null_foreign_term(+TERM, -TYPE)
     null_foreign_term(-TERM, +TYPE)

holds when TERM is a foreign term of TYPE, but is NULL (the address is
0).  At least one of TERM and TYPE must be bound.  This can be used to
generate NULL foreign terms, or to check a foreign term to determine
whether or not it is NULL.


File: sicstus.info,  Node: str-ifc,  Next: str-etr,  Prev: str-nul,  Up: lib-structs

10.23.7 Interfacing with Foreign Code
-------------------------------------

Foreign terms may be passed between Prolog and other languages through
the foreign interface.

   To use this, all foreign types to be passed between Prolog and
another language must be declared with `foreign_type/2' before the
`foreign/[2,3]' clauses specifying the foreign functions.

   The `structs' package extends the foreign type specifications
recognized by the foreign interface.  In addition to the types already
recognized by the foreign interface, any atomic type recognized by the
`structs' package is understood, as well as a pointer to any named
`structs' type.

   For example, if you have a function

     char nth_char(string, n)
         char *string;
         int n;
         {
             return string[n];
         }

   You might use it from Prolog as follows:
     :- foreign_type cstring = array(integer_8).

     foreign(nth_char, c, nth_char(+pointer(cstring), +integer, [-integer_8])).

   This allows the predicate `nth_char/3' to be called from Prolog to
determine the nth character of a C string.

   Note that all existing foreign interface type specifications are
unaffected, in particular `address/[0,1]' continue to pass addresses to
and from Prolog as plain integers.

   If you use the foreign resource linker, `splfr', on a Prolog file
that uses the `structs' package, you must pass it the `--structs'
option.  This will make `splfr' understand foreign type specifications
and translate them into C declarations in the generated header file
(*note The Foreign Resource Linker::).


File: sicstus.info,  Node: str-etr,  Next: str-tip,  Prev: str-ifc,  Up: lib-structs

10.23.8 Examining Type Definitions at Runtime
---------------------------------------------

The above described procedures should be sufficient for most needs.
This module does, however, provide a few procedures to allow
programmers to access type definitions.  These may be a convenience for
debugging, or in writing tools to manipulate type definitions.

   The following procedures allow programmers to find the definition of
a given type:
     type_definition(?TYPE, ?DEFINITION)
     type_definition(?TYPE, ?DEFINITION, ?SIZE)

where TYPE is an atom naming a type, DEFINITION is the definition of
that type, and SIZE is the number of bytes occupied by a foreign term of
this type.  SIZE will be the atom `unknown' if the size of an object of
that type is not known.  Such types may not be used as fields in
structs or unions, or in arrays.  However, pointers to them may be
created.  If TYPE is not bound at call time, these procedures will
backtrack through all current type definitions.

   A definition looks much like the definition given when the type was
defined with `type/1', except that it has been simplified.  Firstly,
intermediate type names have been elided.  For example, if `foo' is
defined as `foo=integer', and `bar' as `bar=foo', `type_definition(bar,
integer)' would hold.  Also, in the definition of a compound type,
types of parts are always defined by type names, rather than complex
specifications.  So if the type of a field in a struct was defined as
`pointer(fred)', it will show up in the definition as `'$fred''.  Of
course, `type_definition('$fred', pointer(fred))' would hold, also.

   The following predicates allow the programmer to determine whether
or not a given type is atomic:
     atomic_type(?TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE, ?SIZE)

where TYPE is an atomic type.  See *note str-fty:: for the definition
of an atomic type.  PRIMITIVE_TYPE is the primitive type that TYPE is
defined in terms of.  SIZE is the number of bytes occupied by an object
of type TYPE, or the atom `unknown', as above.  If TYPE is unbound at
call time, these predicates will backtrack through all the currently
defined atomic types.


File: sicstus.info,  Node: str-tip,  Next: str-exa,  Prev: str-etr,  Up: lib-structs

10.23.9 Tips
------------

  1. Most important tip: don't subvert the `structs' type system by
     looking inside foreign terms to get the address, or use
     `functor/3' to get the type.  This has two negative effects:
     firstly, if the `structs' package should change its representation
     of foreign terms, your code will not work.  But more importantly,
     you are more likely to get type mismatches, and likely to get
     unwrapped terms or even doubly wrapped terms where you expect
     wrapped ones.

  2. Remember that a foreign term `fred(123456)' is not of type `fred',
     but a pointer to `fred'.  Looked at another way, what resides in
     memory at address 123456 is of type `fred'.

  3. The wrapper put on a foreign term signifies the type of that
     foreign term.  If you declare a type to be `pointer(opaque)'
     because you want to view that pointer to be opaque, when you get
     something of this type, it will be printed as `opaque(456123)'.
     This is not very informative.  It is better to declare
          fred = opaque,
          thing = struct([...,
                      part:pointer(fred),
                      ...
                  ]).

     so that when you get the contents of the `part' member of a
     `thing', it is wrapped as `fred(456123)'.


File: sicstus.info,  Node: str-exa,  Prev: str-tip,  Up: lib-structs

10.23.10 Example
----------------

The following example shows how to use `library(structs)' in a simple
package for handling integer arrays.  We define a module `minivec' with
exported predicates for creating and disposing arrays, accessing its
elements, and computing their sum.  The summing operation is
implemented in C and the rest in Prolog.  Arrays are created using the
`array(TYPE)' foreign type.

   Note that the type declaration `int32' does not have to be given in
the C source code, as it appears in the automatically generated header
file `minivec_glue.h'.  Note also how the foreign type specification
`+pointer(int_array)' corresponds to the C type declaration `int32 *'.

                                                         _% minivec.pl_
     :- module(minivec, [
             new_array/2,
             get_array/3,
             put_array/3,
             dispose_array/1,
             sum_array/2
             ]).

     :- load_files(library(str_decl), [when(compile_time)]).
     :- use_module(library(structs)).

     :- foreign_type
             int32           = integer_32,
             int_array       = array(int32).

     foreign(c_sum_array, c_sum_array(+integer,
                                      +pointer(int_array),
                                      [-integer])).

     foreign_resource(minivec, [c_sum_array]).

     :- load_foreign_resource(minivec).

     new_array(Size, array(Size,Mem)) :-
             new(int_array, Size, Mem).

     get_array(Index, array(_,Mem), Value) :-
             get_contents(Mem, Index, Value).

     put_array(Index, array(_,Mem), Value) :-
             put_contents(Mem, Index, Value).

     dispose_array(array(_,Mem)) :-
             dispose(Mem).

     sum_array(array(Size,Mem), Sum) :-
             c_sum_array(Size, Mem, Sum).

                                                      _/* minivec.c */_
     #include "minivec_glue.h"

     SP_integer c_sum_array(SP_integer cnt, int32 *mem)
     {
       int i;
       SP_integer sum = 0;

       for (i=0; i<cnt; i++)
         sum += mem[i];
       return sum;
     }

                                                            _# session_
     % splfr --struct minivec.pl minivec.c
     % sicstus -l minivec
     % compiling /home/matsc/sicstus4/Suite/minivec.pl...
     % [...]
     % compiled /home/matsc/sicstus4/Suite/minivec.pl in module minivec, 30 msec 68388 bytes
     SICStus 4.3.0 ...
     Licensed to SICS
     | ?- new_array(4, A),
          put_array(0,A,1),
          put_array(1,A,10),
          put_array(2,A,100),
          put_array(3,A,1000),
          sum_array(A,S),
          dispose_array(A).
     A = array(4,int_array(1264224)),
     S = 1111

   A fragment from the generated header file:

                                                 _/* minivec_glue.h */_
     #include <sicstus/sicstus.h>
     #include <stdlib.h>
     typedef int int32;
     typedef int32 *(int_array)/* really an unknown-size array */;
     extern SP_integer c_sum_array( SP_integer, int32 *);


File: sicstus.info,  Node: lib-system,  Next: lib-terms,  Prev: lib-structs,  Up: The Prolog Library

10.24 Operating System Utilities--`library(system)'
===================================================

This package contains utilities for invoking services from the operating
system that does not fit elsewhere.

   Exported predicates:

`now(-WHEN)'
     Unifies the current date and time as a UNIX timestamp with WHEN.

`datime(-DATIME)'
     Unifies DATIME with the current date and time as a `datime/6'
     record of the form `datime(YEAR,MONTH,DAY,HOUR,MIN,SEC)'.  All
     fields are integers.

`datime(+WHEN,-DATIME)'

`datime(-WHEN,+DATIME)'
     Convert a time stamp, as obtained by `now/1', to a `datime/6'
     record. Can be used in both directions.

`sleep(+SECONDS)'
     Puts the SICStus Prolog process asleep for SECOND seconds, where
     SECONDS should be a non-negative number.

`environ(?VAR, ?VALUE)'
     VAR is the name of a system property or an environment variable,
     and VALUE is its value.  Both are atoms.  Can be used to enumerate
     all current system properties and environment variables.

     The same as `environ(VAR, VALUE, merged)'.

`environ(?VAR, ?VALUE, +SOURCE)   "since release 4.1"'
     VAR is the name of an environment variable or system property, and
     VALUE is its value.  Both are atoms.  Can be used to enumerate all
     current environment variables and system properties.

     SOURCE is one of `properties', in which case only system
     properties are enumerated; `environment', in which case only
     environment variables are enumerated; and `merged', in which case
     both environment variables and system properties are enumerated.
     When SOURCE is `merged' and an environment variable and a system
     property have equivalent names, the value of the system property
     is returned.

     On UNIX-like platforms, two names are equivalent if and only if
     they are identical.  On Windows-like platforms, a case insensitive
     comparison is used.

     *Note System Properties and Environment Variables::, for more
     information.



File: sicstus.info,  Node: lib-terms,  Next: lib-timeout,  Prev: lib-system,  Up: The Prolog Library

10.25 Term Utilities--`library(terms)'
======================================

This library module provides miscellaneous operations on terms.
Exported predicates:

`subsumeschk(+GENERAL, +SPECIFIC)'
     is true when SPECIFIC is an instance of GENERAL.  It does not bind
     any variables.

     This predicate is identical to the built-in `subsumes_term/2' and
     it is only present for backwards compatibility.

`subsumes(+GENERAL, +SPECIFIC)'
     is true when SPECIFIC is an instance of GENERAL.  It will bind
     variables in GENERAL (but not those in SPECIFIC, except when
     +GENERAL and +SPECIFIC share variables) so that GENERAL becomes
     identical to SPECIFIC.

     In many cases, binding variable is not really desirable, in which
     case `subsumes_term/2' should be used instead.  If unification is
     in fact wanted, it may be better to make this explicit in your
     code by using `subsumes_term/2' followed by an explicit
     unification, e.g. `subsumes_term(G,S), G=S'.

`variant(+TERM, +VARIANT)'
     is true when TERM and VARIANT are identical modulo renaming of
     variables, provided TERM and VARIANT have no variables in common.

`term_subsumer(+TERM1, +TERM2, -TERM)'
     binds TERM to a most specific generalisation of TERM1 and TERM2.
     Using Plotkin's algorithm [Machine Intelligence 5, 1970], extended
     by Dan Sahlin to handle cyclic structures.

`term_hash(+TERM, -HASH)'
     Equivalent to `term_hash(Term, [], Hash)'.

`term_hash(+TERM, +OPTIONS, -HASH)'
     OPTIONS is a list of options,

    `algorithm(ALGORITHM)'
          ALGORITHM specifies which hash function to use. An atom, one
          of,

         `default'
               This is currently the same as `jenkins'. This is the
               default. If we ever see a need to change the default hash
               algorithm again then the algorithm denoted by `default'
               may change but the algorithm denoted by the other names,
               like `'sicstus-4.0.5'', will not change.

         `jenkins'
               Based on the algorithm "lookup3" by Bob Jenkins, see
               `http://burtleburtle.net/bob/hash/doobs.html'.

         `hsieh'
               Based on the algorithm "SuperFastHash" by Paul Hsieh, see
               `http://www.azillionmonkeys.com/qed/hash.html'. Despite
               the name neither this nor any other choice of algorithm
               significantly affects the speed of `term_hash/3'.

         `sdbm'
               Based on the well known algorithm "sdbm".

         `'sicstus-4.0.4''
               This is the algorithm used up to SICStus Prolog 4.0.4
               (inclusive). It is only present to provide backwards
               compatibility. It is not as good as any of the above
               algorithms. Note that this atom needs to be quoted.

               This algorithm produces hash values that may differ
               between platforms.

         `'sicstus-4.0.5''
               This is the same as `jenkins'. I.e. the default since
               SICStus Prolog 4.0.5. Note that this atom needs to be
               quoted.


          there are some other (not as good) algorithms available for
          the curious, see the source for detail.

          Unless otherwise noted, the hash value will be identical
          across runs and platforms.

    `range(RANGE)'
          The resulting hash value will be non-negative and less than
          the upper bound specified by RANGE. RANGE should be either a
          positive integer, or an atom, one of,

         `infinite'
               Do not constrain the hash value. Currently all hash
               algorithms produce an unsigned 32-bit integer. Note that
               this may be too large to be used for first-argument
               indexing on 32-bit platforms.

         `smallint'
               Ensure the resulting hash value is a small integer, e.g.
               suitable for first argument indexing. This is the same as
               specifying a range of `2^28' on 32-bit platforms and
               `2^60' on 64-bit platforms.

         `smallint32'
               Ensure the resulting hash value is in the 32-bit
               platform range of small integers, i.e. the same as a
               range of `2^28'.

         `default'
               The same as `smallint32'. This is the default. This
               ensures that, by default, the same hash value is
               computed for the same term on both 32-bit and 64-bit
               platforms.


    `depth(DEPTH)'
          Specifies how deep to descend into the term when calculating
          the hash value.  If `Depth' is a non-negative integer the
          subterms up to depth DEPTH of TERM are used in the
          computation. Alternatively, if `Depth' is the atom
          `infinite', all subterms of TERM are relevant in computing
          HASH. In the latter case TERM must be acyclic.  In this
          context the _depth_ of a term is defined as follows: the
          (principal functor of) the term itself has depth 1, and an
          argument of a term with depth I has depth I+1. Note that this
          is similar to, but not the same as, the value computed by
          `term_depth/2'.  For legacy reasons a DEPTH of -1 is treated
          the same a `infinite'.

    `if_var(IFVAR)'
          Specifies what to do if a variable is encountered in the term
          (i.e. to the specified depth). IFVAR should be an atom, one
          of,

         `error'
               An instantiation error is thrown.

         `ignore'
               The variable is ignored and the hash algorithm continues
               with the other parts of the term.

         `value(Value)'
               The hash algorithm stops, the intermediate hash result is
               discarded and `Hash' is bound to `Value'. There is no
               restrictions on `Value', it need not be an integer or
               even be ground.

         `default'
               This is the same as `value(_)', i.e. `term_hash/3' just
               succeeds without binding `Hash'. This is the default.
               This is useful when the hash value us used for
               first-argument indexing. This ensures that if the
               (possibly variable-valued) hash values for TERM1 and
               TERM2 are HASH1 and HASH2, respectively, then if TERM1
               and TERM2 are unifiable (to the specified depth) then so
               are HASH1 and HASH2.  For other use cases it is probably
               more appropriate to specify `if_var(error)'.

`term_hash(+TERM, +DEPTH, +RANGE, -HASH)'
     Equivalent to `term_hash(Term, [depth(DEPTH), range(RANGE)],
     Hash)'.  `term_hash/[2,3,4]' is provided primarily as a tool for
     the construction of sophisticated Prolog clause access
     schemes.	 Its intended use is to generate hash values for terms
     that will be used with first argument clause indexing, yielding
     compact and efficient multi-argument or deep argument indexing.
     Note that, for this usage, it is very important that the hash
     value is a small integer, as it will be by default.

`term_variables_set(+TERM, -VARIABLES)   "since release 4.3"'
     True if VARIABLES is the (ordered) set of variables occurring in
     TERM.

     This was called `term_variables/2' prior to SICStus Prolog 4.3 but
     now `term_variables/2' is a built-in with different meaning, due
     to alignment with the ISO Prolog standard.

`term_variables_bag(+TERM, -VARIABLES)   "since release 4.3"'
     True if VARIABLES is the list of variables occurring in TERM, in
     first occurrence order.

     This predicate has been superseeded by the built-in
     `term_variables/2' and it is only present for backwards
     compatibility.

     The name is an historical accident, the result is not really a bag
     (i.e. multiset).

`cyclic_term(+X)'
     True if X is infinite (cyclic).  Runs in linear time.

`term_order(+X, +Y, -R)'
     is true when X and Y are arbitrary terms, and R is `<', `=', or
     `>' according as X @< Y, X == Y, or X @> Y.  This is the same as
     `compare/3', except for the argument order.

`contains_term(+KERNEL, +EXPRESSION)'
     is true when the given KERNEL occurs somewhere in the EXPRESSION.
     It can only be used as a test; to generate sub-terms use
     `sub_term/2'.

`free_of_term(+KERNEL, +EXPRESSION)'
     is true when the given KERNEL does not occur anywhere in the
     EXPRESSION.  NB: if the EXPRESSION contains an unbound variable,
     this must fail, as the KERNEL might occur there.  Since there are
     infinitely many KERNELS not contained in any EXPRESSION, and also
     infinitely many EXPRESSIONS not containing any KERNEL, it doesn't
     make sense to use this except as a test.

`occurrences_of_term(+KERNEL, +EXPRESSION, -TALLY)'
     is true when the given KERNEL occurs exactly TALLY times in
     EXPRESSION.  It can only be used to calculate or test TALLY; to
     enumerate KERNELS you'll have to use `sub_term/2' and then test
     them with this routine.  If you just want to find out whether
     KERNEL occurs in EXPRESSION or not, use `contains_term/2' or
     `free_of_term/2'.

`contains_var(+VARIABLE, +TERM)'
     is true when the given TERM contains at least one sub-term which
     is identical to the given VARIABLE.  We use `==' to check for the
     variable (`contains_term/2' uses `=') so it can be used to check
     for arbitrary terms, not just variables.

`free_of_var(+VARIABLE, +TERM)'
     is true when the given TERM contains no sub-term identical to the
     given VARIABLE (which may actually be any term, not just a var).
     For variables, this is precisely the "occurs check" which is
     needed for sound unification.

`occurrences_of_var(+TERM, +VARIABLE, -TALLY)'
     is true when the given VARIABLE occurs exactly TALLY times in
     TERM.	 It can only be used to calculate or test TALLY; to
     enumerate Variables you'll have to use `sub_term/2' and then test
     them with this routine.  If you just want to find out whether
     VARIABLE occurs in TERM or not, use `contains_var/2' or
     `free_of_var/2'.

`sub_term(?KERNEL, +TERM)'
     is true when KERNEL is a sub-term of TERM.  It enumerates the
     sub-terms of TERM in an arbitrary order.  Well, it is defined that
     a sub-term of TERM will be enumerated before its own sub-terms are
     (but of course some of those sub-terms might be elsewhere in TERM
     as well).

`depth_bound(+TERM, +BOUND)'
     is true when the term depth of TERM is no greater than BOUND, that
     is, when constructor functions are nested no more than BOUND deep.
     Later variable bindings may invalidate this bound.	To find the
     (current) depth, use `term_depth/2'.

`length_bound(?LIST, +BOUND)'
     is true when the length of LIST is no greater than BOUND.  It can
     be used to enumerate Lists up to the bound.

`size_bound(+TERM, +BOUND)'
     is true when the number of constant and function symbols in TERM is
     (currently) at most BOUND.  If TERM is non-ground, later variable
     bindings may invalidate this bound.	 To find the (current)
     size, use `term_size/2'.

`term_depth(+TERM, -DEPTH)'
     calculates the Depth of a Term, using the definition
          term_depth(Var) = 0
          term_depth(Const) = 0
          term_depth(F(T1,...,Tn)) = 1+max(term_depth(T1),...,term_depth(Tn))
     Could be defined as:

          term_depth(X, Depth) :-
          simple(X), !, Depth = 0.
          term_depth(X, Depth) :-
          (   foreacharg(A,X),
          fromto(0,D0,D,Depth0)
          do  term_depth(A, D1),
          D is max(D0,D1)
          ),
          Depth is Depth0+1.

`term_size(+TERM, -SIZE)'
     calculates the SIZE of a TERM, defined to be the number of
     constant and function symbol occurrences in it.  Could be defined
     as:

          term_size(X, Size) :-
          var(X), !, Size = 0.
          term_size(X, Size) :-
          simple(X), !, Size = 1.
          term_size(X, Size) :-
          (   foreacharg(A,X),
          fromto(1,S0,S,Size)
          do  term_size(A, S1),
          S is S0+S1
          ).

`same_functor(?T1, ?T2)'
     is true when T1 and T2 have the same principal functor.	 If one
     of the terms is a variable, it will be instantiated to a new term
     with the same principal functor as the other term (which should be
     instantiated) and with arguments being new distinct variables.  If
     both terms are variables, an error is reported.

`same_functor(?T1, ?T2, ?N)'
     is true when T1 and T2 have the same principal functor, and their
     common arity is N. Like `same_functor/3', at least one of T1 and T2
     must be bound, or an error will be reported.

`same_functor(?T1, ?T2, ?F, ?N)'
     is true when T1 and T2 have the same principal functor, and their
     common functor is F/N. Given T1 (or T2) the remaining arguments
     can be computed.  Given F and N, the remaining arguments can be
     computed.  If too many arguments are unbound, an error is reported.


File: sicstus.info,  Node: lib-timeout,  Next: lib-trees,  Prev: lib-terms,  Up: The Prolog Library

10.26 Meta-Call with Limit on Execution Time--`library(timeout)'
================================================================

Exported predicates:

`time_out(:GOAL, +TIME, -RESULT)'
     The GOAL is executed as if by `call/1'.  If computing any solution
     takes more than TIME milliseconds, the goal will be aborted and
     RESULT unified with the atom `time_out'.  If the goal succeeds
     within the specified time, RESULT is unified with the atom
     `success'.  TIME must be a number between (not including) 0 and
     2147483647.

     The time is measured in process virtual time under UNIX. Under
     Windows, thread virtual time is used, which is the same as process
     virtual time for single-threaded processes.

     The precision of the time out interval is usually not better than
     several tens of milliseconds. This is due to limitations in the
     timing mechanisms used to implement `library(timeout)'.

     This library can only be used by one SICStus instance in a
     process, which is the usual way to run SICStus. This limitation
     only affects programs that load SICStus from C or Java and run
     more than one SICStus instance in the same process.


   `time_out/3' is implemented by raising and handling `time_out'
exceptions but, as of SICStus Prolog 4.1.3, these exceptions will not
be intercepted by the normal exception handlers (`on_exception/3' and
`catch/3').


File: sicstus.info,  Node: lib-trees,  Next: lib-types,  Prev: lib-timeout,  Up: The Prolog Library

10.27 Updatable Binary Trees--`library(trees)'
==============================================

This libary module provides updatable binary trees with logarithmic
access time.  Exported predicates:

`gen_label(?INDEX, +TREE, ?VALUE)'
     assumes that Tree is a proper binary tree, and is true when VALUE
     is the INDEX-TH element in TREE.  Can be used to enumerate all
     VALUES by ascending INDEX.

`get_label(+INDEX, +TREE, -LABEL)'
     treats the tree as an array of N elements and returns the INDEX-TH.
     If INDEX < 1 or > N it simply fails, there is no such element.  As
     Tree need not be fully instantiated, and is potentially unbounded,
     we cannot enumerate INDICES.

`list_to_tree(+LIST, -TREE)'
     takes a given LIST of N elements and constructs a binary TREE
     where `get_label(K, TREE, LAB)' <=> LAB is the KTH element of LIST.

`map_tree(:PRED, +OLDTREE, ?NEWTREE)'
     is true when OLDTREE and NEWTREE are binary trees of the same shape
     and PRED(OLD,NEW) is true for corresponding elements of the two
     trees.

`put_label(+INDEX, +OLDTREE, -LABEL, -NEWTREE)'
     constructs a new tree the same shape as the old which moreover has
     the same elements except that the INDEX-TH one is LABEL.  Unlike
     the "arrays" of `library(arrays)', OLDTREE is not modified and you
     can hang on to it as long as you please.  Note that O(LG N) new
     space is needed.

`put_label(+INDEX, +OLDTREE, -OLDLABEL, -NEWTREE, +NEWLABEL)'
     is true when OLDTREE and NEWTREE are trees of the same shape having
     the same elements except that the INDEX-TH element of OLDTREE is
     OLDLABEL and the INDEX-TH element of NEWTREE is NEWLABEL.  You can
     swap the <TREE,LABEL> argument pairs if you like, it makes no
     difference.

`tree_size(+TREE, -SIZE)'
     calculates the number of elements in the TREE.  All trees made by
     `list_to_tree/2' that are the same size have the same shape.

`tree_to_list(+TREE, -LIST)'
     is the converse operation to `list_to_tree/2'.  Any mapping or
     checking operation can be done by converting the tree to a list,
     mapping or checking the list, and converting the result, if any,
     back to a tree.  It is also easier for a human to read a list than
     a tree, as the order in the tree goes all over the place.


File: sicstus.info,  Node: lib-types,  Next: lib-ugraphs,  Prev: lib-trees,  Up: The Prolog Library

10.28 Type Checking--`library(types)'
=====================================

This library module provides more and better type tests.  For the
purposes of this library, we first define an abstract type TYPETERM, as
follows:

TYPETERM           ::= `atom'
                   | `atomic'
                   | `callable'
                   | `character'
                   | `character_code'
                   | `compound'
                   | `db_reference'
                   | `float'
                   | `float(RANGETERM)'
                   | `ground'
                   | `integer'
                   | `integer(RANGETERM)'
                   | `list'
                   | `list(TYPE)'
                   | `mutable'
                   | `nonvar'
                   | `number'
                   | `number(RANGETERM)'
                   | `oneof(L)'
                   | `order'
                   | `pair'
                   | `pred_spec'
                   | `pred_spec_tree'
                   | `proper_list'
                   | `proper_list(TYPE)'
                   | `simple'
                   | `term'
                   | `var'
                   | `var_or(TYPE)'

RANGETERM          ::= `between(L,U)'
                   | `>=(L)'
                   | `>(L)'
                   | `<(L)'
                   | `=<(L)'
                   | `=:=(L)'
                   | `=\=(L)'

   Culprit information:

   These predicates takes arguments that are used when reporting the
reason and location of errors.  The arguments are:
GOAL
     must be a callable term, without `(:)/2' module wrapping, with
     arity at least ARGNO.

ARGNO
     must be a non-negative integer, where zero means no specific
     argument postition.

CULPRIT
     the term that has the offending value.

   Exported predicates:

`must_be(+TERM, +TYPE, +GOAL, +ARGNO)'
     checks whether the TERM belongs to the indicated TYPE, which
     should be a TYPETERM.  If it doesn't, several different error
     exceptions can be thrown: the TERM may not be instantiated enough
     to tell yet (Instantiation Error); it may be instantiated when an
     unbound variable was expected (Uninstantiation Error); it may be
     definitely not of the right type (Type Error); it may be of the
     right type but not representable (Representation Error); or it may
     be of the right type but in the wrong domain (Domain Error).  If
     an error exception is thrown, it will include GOAL and ARGNO and,
     if possible, the line of code in the scope of which the error
     occurred.  *Note ref-ere-err::.

`illarg(+ERRORTERM, +GOAL, +ARGNO)'
`illarg(+ERRORTERM, +GOAL, +ARGNO, +CULPRIT)'
     is the way to raise an error exception, if you would like the
     exception to pinpoint the line of code in the scope of which the
     error occurs.  This is especially useful in the context of
     source-linked debugging. CULPRIT defaults to argument number ARGNO
     of GOAL. These three arguments are passed to the exception being
     raised, if appropriate. ERRORTERM should be one of the following.
     *Note ref-ere-err::.

    `var'
          An Instantiation error is raised.

    `type(ERRORTYPE)'
          Same as `must_be(CULPRIT, ERRORTYPE, GOAL, ARGNO)'.

    `domain(ERRORTYPE,ERRORDOMAIN)'
          First, the type is checked by `must_be(CULPRIT, ERRORTYPE,
          GOAL, ARGNO)'.  If the type is valid, a Domain Error is
          raised with the expected domain being ERRORDOMAIN.

    `force_type(EXPTYPE)'
          A Type Error is raised.

    `context(CONTEXTTYPE,COMMANDTYPE)'
          A Context Error is raised.

    `existence(OBJTYPE,CULPRIT,MESSAGE)'
          An Existence Error is raised.

    `permission(OPERATION,OBJTYPE,MESSAGE)'
          A Permission Error is raised.

    `representation(ERRORTYPE)'
          A Representation Error is raised.

    `evaluation(ERRORTYPE)'
          An Evaluation Error is raised.

    `consistency(CULPRIT1,CULPRIT2,MESSAGE)'
          A Consistency Error is raised.

    `syntax(POS,MSG,TOKENS,AFTERERROR)'
          A Syntax Error is raised.

    `resource(RESOURCE)'
          A Resource Error is raised.

    `system(MESSAGE)'
          A System Error is raised.



File: sicstus.info,  Node: lib-ugraphs,  Next: lib-varnumbers,  Prev: lib-types,  Up: The Prolog Library

10.29 Unweighted Graph Operations--`library(ugraphs)'
=====================================================

This library module provides operations on directed graphs.  An
unweighted directed graph (ugraph) is represented as a list of
(VERTEX-NEIGHBORS) pairs, where the pairs are in standard order (as
produced by `keysort/2' with unique keys) and the neighbors of each
vertex are also in standard order (as produced by `sort/2'), and every
neighbor appears as a vertex even if it has no neighbors itself.

   An undirected graph is represented as a directed graph where for
each edge (U,V) there is a symmetric edge (V,U).

   An edge (U,V) is represented as the term U-V.

   A vertex can be any term.  Two vertices are distinct iff they are
not identical (`==').

   A path is represented as a list of vertices.  No vertex can appear
twice in a path.

   Exported predicates:

`vertices_edges_to_ugraph(+VERTICES, +EDGES, -GRAPH)'
     is true if VERTICES is a list of vertices, EDGES is a list of
     edges, and GRAPH is a graph built from VERTICES and EDGES.
     VERTICES and EDGES may be in any order.  The vertices mentioned in
     EDGES do not have to occur explicitly in VERTICES.  VERTICES may
     be used to specify vertices that are not connected to any edges.

`vertices(+GRAPH, -VERTICES)'
     unifies VERTICES with the vertices in GRAPH.  Could be defined as:

          vertices(Graph, Vertices) :-
          	(   foreach(V-_,Graph),
          	    foreach(V,Vertices)
          	do  true
          	).

`edges(+GRAPH, -EDGES)'
     unifies EDGES with the edges in GRAPH.  Could be defined as:

          edges(Graph, Edges) :-
          	(   foreach(V1-Neibs,Graph),
          	    fromto(Edges,S0,S,[])
          	do  (   foreach(V2,Neibs),
          		param(V1),
          		fromto(S0,[V1-V2|S1],S1,S)
          	    do  true
          	    )
          	).

`add_vertices(+GRAPH1, +VERTICES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with VERTICES added to it.

`del_vertices(+GRAPH1, +VERTICES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with VERTICES and all edges to and from
     VERTICES removed from it.

`add_edges(+GRAPH1, +EDGES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with EDGES and their "to" and "from"
     vertices added to it.

`del_edges(+GRAPH1, +EDGES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with EDGES removed from it.

`transpose_ugraph(+GRAPH, -TRANSPOSE)'
     is true if TRANSPOSE is the graph computed by replacing each edge
     (U,V) in GRAPH by its symmetric edge (V,U).  It can only be used
     one way around.  The cost is O(N LOG N).

`neighbors(+VERTEX, +GRAPH, -NEIGHBORS)'
`neighbours(+VERTEX, +GRAPH, -NEIGHBORS)'
     is true if VERTEX is a vertex in GRAPH and NEIGHBORS are its
     neighbors.

`complement(+GRAPH, -COMPLEMENT)'
     COMPLEMENT is the complement graph of GRAPH, i.e. the graph that
     has the same vertices as GRAPH but only the edges that are not in
     GRAPH.

`compose(+G1, +G2, -COMPOSITION)'
     computes COMPOSITION as the composition of two graphs, which need
     not have the same set of vertices.

`transitive_closure(+GRAPH, -CLOSURE)'
     computes CLOSURE as the transitive closure of GRAPH in O(N^3) time.

`symmetric_closure(+GRAPH, -CLOSURE)'
     computes CLOSURE as the symmetric closure of GRAPH, i.e. for each
     edge (U,V) in GRAPH, add its symmetric edge (V,U).  Approx. O(N
     LOG N) time.  This is useful for making a directed graph
     undirected.  Could be defined as:

          symmetric_closure(Graph, Closure) :-
          	transpose_ugraph(Graph, Transpose),
          	(   foreach(V-Neibs1,Graph),
          	    foreach(V-Neibs2,Transpose),
          	    foreach(V-Neibs,Closure)
          	do  ord_union(Neibs1, Neibs2, Neibs)
          	).

`top_sort(+GRAPH, -SORTED)'
     finds a topological ordering of GRAPH and returns the ordering as
     a list of SORTED vertices.  Fails iff no ordering exists, i.e.
     iff the graph contains cycles.  Approx. O(N LOG N) time.

`max_path(+V1, +V2, +GRAPH, -PATH, -COST)'
     is true if PATH is a list of vertices constituting a longest path
     of cost COST from V1 to V2 in GRAPH, there being no cyclic paths
     from V1 to V2.  Takes O(N^2) time.

`min_path(+V1, +V2, +GRAPH, -PATH, -LENGTH)'
     is true if PATH is a list of vertices constituting a shortest path
     of length LENGTH from V1 to V2 in GRAPH.  Takes O(N^2) time.

`min_paths(+VERTEX, +GRAPH, -TREE)'
     is true if TREE is a tree of all the shortest paths from VERTEX to
     every other vertex in GRAPH.  This is the single-source shortest
     paths problem.  The algorithm is straightforward.

`path(+VERTEX, +GRAPH, -PATH)'
     is given a GRAPH and a VERTEX of that GRAPH, and returns a maximal
     PATH rooted at VERTEX, enumerating more PATHS on backtracking.

`reduce(+GRAPH, -REDUCED)'
     is true if REDUCED is the reduced graph for GRAPH. The vertices of
     the reduced graph are the strongly connected components of GRAPH.
     There is an edge in REDUCED from U to V iff there is an edge in
     GRAPH from one of the vertices in U to one of the vertices in V. A
     strongly connected component is a maximal set of vertices where
     each vertex has a path to every other vertex.  Algorithm from
     "Algorithms" by Sedgewick, page 482, Tarjan's algorithm.

`reachable(+VERTEX, +GRAPH, -REACHABLE)'
     is given a Graph and a VERTEX of that GRAPH, and returns the set
     of vertices that are REACHABLE from that VERTEX.  Takes O(N^2)
     time.

`random_ugraph(+P, +N, -GRAPH)'
     where P is a probability, unifies GRAPH with a random graph of N
     vertices where each possible edge is included with probability P.

`min_tree(+GRAPH, -TREE, -COST)'
     is true if TREE is a spanning tree of an _undirected_ GRAPH with
     cost COST, if it exists.  Using a version of Prim's algorithm.


File: sicstus.info,  Node: lib-varnumbers,  Next: lib-wgraphs,  Prev: lib-ugraphs,  Up: The Prolog Library

10.30 An Inverse of numbervars/3--`library(varnumbers)'
=======================================================

The built-in predicate `numbervars/3' makes a term ground by binding
the variables in it to subterms of the form `'$VAR'(N)' where N is an
integer.  Most of the calls to `numbervars/3' look like
         numbervars(Term, 0, _)
   which can be abbreviated to
         numbervars(Term)
   if you use this package.

   `varnumbers/3' is a partial inverse to `numbervars/3':
         varnumbers(Term, N0, Copy)
   unifies COPY with a copy of TERM in which subterms of the form
`'$VAR'(N)' where N is an integer not less than N0 (that is, subterms
which might have been introduced by `numbervars/3' with second argument
N0) have been consistently replaced by new variables.  Since 0 is the
usual second argument of `numbervars/3', there is also
         varnumbers(Term, Copy)

   This provides a facility whereby a Prolog-like data base can be kept
as a term.  For example, we might represent `append/3' thus:
         Clauses = [
             (append([], '$VAR'(0), '$VAR'(0)) :- true),
             (append(['$VAR'(0)|'$VAR'(1), '$VAR'(2), ['$VAR'(0)|'$VAR(3)]) :-
                 append('$VAR'(1), '$VAR'(2), '$VAR'(3)))
         ]
   and we might access clauses from it by doing
         prove(Goal, Clauses) :-
                 member(Clause, Clauses),
                 varnumbers(Clause, (Goal:-Body)),
                 prove(Goal).

   Exported predicates:

`numbervars(+TERM)'
     makes TERM ground by binding variables to subterms `'$VAR'(N)' with
     values of N ranging from 0 up.

`varnumbers(+TERM, -COPY)'
     xo succeeds when TERM was a term producing by calling
     `numbervars(TERM)' and COPY is a copy of TERM with such subterms
     replaced by variables.

`varnumbers(+TERM, +N0, -COPY)'
     succeeds when TERM was a term produced by calling
     `numbervars(TERM, N0, N)' (so that all subterms `'$VAR'(X)' have
     `integer(X)', `X >= N0') and COPY is a copy of TERM with such
     subterms replaced by variables.


File: sicstus.info,  Node: lib-wgraphs,  Next: lib-xml,  Prev: lib-varnumbers,  Up: The Prolog Library

10.31 Weighted Graph Operations--`library(wgraphs)'
===================================================

This library module provides operations on weighted directed graphs.  A
weighted directed graph (wgraph) is represented as a list of
(VERTEX-EDGELIST) pairs, where the pairs are in standard order (as
produced by `keysort/2' with unique keys), the edgelist is a list of
(NEIGHBOR-WEIGHT) pair also in standard order (as produced by
`keysort/2' with unique keys), every weight is a nonnegative integer,
and every neighbor appears as a vertex even if it has no neighbors
itself.

   An undirected graph is represented as a directed graph where for
each edge (U,V) there is a symmetric edge (V,U).

   An edge (U,V) is represented as the term U-V.

   A vertex can be any term.  Two vertices are distinct iff they are
not identical (`==').

   A path is represented as a list of vertices.  No vertex can appear
twice in a path.

   Exported predicates:

`vertices/2'
`edges/2'
`add_vertices/3'
`neighbors/3'
`neighbours/3'
     Re-exported from `library(wgraphs)'.

`wgraph_to_ugraph(+WEIGHTEDGRAPH, -GRAPH)'
     is true if GRAPH has the same vertices and edges as WEIGHTEDGRAPH,
     except the edges of GRAPH are unweighted.  Could be defined as:

          wgraph_to_ugraph(WGraph, Graph) :-
          	(   foreach(V-WNeibs,WGraph),
          	    foreach(V-Neibs,Graph)
          	do  (   foreach(V1-_,WNeibs),
          		foreach(V1,Neibs)
          	    do  true
          	    )
          	).

`ugraph_to_wgraph(+GRAPH, -WEIGHTEDGRAPH)'
     is true if WEIGHTEDGRAPH has the same vertices and edges as GRAPH,
     except the edges of WEIGHTEDGRAPH all have weight 1.  Could be
     defined as:

          ugraph_to_wgraph(Graph, WGraph) :-
          	(   foreach(V-Neibs,Graph),
          	    foreach(V-WNeibs,WGraph)
          	do  (   foreach(V1,Neibs),
          	        foreach(V1-1,WNeibs)
          	    do  true
          	    )
          	).

`ugraph_to_wgraph(+SubGraph, +WeightedGraph, -WeightedSubGraph)'
     is true if WeightedSubGraph has the same vertices and edges as
     SubGraph and the same weights as the corresponding edges in
     WeightedGraph.

`vertices_edges_to_wgraph(+VERTICES, +EDGES, -WEIGHTEDGRAPH)'
     is true if VERTICES is a list of vertices, EDGES is a list of
     edges, and WEIGHTEDGRAPH is a graph built from VERTICES and EDGES.
     VERTICES and EDGES may be in any order.  The vertices mentioned in
     EDGES do not have to occur explicitly in VERTICES.  VERTICES may
     be used to specify vertices that are not connected to any edges.

`del_vertices(+WEIGHTEDGRAPH1, +VERTICES, -WEIGHTEDGRAPH2)'
     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with VERTICES and all
     edges to and from VERTICES removed from it.

`add_edges(+WEIGHTEDGRAPH1, +EDGES, -WEIGHTEDGRAPH2)'
     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with EDGES and their
     "to" and "from" vertices added to it.

`del_edges(+WEIGHTEDGRAPH1, +EDGES, -WEIGHTEDGRAPH2)'
     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with EDGES removed
     from it.

`transpose_wgraph(+WEIGHTEDGRAPH, -TRANSPOSE)'
     is true if TRANSPOSE is the graph computed by replacing each edge
     (U,V) in WEIGHTEDGRAPH by its symmetric edge (V,U).  It can only
     be used one way around.  The cost is O(N LOG N).

`transitive_closure(+WEIGHTEDGRAPH, -CLOSURE)'
     computes Closure as the transitive closure of WEIGHTEDGRAPH in
     O(N^3) time.  Uses Floyd's algorithm and fragments of Barney
     Pell's code.

`symmetric_closure(+WEIGHTEDGRAPH, -CLOSURE)'
     computes CLOSURE as the symmetric closure of WEIGHTEDGRAPH, i.e.
     for each edge (U,V) in WEIGHTEDGRAPH, add its symmetric edge
     (V,U).  Approx O(N LOG N) time.  This is useful for making a
     directed graph undirected.

`top_sort(+GRAPH, -SORTED)'
     finds a topological ordering of a GRAPH and returns the ordering
     as a list of SORTED vertices.  Fails iff no ordering exists, i.e.
     iff the graph contains cycles.  Takes O(N LOG N) time.

`max_path(+V1, +V2, +WEIGHTEDGRAPH, -PATH, -COST)'
     is true if PATH is a list of vertices constituting a longest path
     of cost Cost from V1 to V2 in WEIGHTEDGRAPH, there being no cyclic
     paths from V1 to V2.  Takes O(N^2) time.

`min_path(+V1, +V2, +WEIGHTEDGRAPH, -PATH, -COST)'
     is true if PATH is a list of vertices constituting a shortest path
     with total cost COST from V1 to V2 in WEIGHTEDGRAPH.  Takes O(N^2)
     time.

`min_paths(+VERTEX, +WEIGHTEDGRAPH, -TREE)'
     is true if TREE is a tree of all the shortest paths from VERTEX to
     every other vertex in WEIGHTEDGRAPH.  This is the single-source
     shortest paths problem.  Using Dijkstra's algorithm.

`path(+VERTEX, +WEIGHTEDGRAPH, -PATH)'
     is given a WEIGHTEDGRAPH and a VERTEX of that WEIGHTEDGRAPH, and
     returns a maximal PATH rooted at VERTEX, enumerating more PATHS on
     backtracking.

`reduce(+WEIGHTEDGRAPH, -REDUCED)'
     is true if REDUCED is the reduced graph for WEIGHTEDGRAPH. The
     vertices of the reduced graph are the strongly connected
     components of WEIGHTEDGRAPH.  There is an edge in REDUCED from U
     to V iff there is an edge in WEIGHTEDGRAPH from one of the
     vertices in U to one of the vertices in V. A strongly connected
     component is a maximal set of vertices where each vertex has a
     path to every other vertex.  Algorithm from "Algorithms" by
     Sedgewick, page 482, Tarjan's algorithm.

`reachable(+VERTEX, +WEIGHTEDGRAPH, -REACHABLE)'
     is given a WEIGHTEDGRAPH and a VERTEX of that WEIGHTEDGRAPH, and
     returns the set of vertices that are REACHABLE from that VERTEX.
     Takes O(N^2) time.

`random_wgraph(+P, +N, +W, -WEIGHTEDGRAPH)'
     where P is a probability, unifies WEIGHTEDGRAPH with a random
     graph with vertices 1..N where each possible edge is included with
     probability P and random weight in 1..W.

`min_tree(+WEIGHTEDGRAPH, -TREE, -COST)'
     is true if TREE is a minimum-COST spanning tree of an _undirected_
     WEIGHTEDGRAPH with cost COST, if it exists.  Using Kruskal's
     algorithm.


File: sicstus.info,  Node: lib-xml,  Next: lib-linda,  Prev: lib-wgraphs,  Up: The Prolog Library

10.32 Parsing and Generating XML--`library(xml)'
================================================

This is a package for parsing XML with Prolog, which provides Prolog
applications with a simple "Document Value Model" interface to XML
documents.  A description of the subset of XML that it supports can be
found at: `http://www.binding-time.co.uk/xmlpl.html'

   The package, originally written by Binding Time Ltd., is in the
public domain and unsupported.  To use the package, enter the query:

     | ?- use_module(library(xml)).

   The package represents XML documents by the abstract data type
DOCUMENT, which is defined by the following grammar:

DOCUMENT       ::=                           { well-formed document }
               `xml(ATTRIBUTES,CONTENT)'     
               |                             { malformed document }
               `malformed(ATTRIBUTES,CONTENT)'

ATTRIBUTES     ::= `[]'                      
               |                             
               `[NAME=CHAR-DATA|ATTRIBUTES]' 

CONTENT        ::= `[]'                      
               |   `[CTERM|CONTENT]'         

CTERM          ::= `pcdata(CHAR-DATA)'       { text }
               |   `comment(CHAR-DATA)'      { an XML comment }
               |                             { a Namespace }
               `namespace(URI,PREFIX,ELEMENT)'
               |                             { <TAG>..</TAG> encloses
               `element(TAGATTRIBUTES,CONTENT)'CONTENT or <TAG /> if empty }
               |                             { A PI <? NAME CHAR-DATA ?> }
               `instructions(NAME,CHAR-DATA)'
               |   `cdata(CHAR-DATA)'        { <![CDATA[CHAR-DATA]]>  }
               |                             { DTD <!DOCTYPE .. > }
               `doctype(TAG,DOCTYPE-ID)'     
               |   `unparsed(CHAR-DATA)'     { text that hasn't been
                                             parsed }
               |   `out_of_context(TAG)'     { TAG is not closed }

TAG            ::= "atom"                    { naming an element }

NAME           ::= "atom"                    { not naming an element }

URI            ::= "atom"                    { giving the URI of a
                                             namespace }

CHAR-DATA      ::= "code-list"               

DOCTYPE-ID     ::=                           
               `public(CHAR-DATA,CHAR-DATA)' 
               |                             
               `public(CHAR-DATA,DTD-LITERALS)'
               |   `system(CHAR-DATA)'       
               |                             
               `system(CHAR-DATA,DTD-LITERALS)'
               |   `local'                   
               |   `local,DTD-LITERALS'      

DTD-LITERALS   ::= `[]'                      
               |                             
               `[dtd_literal(CHAR-DATA)|DTD-LITERALS]'

   The following predicates are exported by the package:

`xml_parse(?CHARS, ?DOCUMENT)'
`xml_parse(?CHARS, ?DOCUMENT, +OPTIONS)'
     Either parses CHARS, a "code-list", to DOCUMENT, a DOCUMENT.
     CHARS is not required to represent strictly well-formed XML.  Or
     generates CHARS, a "code-list", from DOCUMENT, a DOCUMENT.  If
     DOCUMENT is not a valid DOCUMENT term representing well-formed
     XML, an exception is raised.  In the second usage of the
     predicate, the only option available is `format/1'.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false':

    `format(BOOLEAN)'
          Indent the element content (default `true').

    `extended_characters(BOOLEAN)'
          Use the extended character entities for XHTML (default
          `true').

    `remove_attribute_prefixes(BOOLEAN)'
          Remove namespace prefixes from attributes when it's the same
          as the prefix of the parent element (default `false').

`xml_subterm(+TERM, ?SUBTERM)'
     Unifies SUBTERM with a sub-term of TERM, a DOCUMENT. This can be
     especially useful when trying to test or retrieve a deeply-nested
     subterm from a document.

`xml_pp(+DOCUMENT)'
     "Pretty prints" DOCUMENT, a DOCUMENT, on the current output stream.


File: sicstus.info,  Node: lib-linda,  Next: lib-chr,  Prev: lib-xml,  Up: The Prolog Library

10.33 Process Communication--`library(linda/[server,client])'
=============================================================

Linda is a concept for process communication.

   For an introduction and a deeper description, see [Carreiro &
Gelernter 89a] or [Carreiro & Gelernter 89b], respectively.

   One process is running as a server and one or more processes are
running as clients.  The processes are communicating with sockets and
supports networks.

   The server is in principle a blackboard on which the clients can
write (`out/1'), read (`rd/1') and remove (`in/1') data.  If the data
is not present on the blackboard, the predicates suspend the process
until they are available.

   There are some more predicates besides the basic `out/1', `rd/1' and
`in/1'.  The `in_noblock/1' and `rd_noblock/1' does not suspend if the
data is not available--they fail instead.  A blocking fetch of a
conjunction of data can be done with `in/2' or `rd/2'.

   Example: A simple producer-consumer.  In client 1:
     producer :-
            produce(X),
            out(p(X)),
            producer.

     produce(X) :- .....

   In client 2:

     consumer :-
            in(p(A)),
            consume(A),
            consumer.

     consume(A) :- .....

   Example: Synchronization

            ...,
            in(ready),  %Waits here until someone does out(ready)
            ...,

   Example: A critical region

            ...,
            in(region_free),  % wait for region to be free
            critical_part,
            out(region_free), % let next one in
            ...,

   Example: Reading global data

            ...,
            rd(data(Data)),
            ...,

     or, without blocking:
            ...,
            rd_noblock(data(Data)) ->
                  do_something(Data)
            ;     write('Data not available!'),nl
            ),
            ...,

   Example: Waiting for one of several events

            ...,
            in([e(1),e(2),...,e(n)], E),
     %  Here is E instantiated to the first tuple that became available
            ...,

* Menu:

* lib-linda-server:: Linda Server
* lib-linda-client:: Linda Client


File: sicstus.info,  Node: lib-linda-server,  Next: lib-linda-client,  Up: lib-linda

10.33.1 Linda Server
--------------------

The server is the process running the "blackboard process".  It is an
ordinary SICStus process, which can be run on a separate machine if
necessary.

   To load the package, enter the query

     | ?- use_module(library('linda/server')).

and start the server with `linda/[0,1]'.

`linda'
     Starts a Linda-server in this SICStus.  The network address is
     written to the current output stream as HOST:PORTNUMBER.

`linda(:OPTIONS)'
     Starts a Linda-server in this SICStus. Each option on the list
     OPTIONS is one of
    `ADDRESS-GOAL'
          where ADDRESS must be unifiable with HOST:PORT and GOAL must
          be instantiated to a goal.

          When the linda server is started, HOST and PORT are bound to
          the server host and port respectively and the goal GOAL is
          called. A typical use of this would be to store the
          connection information in a file so that the clients can find
          the server to connect to.

          For backward compatibility, if OPTIONS is not a list, it is
          assumed to be an option of the form `ADDRESS-GOAL'.

          Before release 3.9.1, GOAL needed an explicit module prefix
          to ensure it was called in the right module. This is no
          longer necessary since `linda/1' is now a meta-predicate.

    `accept_hook(CLIENT,STREAM,GOAL)'
          When a client attempts to connects to the server CLIENT and
          STREAM will be bound to the IP address of the client and the
          socket stream connected to the client, respectively. The GOAL
          is then called, and if it succeeds, the client is allowed to
          connect. If GOAL fails, the server will close the stream and
          ignore the connection request. A typical use of this feature
          would be to restrict the addresses of the clients allowed to
          connect. If you require bullet proof security, you would
          probably need something more sophisticated.


     Example:
          | ?- linda([(Host:Port)-mypred(Host,Port),
                      accept_hook(C,S,should_accept(C,S))]).

     will call `mypred/2' when the server is started.  `mypred/2' could
     start the client-processes, save the address for the clients etc.
     Whenever a client attempts to connect from a host with IP address
     ADDR, a bi-directional socket stream STREAM will be opened to the
     client, and `should_accept(ADDR,STREAM)' will be called to
     determine if the client should be allowed to connect.



File: sicstus.info,  Node: lib-linda-client,  Prev: lib-linda-server,  Up: lib-linda

10.33.2 Linda Client
--------------------

The clients are one or more SICStus processes that have connection(s)
to the server.

   To load the package, enter the query

     | ?- use_module(library('linda/client')).

   Some of the following predicates fail if they don't receive an
answer from the Linda-server in a reasonable amount of time.  That time
is set with the predicate `linda_timeout/2'.

`linda_client(+ADDRESS)'
     Establishes a connection to a Linda-server specified by ADDRESS.
     The ADDRESS is of the format HOST:PORTNUMBER as given by
     `linda/[0,1]'.

     It is not possible to be connected to two Linda-servers at the
     same time.

     This predicate can fail due to a timeout.

`close_client'
     Closes the connection to the server.

`shutdown_server/0'
     Sends a Quit signal to the server, which immediately stops
     accepting new connections before `shutdown_server/0' returns. The
     server continues running after receiving this signal, processing
     requests from existing clients, until such time as all the clients
     have closed their connections. It is up to the clients to tell
     each other to quit. When all the clients are done, the server stops
     (i.e. `linda/[0,1]' succeeds).  Courtesy of Malcolm Ryan.  Note
     that `close_client/0' should be called _after_
     `shutdown_server/0'. `shutdown_server/0' will raise an error if
     there is no connection between the client and the server.

     The behavior of `shutdown_server/0' changed in SICStus Prolog 4.2.
     In previous releases the server continued to accept new connections
     after being told to shutdown. Now it immediately stops listening
     for new connections and releases the listening socket and these
     server actions happens before the client returns from
     `shutdown_server/0'.

`linda_timeout(?OLDTIME, ?NEWTIME)'
     This predicate controls Linda's timeout. OLDTIME is unified with
     the old timeout and then timeout is set to NEWTIME.  The value is
     either `off' or of the form SECONDS:MILLISECONDS.  The former
     value indicates that the timeout mechanism is disabled, that is,
     eternal waiting.  The latter form is the TIMEOUT-TIME.

`out(+TUPLE)'
     Places the tuple TUPLE in Linda's tuple-space.

`in(?TUPLE)'
     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, the predicate blocks until it is available (that is,
     someone performs an `out/1').

`in_noblock(?TUPLE)'
     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, the predicate fails.

     This predicate can fail due to a timeout.

`in(+TUPLELIST, ?TUPLE)'
     As `in/1' but succeeds when either of the tuples in TUPLELIST is
     available. TUPLE is unified with the fetched tuple.  If that
     unification fails, the tuple is _not_ reinserted in the
     tuple-space.

`rd(?TUPLE)'
     Succeeds if TUPLE is available in the tuple-space, suspends
     otherwise until it is available.  Compare this with `in/1': the
     tuple is _not_ removed.

`rd_noblock(?TUPLE)'
     Succeeds if TUPLE is available in the tuple-space, fails otherwise.

     This predicate can fail due to a timeout.

`rd(+TUPLELIST, ?TUPLE)'
     As `in/2' but does not remove any tuples.

`bagof_rd_noblock(?TEMPLATE, +TUPLE, ?BAG)'
     BAG is the list of all instances of TEMPLATE such that TUPLE
     exists in the tuple-space.

     The behavior of variables in TUPLE and TEMPLATE is as in
     `bagof/3'.  The variables could be existentially quantified with
     `^/2' as in `bagof/3'.

     The operation is performed as an atomic operation.

     This predicate can fail due to a timeout.

     Example: Assume that only one client is connected to the server
     and that the tuple-space initially is empty.
          | ?- out(x(a,3)), out(x(a,4)), out(x(b,3)), out(x(c,3)).

          | ?- bagof_rd_noblock(C-N, x(C,N), L).

          C = _32,
          L = [a-3,a-4,b-3,c-3],
          N = _52

          | ?- bagof_rd_noblock(C, N^x(C,N), L).

          C = _32,
          L = [a,a,b,c],
          N = _48


File: sicstus.info,  Node: lib-chr,  Next: lib-clpfd,  Prev: lib-linda,  Up: The Prolog Library

10.34 Constraint Handling Rules--`library(chr)'
===============================================

This section is written by Tom Schrijvers, K.U. Leuven, and adjustments
by Jan Wielemaker.

   The CHR system of SICStus Prolog is the K.U.Leuven CHR system.  The
runtime environment is written by Christian Holzbaur and Tom Schrijvers
while the compiler is written by Tom Schrijvers. Both are integrated
with SICStus Prolog and licensed under compatible conditions with
permission from the authors.

   The main reference for the CHR system is [Schrijvers & Demoen 04].

* Menu:

* CHR Introduction::
* CHR Syntax and Semantics::
* CHR in Prolog Programs::
* CHR Debugging::
* CHR Examples::
* CHR Guidelines::


File: sicstus.info,  Node: CHR Introduction,  Next: CHR Syntax and Semantics,  Up: lib-chr

10.34.1 Introduction
--------------------

Constraint Handling Rules (CHR) is a committed-choice rule-based
language embedded in Prolog. It is designed for writing constraint
solvers and is particularly useful for providing application-specific
constraints.  It has been used in many kinds of applications, like
scheduling, model checking, abduction, type checking among many others.

   CHR has previously been implemented in other Prolog systems (SICStus,
Eclipse, Yap), Haskell and Java. This CHR system is based on the
compilation scheme and runtime environment of CHR in SICStus.

   In this documentation we restrict ourselves to giving a short
overview of CHR in general and mainly focus on elements specific to this
implementation. For a more thorough review of CHR we refer the reader to
[Fruehwirth 98].

   In *note CHR Syntax and Semantics:: we present the syntax of CHR in
Prolog and explain informally its operational semantics. Next, *note
CHR in Prolog Programs:: deals with practical issues of writing and
compiling Prolog programs containing CHR. *note CHR Debugging::
explains the currently primitive CHR debugging facilities.  *note CHR
Debugging Predicates:: provides a few useful predicates to inspect the
constraint store and *note CHR Examples:: illustrates CHR with two
example programs.  Finally, *note CHR Guidelines:: concludes with a few
practical guidelines for using CHR.


File: sicstus.info,  Node: CHR Syntax and Semantics,  Next: CHR in Prolog Programs,  Prev: CHR Introduction,  Up: lib-chr

10.34.2 Syntax and Semantics
----------------------------

* Menu:

* CHR Syntax::
* CHR Semantics::


File: sicstus.info,  Node: CHR Syntax,  Next: CHR Semantics,  Up: CHR Syntax and Semantics

10.34.2.1 Syntax
................

The syntax of CHR rules is the following:

RULES          ::= RULE RULES
RULES          ::= EMPTY

RULE           ::= NAME ACTUAL_RULE PRAGMA `.'

NAME           ::= ATOM `@'
NAME           ::= EMPTY

ACTUAL_RULE    ::= SIMPLIFICATION_RULE
ACTUAL_RULE    ::= PROPAGATION_RULE
ACTUAL_RULE    ::= SIMPAGATION_RULE

SIMPLIFICATION_RULE::= HEAD `<=>' GUARD BODY
PROPAGATION_RULE::= HEAD `==>' GUARD BODY
SIMPAGATION_RULE::= HEAD `\' HEAD `<=>' GUARD BODY

HEAD           ::= CONSTRAINTS

CONSTRAINTS    ::= CONSTRAINT CONSTRAINT_ID
CONSTRAINTS    ::= CONSTRAINT CONSTRAINT_ID `,' CONSTRAINTS

CONSTRAINT     ::= COMPOUND_TERM

CONSTRAINT_ID  ::= EMPTY
CONSTRAINT_ID  ::= `#' VARIABLE

GUARD          ::= EMPTY
GUARD          ::= GOAL DISJ

BODY           ::= GOAL

PRAGMA         ::= EMPTY
PRAGMA         ::= `pragma' ACTUAL_PRAGMAS

ACTUAL_PRAGMAS ::= ACTUAL_PRAGMA
ACTUAL_PRAGMAS ::= ACTUAL_PRAGMA `,' ACTUAL_PRAGMAS

ACTUAL_PRAGMA  ::= `passive(VARIABLE)'

DISJ           ::= `;' | `|' { read as `;' unless `|' is declared infix }

   Note that the guard of a rule may not contain any goal that binds a
variable in the head of the rule with a non-variable or with another
variable in the head of the rule. It may however bind variables that
don't appear in the head of the rule, e.g. an auxiliary variable
introduced in the guard.

   Note also that, unless `|' has been declared as an operator, `|' and
`;' are indistinguishable as infix operators--both are read as `;'
(*note ref-syn-syn-sen::). So if e.g. a simplification rule is given as:

     HEAD `<=>' `(P ; Q)'
   CHR will break the ambiguity by treating P as the guard and Q as the
body, which is probably not what you want. To get the intended
interpretation, you must supply a dummy guard `true |':

     HEAD `<=>' `true | (P ; Q)'

   *Please note*: the above is true as long as you don't declare `|' as
an infix operator, which is possible since release 4.3 for ISO
compliance.  Declaring `|' as an infix operator will confuse CHR.


File: sicstus.info,  Node: CHR Semantics,  Prev: CHR Syntax,  Up: CHR Syntax and Semantics

10.34.2.2 Semantics
...................

In this subsubsection the operational semantics of CHR in Prolog are
presented informally. They don't differ essentially from other CHR
systems.

   When a constraint is called, it is considered an active constraint
and the system will try to apply the rules to it. Rules are tried and
executed sequentially in the order they are written.

   A rule is conceptually tried for an active constraint in the
following way. The active constraint is matched with a constraint in
the head of the rule. If more constraints appear in the head they are
looked for among the suspended constraints, which are called passive
constraints in this context. If the necessary passive constraints can
be found and all match with the head of the rule and the guard of the
rule succeeds, the rule is committed and the body of the rule executed.
If not all the necessary passive constraint can be found, the matching
fails or the guard fails, the body is not executed and the process of
trying and executing simply continues with the following rules. If for
a rule, there are multiple constraints in the head, the active
constraint will try the rule sequentially multiple times, each time
trying to match with another constraint.

   This process ends either when the active constraint disappears, i.e.
it is removed by some rule, or after the last rule has been processed.
In the latter case the active constraint becomes suspended.

   A suspended constraint is eligible as a passive constraint for an
active constraint. The other way it may interact again with the rules,
is when a variable appearing in the constraint becomes bound to either
a non-variable or another variable involved in one or more constraints.
In that case the constraint is triggered, i.e. it becomes an active
constraint and all the rules are tried.

   Rule Types.  There are three different kinds of rules, each with
their specific semantics:

"simplification"
     The simplification rule removes the constraints in its head and
     calls its body.

"propagation"
     The propagation rule calls its body exactly once for the
     constraints in its head.

"simpagation"
     The simpagation rule removes the constraints in its head after the
     `\' and then calls its body. It is an optimization of
     simplification rules of the form:

          CONSTRAINTS_1, CONSTRAINTS_2 <=> CONSTRAINTS_1, BODY

     namely, in the simpagation form:

          CONSTRAINTS_1 \ CONSTRAINTS_2 <=> BODY

     the CONSTRAINTS_1 constraints are not called in the body.

   Rule Names.  Naming a rule is optional and has no semantical
meaning. It only functions as documentation for the programmer.

   Pragmas.  The semantics of the pragmas are:

`passive(IDENTIFIER)'
     The constraint in the head of a rule IDENTIFIER can only match a
     passive constraint in that rule.

   Additional pragmas may be released in the future.

   Options.  

   It is possible to specify options that apply to all the CHR rules in
the module.  Options are specified with the `chr_option/2' declaration:

     :- chr_option(Option,Value).

and may appear in the file anywhere after the first constraints
declaration.

   Available options are:
`check_guard_bindings'
     This option controls whether guards should be checked for
     (illegal) variable bindings or not. Possible values for this
     option are `on', to enable the checks, and `off', to disable the
     checks. If this option is on, any guard fails when it binds a
     variable that appears in the head of the rule.  When the option is
     off, the behavior of a binding in the guard is undefined.

`optimize'
     This option controls the degree of optimization.  Possible values
     are `full', to enable all available optimizations, and `off' (the
     default), to disable all optimizations.  If optimization is
     enabled, debugging must be disabled.

`debug'
     This options enables or disables the possibility to debug the CHR
     code.  Possible values are `on' (the default) and `off'. See *note
     CHR Debugging:: for more details on debugging.


File: sicstus.info,  Node: CHR in Prolog Programs,  Next: CHR Debugging,  Prev: CHR Syntax and Semantics,  Up: lib-chr

10.34.3 CHR in Prolog Programs
------------------------------

* Menu:

* CHR Embedding in Prolog Programs::
* CHR Constraint Declaration::
* CHR Compilation::


File: sicstus.info,  Node: CHR Embedding in Prolog Programs,  Next: CHR Constraint Declaration,  Up: CHR in Prolog Programs

10.34.3.1 Embedding in Prolog Programs
......................................

The CHR constraints defined in a `.pl' file are associated with a
module. The default module is `user'. One should never load different
`.pl' files with the same CHR module name.


File: sicstus.info,  Node: CHR Constraint Declaration,  Next: CHR Compilation,  Prev: CHR Embedding in Prolog Programs,  Up: CHR in Prolog Programs

10.34.3.2 Constraint Declaration
................................

Every constraint used in CHR rules has to be declared with a
`chr_constraint/1' declaration by the "constraint specifier". For
convenience multiple constraints may be declared at once with the same
`chr_constraint/1' declaration followed by a comma-separated list of
constraint specifiers.

   A constraint specifier is, in its compact form, F/A where F and A
are respectively the functor name and arity of the constraint, e.g.

     :- chr_constraint foo/1.
     :- chr_constraint bar/2, baz/3.

   In its extended form, a constraint specifier is `C(A_1,...,A_N)'
where C is the constraint's functor, N its arity and the A_I are
argument specifiers. An argument specifier is a mode, optionally
followed by a type. E.g.

     :- chr_constraint get_value(+,?).
     :- chr_constraint domain(?int,+list(int)),
                        alldifferent(?list(int)).

   A mode is one of the following:

`-'
     The corresponding argument of every occurrence of the constraint
     is always unbound.

`+'
     The corresponding argument of every occurrence of the constraint
     is always ground.

`?'
     The corresponding argument of every occurrence of the constraint
     can have any instantiation, which may change over time. This is the
     default value.

   A type can be a user-defined type or one of the built-in types. A
type comprises a (possibly infinite) set of values. The type
declaration for a constraint argument means that for every instance of
that constraint the corresponding argument is only ever bound to values
in that set. It does not state that the argument necessarily has to be
bound to a value.

   The built-in types are:

`int'
     The corresponding argument of every occurrence of the constraint
     is an integer.

`float'
     ... a floating point number.

`number'
     ... a number.

`natural'
     ... a positive integer.

`any'
     The corresponding argument of every occurrence of the constraint
     can have any type. This is the default value.

   User-defined types are algebraic data types, similar to those in
Haskell or the discriminated unions in Mercury. An algebraic data type
is defined using

     :- chr_type TYPE ---> BODY.

   If the type term is a functor of arity zero (i.e. one having zero
arguments), it names a "monomorphic" type. Otherwise, it names a
"polymorphic" type; the arguments of the functor must be distinct type
variables. The body term is defined as a sequence of constructor
definitions separated by semi-colons.

   Each constructor definition must be a functor whose arguments (if
any) are types. Discriminated union definitions must be transparent: all
type variables occurring in the body must also occur in the type.

   Here are some examples of algebraic data type definitions:

     :- chr_type color ---> red ; blue ; yellow ; green.
     :- chr_type tree --->  empty ; leaf(int) ; branch(tree, tree).
     :- chr_type list(T) --->    [] ; [T | list(T)].
     :- chr_type pair(T1, T2) ---> (T1 - T2).

   Each algebraic data type definition introduces a distinct type. Two
algebraic data types that have the same bodies are considered to be
distinct types (name equivalence).

   Constructors may be overloaded among different types: there may be
any number of constructors with a given name and arity, so long as they
all have different types.

   Aliases can be defined using `=='. For example, if your program uses
lists of lists of integers, you can define an alias as follows:

     :- chr_type lli == list(list(int)).


File: sicstus.info,  Node: CHR Compilation,  Prev: CHR Constraint Declaration,  Up: CHR in Prolog Programs

10.34.3.3 Compilation
.....................

The Prolog CHR compiler exploits `user:term_expansion/6' rules to
translate the constraint handling rules to plain Prolog. These rules
are loaded from `library(chr)'.  They are activated after finding a
declaration of the format:

     :- chr_constraint ...

   It is advised to define CHR rules in a module-file, where the module
declaration is immediately followed by loading `library(chr)' as
exemplified below:

     :- module(zebra, [ zebra/0 ]).
     :- use_module(library(chr)).

     :- chr_constraint ...


File: sicstus.info,  Node: CHR Debugging,  Next: CHR Examples,  Prev: CHR in Prolog Programs,  Up: lib-chr

10.34.4 Debugging
-----------------

The CHR debugging facilities are currently rather limited. Only tracing
is currently available.  To use the CHR debugging facilities for a CHR
file it must be compiled for debugging. Generating debug info is
controlled by the CHR option `debug', whose default is derived from the
CHR flag `generate_debug_info'.

* Menu:

* CHR Ports::
* CHR Tracing::
* CHR Debugging Predicates::


File: sicstus.info,  Node: CHR Ports,  Next: CHR Tracing,  Up: CHR Debugging

10.34.4.1 Ports
...............

For CHR constraints the four standard ports are defined:

`call'
     A new constraint is called and becomes active.

`exit'
     An active constraint exits: it has either been inserted in the
     store after trying all rules or has been removed from the
     constraint store.

`fail'
     An active constraint fails.

`redo'
     An active constraint starts looking for an alternative solution.

   In addition to the above ports, CHR constraints have five additional
ports:

`wake'
     A suspended constraint is woken and becomes active.

`insert'
     An active constraint has tried all rules and is suspended in the
     constraint store.

`remove'
     An active or passive constraint is removed from the constraint
     store.

`try'
     An active constraints tries a rule with possibly some passive
     constraints. The try port is entered just before committing to the
     rule.

`apply'
     An active constraints commits to a rule with possibly some passive
     constraints. The apply port is entered just after committing to the
     rule.


File: sicstus.info,  Node: CHR Tracing,  Next: CHR Debugging Predicates,  Prev: CHR Ports,  Up: CHR Debugging

10.34.4.2 Tracing
.................

Tracing is enabled with the `chr_trace/0' predicate and disabled with
the `chr_notrace/0' predicate.

   When enabled, the tracer will step through the `call', `exit',
`fail', `wake' and `apply' ports, accepting debug commands, and simply
write out the other ports.

   The following debug commands are currently supported:

     CHR debug options:

             <cr>    creep           c       creep
             s       skip
             g       ancestors
             n       nodebug
             b       break
             a       abort
             f       fail
             ?       help            h       help

   Their meaning is:

`creep'
     Step to the next port.

`skip'
     Skip to exit port of this call or wake port.

`ancestors'
     Print list of ancestor call and wake ports.

`nodebug'
     Disable the tracer.

`break'
     Enter a recursive Prolog toplevel.  See `break/0'.

`abort'
     Exit to the toplevel.  See `abort/0'.

`fail'
     Insert failure in execution.

`help'
     Print the above available debug options.


File: sicstus.info,  Node: CHR Debugging Predicates,  Prev: CHR Tracing,  Up: CHR Debugging

10.34.4.3 Debugging Predicates
..............................

The `chr' module exports several predicates that allow inspecting and
printing the content of the constraint store.

`chr_trace/0'
     Activate the CHR tracer.  By default the CHR tracer is activated
     and deactivated automatically by the Prolog predicates `trace/0'
     and `notrace/0'.

`chr_notrace/0'
     De-activate the CHR tracer.  By default the CHR tracer is
     activated and deactivated automatically by the Prolog predicates
     `trace/0' and `notrace/0'.

`chr_leash(+SPEC)'
     Define the set of CHR ports on which the CHR tracer asks for user
     intervention (i.e. stops). SPEC is either a list of ports as
     defined in *note CHR Ports:: or a predefined alias.  Defined
     aliases are: `full' to stop at all ports, `none' or `off' to never
     stop, and `default' to stop at the `call', `exit', `fail', `wake'
     and `apply' ports.  See also `leash/1'.

`chr_flag(+FLAGNAME, ?OLDVALUE, ?NEWVALUE)'
     OLDVALUE is the value of the CHR flag FLAGNAME, and the new value
     of FLAGNAME is set to NEWVALUE.  The valid CHR flag are the
     following:

    `toplevel_show_store'
          If `on' (the default), the Prolog toplevel displays the
          constraint store at the end of each query. If `off', the
          toplevel does not display this.

    `generate_debug_info'
          Provides the default if the `debug' option is not given.  The
          valid values are `true' and `false' (the default).

    `optimize'
          Provides the default if the `optimize' option is not given.
          The valid values are `full' and `off' (the default).

`chr_show_store(+MOD)'
     Prints all suspended constraints of module MOD to the current
     output stream.



File: sicstus.info,  Node: CHR Examples,  Next: CHR Guidelines,  Prev: CHR Debugging,  Up: lib-chr

10.34.5 Examples
----------------

Here are two example constraint solvers written in CHR.

  1. The program below defines a solver with one constraint, `leq/2',
     which is a less-than-or-equal constraint, also known as a partial
     order constraint.

          :- module(leq,[leq/2]).
          :- use_module(library(chr)).

          :- chr_constraint leq/2.
          reflexivity   leq(X,X) <=> true.
          antisymmetry  leq(X,Y), leq(Y,X) <=> X = Y.
          idempotence   leq(X,Y) \ leq(X,Y) <=> true.
          transitivity  leq(X,Y), leq(Y,Z) ==> leq(X,Z).

     When the above program is loaded, you can call the `leq/2'
     constraint in a query, e.g.:

          | ?- leq(X,Y), leq(Y,Z).
          leq(X,Y),
          leq(X,Z),
          leq(Y,Z) ?

  2. The program below implements a simple finite domain constraint
     solver.

          :- module(dom,[dom/2]).
          :- use_module(library(chr)).
          :- use_module(library(sets), [intersection/3]).

          :- chr_constraint dom(?int,+list(int)).
          :- chr_type list(T) ---> [] ; [T|list(T)].

          dom(X,[]) <=> fail.
          dom(X,[Y]) <=> X = Y.
          dom(X,L) <=> nonvar(X) | memberchk(X,L).
          dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).

     When the above program is loaded, you can call the `dom/2'
     constraint in a query, e.g.:

          | ?- dom(A,[1,2,3]), dom(A,[3,4,5]).
          A = 3

   Finally, Martin Keser's WebCHR package at
`http://chr.informatik.uni-ulm.de/~webchr/' contains more than 40
example programs for SICStus 4, complete with documentation and example
queries.


File: sicstus.info,  Node: CHR Guidelines,  Prev: CHR Examples,  Up: lib-chr

10.34.6 Guidelines
------------------

In this subsection we cover several guidelines on how to use CHR to
write constraint solvers and how to do so efficiently.

Check guard bindings yourself.
     It is considered bad practice to write guards that bind variables
     of the head and to rely on the system to detect this at runtime.
     It is inefficient and obscures the working of the program.

Set semantics.
     The CHR system allows the presence of identical constraints, i.e.
     multiple constraints with the same functor, arity and arguments.
     For most constraint solvers, this is not desirable: it affects
     efficiency and possibly termination. Hence appropriate simpagation
     rules should be added of the form:

          CONSTRAINT \ CONSTRAINT <=> TRUE.

Multi-headed rules.
     Multi-headed rules are executed more efficiently when the
     constraints share one or more variables.

Mode and type declarations.
     Provide mode and type declarations to get more efficient program
     execution.

Compile once, run many times.
     Does consulting your CHR program take a long time? Probably it
     takes the CHR compiler a long time to compile the CHR rules into
     Prolog code. When you disable optimizations the CHR compiler will
     be a lot quicker, but you may lose performance.


File: sicstus.info,  Node: lib-clpfd,  Next: lib-clpb,  Prev: lib-chr,  Up: The Prolog Library

10.35 Constraint Logic Programming over Finite Domains--`library(clpfd)'
========================================================================

* Menu:

* CLPFD Intro:: Introduction
* CLPFD Caveats:: Caveats
* CLPFD Interface:: Solver Interface
* Available Constraints:: Available Constraints
* Enumeration Predicates:: Enumeration Predicates
* Statistics Predicates:: Statistics Predicates
* Answer Constraints:: Answer Constraints
* CLPFD Debugging:: Debugging
* Defining Global Constraints:: Defining Global Constraints
* Defining Primitive Constraints:: Defining Primitive Constraints
* CLPFD Coexisting:: Coexisting with Attributes and Blocked Goals
* CLPFD Example Programs:: Example Programs
* Syntax Summary:: Syntax Summary


File: sicstus.info,  Node: CLPFD Intro,  Next: CLPFD Caveats,  Up: lib-clpfd

10.35.1 Introduction
--------------------

The clp(FD) solver described in this chapter is an instance of the
general Constraint Logic Programming scheme introduced in [Jaffar &
Michaylov 87].  This constraint domain is particularly useful for
modeling discrete optimization and verification problems such as
scheduling, planning, packing, timetabling etc.  The treatise [Van
Hentenryck 89] is an excellent exposition of the theoretical and
practical framework behind constraint solving in finite domains, and
summarizes the work up to 1989.

   This solver has the following highlights:

   * A rich set of global constraints with state-of-the-art propagators.

   * Two classes of propagators are handled internally: indexicals and
     global propagators.

   * Propagators of both classes can be user-defined, by means of
     programming interfaces.

   * The constraints described in this chapter are automatically
     translated to sets of propagators.

   * The truth value of a primitive constraint can be reflected into a
     0/1-variable, i.e. a variable with domain `0..1' (reification).

   This library fully supports multiple SICStus runtimes in a process.

* Menu:

* Referencing CLPFD:: Referencing this Software
* Acknowledgments CLPFD:: Acknowledgments

   The rest of this chapter is organized as follows: How to load the
solver and how to write simple programs is explained in *note CLPFD
Interface::.  A description of all constraints that the solver provides
is contained in *note Available Constraints::.  The predicates for
searching for solution are documented in *note Enumeration
Predicates::.  The predicates for getting execution statistics are
documented in *note Statistics Predicates::.  A few notes on debugging
are given in *note CLPFD Debugging::.  A few example programs are given
in *note CLPFD Example Programs::.  Finally, *note Syntax Summary::
contains syntax rules for all expressions.

   The following sections discuss advanced features and are probably
only relevant to experienced users: How to control the amount of
information presented in answers to queries is explained in *note
Answer Constraints::.  How to add new global constraints via a
programming interface is described in *note Defining Global
Constraints::.  How to define new primitive constraints with indexicals
is described in *note Defining Primitive Constraints::.  The fine
points of coexisting with attributes and blocked goals are described in
*note CLPFD Coexisting::.


File: sicstus.info,  Node: Referencing CLPFD,  Next: Acknowledgments CLPFD,  Up: CLPFD Intro

10.35.1.1 Referencing this Software
...................................

When referring to this implementation of clp(FD) in publications,
please use the following reference:

     Carlsson M., Ottosson G., Carlson B.  `An Open-Ended Finite Domain
     Constraint Solver', Proc. Programming Languages: Implementations,
     Logics, and Programs, 1997.


File: sicstus.info,  Node: Acknowledgments CLPFD,  Prev: Referencing CLPFD,  Up: CLPFD Intro

10.35.1.2 Acknowledgments
.........................

The first version of this solver was written as part of Key Hyckenberg's
MSc thesis in 1995, with contributions from Greger Ottosson at the
Computing Science Department, Uppsala University.  The code was later
rewritten by Mats Carlsson with contributions by Nicolas Beldiceanu.
Pe'ter Szeredi contributed material for this manual chapter.

   The development of this software was supported by the Swedish
National Board for Technical and Industrial Development (NUTEK) under
the auspices of Advanced Software Technology (ASTEC) Center of
Competence at Uppsala University.

   We include a collection of examples, among which some have been
distributed with the INRIA implementation of clp(FD) [Diaz & Codognet
93].


File: sicstus.info,  Node: CLPFD Caveats,  Next: CLPFD Interface,  Prev: CLPFD Intro,  Up: lib-clpfd

10.35.2 Caveats and Limitations
-------------------------------

Following are some general statements about the constraints and
libraries of this library module.

Domain Variables
     Only small integers (*note Glossary::) and domain variables are
     allowed in finite domain constraints.  Whenever a domain variable
     is required in the argument of a constraint, a small integer can
     be given instead.  The conversion from unbound variable to domain
     variable is automatic.

Aliasing
     In case of variable aliasing, i.e. if a variable occurs more than
     once in a global constraint that is being posted, or due to a
     subsequent variable-variable unification, any guarantee to
     maintain a particular level of consistency no longer holds, and
     idempotency is almost always lost.

Termination
     Of course, all constraints and predicates terminate.  However, due
     to the combinatorial nature of constraint solving, and to the fact
     that constraint solving is based on filtering domains, which can
     be huge, pathological cases where termination takes extremely long
     time are easily constructed.  After about 15,000 years on a 64-bit
     machine, the following query terminates with a representation
     error, when the lower bound of X exceeds the small integer range:

          | ?- X #> abs(X).
          [... ... ...]
          ! Representation error in user:'t=<u+c'/3
          ! CLPFD integer overflow
          ! goal:  't=<u+c'(_245,_247,-1)

     Anyway, if you find non-pathological cases that take longer than
     reasonable time to terminate, please write to
     <sicstus-support@sics.se>.

Error Checking
     Contrary to most library modules, CLPFD constraints and predicates
     check their arguments to almost the same extent as built-in
     predicates.  If you find a case where reasonable error checking is
     missing, please write to <sicstus-support@sics.se>.


File: sicstus.info,  Node: CLPFD Interface,  Next: Available Constraints,  Prev: CLPFD Caveats,  Up: lib-clpfd

10.35.3 Solver Interface
------------------------

* Menu:

* Posting Constraints:: Posting Constraints
* A Constraint Satisfaction Problem:: A Constraint Satisfaction Problem
* Reified Constraints:: Reified Constraints

   The solver contains predicates for checking the consistency and
entailment of finite domain constraints, as well as solving for solution
values for your problem variables.

   In the context of this constraint solver, a "finite domain" is a
subset of small integers, and a "finite domain constraint" denotes a
relation over a tuple of small integers (*note Glossary::).  Hence,
only small integers and unbound variables are allowed in finite domain
constraints.

   All "domain variables", i.e. variables that occur as arguments to
finite domain constraints get associated with a finite domain, either
explicitly declared by the program, or implicitly imposed by the
constraint solver.  Temporarily, the domain of a variable may actually
be infinite, if it does not have a finite lower or upper bound.  If
during the computation a variable receives a new lower or upper bound
that cannot be represented as a small integer, an overflow condition is
issued.  This is expressed as silent failure or as a representation
error, subject to the `overflow' option of `fd_flag/3'.

   The set of current domains of all domain variables is called the
"domain store".  Domain store S is an "extension" of domain store T if
each domain in S is a subset of the corresponding domain in T.  If some
domain is empty, the store is "contradictory" and execution backtracks;
otherwise, it is "consistent".  

   At the end of a successful computation, all domains have usually
become singletons, i.e. the domain variables have become assigned.  The
domains don't become singletons automatically.  Usually, it takes some
amount of search to find an assignment that satisfies all constraints.
It is the programmer's responsibility to do so.  If some domain
variables are left unassigned in a computation, the garbage collector
will preserve all constraint data that is attached to them.

   *Please note*: if a term containing domain variables is written,
copied, asserted, gathered as a solution to `findall/3' and friends, or
raised as an exception, those domain variables will be replaced by
brand new variables in the copy.  To retain the domains and any
attached constraints, you can use `copy_term/3' with
`clpfd:full_answer' asserted (*note ref-lte-cpt:: and *note Answer
Constraints::).  *API change wrt. release 3.*

   Every finite domain constraint is implemented by a "propagator", or
a set of such.  Some constraints have alternative propagators with
differing properties.  All propagators act as coroutines performing
incremental constraint solving, removing values from domains, and/or
entailment checking.  They wake up by changes in the domains of its
arguments.  A propagator P can be seen as a function on constraint
store S: P(S) denotes the extension of S resulting from applying P on S.

   Propagators come in two kinds: "indexicals", stateless reactive
functional rules implemented by a stack machine and running, and
"global propagators", usually stateful, implemented in C or Prolog, and
using algorithms from many fields of computer science.  At the heart of
the constraint solver is a scheduler for propagators, where indexicals
have priority over global propagators.

   Certain properties of propagators are desirable:

Correct
     A correct propagator never removes values that are consistent wrt.
     its constraint. This property is mandatory.

Checking
     A checking propagator accepts all ground assignments that
     satisfies the given constraint, and rejects all ground assignments
     that violate it.  This property is also mandatory.

Contracting
     A contracting propagator never adds any value to any domain.  This
     property is also mandatory.

Monotone
     A propagator P is monotone if, for all domain stores S and T, S is
     an extension of T implies that P(S) is an extension of P(T).  This
     property is not mandatory but helps understanding and debugging.

Idempotent
     A propagator P is idempotent if, for all domain stores S, P(S)
     equals P(P(S)).

Domain-Consistent
     A domain-consistent propagator removes all inconsistent values.
     This property is not mandatory and only a few propagators have it.
     The reason is that the complexity of maintaining
     domain-consistency is often prohibitively high.

Bounds-Consistent
     A bounds-consistent propagator adjusts all inconsistent upper and
     lower domain bounds.  This property is not mandatory, and is
     implied by domain-consistency.  This property is more widespread
     and usually less costly to maintain than domain-consistency, but
     far from all propagators have it.


File: sicstus.info,  Node: Posting Constraints,  Next: A Constraint Satisfaction Problem,  Up: CLPFD Interface

10.35.3.1 Posting Constraints
.............................

A constraint is called as any other Prolog predicate.  When called, the
constraint is "posted" to the store.  For example:

     | ?- X in 1..5, Y in 2..8, X+Y #= T.
     X in 1..5,
     Y in 2..8,
     T in 3..13

     | ?- X in 1..5, T in 3..13, X+Y #= T.
     X in 1..5,
     T in 3..13,
     Y in -2..12

   Note that the answer constraint shows the domains of nonground query
variables, but does not show any constraints that may be attached to
them.

   Normally, after posting a constraint, propagation to fixpoint is
performed, which can be an overkill.  The following provides a means of
posting a set of constraints in one batch, suspending all propagation
until the whole set has been posted.  Suspending propagation can
significantly reduce posting overhead.

`fd_batch(+CONSTRAINTS)   "since release 4.2.1"'
     where CONSTRAINTS should be a list of constraints, user-defined or
     exported by `library(clpfd)'.  General Prolog goals among the
     constraints will have undefined behavior.


File: sicstus.info,  Node: A Constraint Satisfaction Problem,  Next: Reified Constraints,  Prev: Posting Constraints,  Up: CLPFD Interface

10.35.3.2 A Constraint Satisfaction Problem
...........................................

Constraint satisfaction problems (CSPs) are a major class of problems
for which this solver is ideally suited.  In a CSP, the goal is to pick
values from pre-defined domains for certain variables so that the given
constraints on the variables are all satisfied.

   As a simple CSP example, let us consider the Send More Money puzzle.
In this problem, the variables are the letters S, E, N, D, M, O, R, and
Y.  Each letter represents a digit between 0 and 9.  The problem is to
assign a value to each digit, such that SEND + MORE equals MONEY.

   A program that solves the puzzle is given below.  The program
contains the typical three steps of a clp(FD) program:

  1. declare the domains of the variables

  2. post the problem constraints

  3. look for a feasible solution via backtrack search, or look for an
     optimal solution via branch-and-bound search

   Sometimes, an extra step precedes the search for a solution: the
posting of surrogate constraints to break symmetries or to otherwise
help prune the search space.  No surrogate constraints are used in this
example.

   The domains of this puzzle are stated via the `domain/3' goal and by
requiring that S and M be greater than zero.  The two problem
constraint of this puzzle are the equation (`sum/8') and the constraint
that all letters take distinct values (`all_different/1').  Finally,
the backtrack search is performed by `labeling/2'.  Different search
strategies can be encoded in the `Type' parameter.  In the example
query, the default search strategy is used (select the leftmost
variable, try values in ascending order).

     :- use_module(library(clpfd)).

     mm([S,E,N,D,M,O,R,Y], Type) :-
          domain([S,E,N,D,M,O,R,Y], 0, 9),      % step 1
          S#>0, M#>0,
          all_different([S,E,N,D,M,O,R,Y]),     % step 2
          sum(S,E,N,D,M,O,R,Y),
          labeling(Type, [S,E,N,D,M,O,R,Y]).    % step 3

     sum(S, E, N, D, M, O, R, Y) :-
                       1000*S + 100*E + 10*N + D
          +            1000*M + 100*O + 10*R + E
          #= 10000*M + 1000*O + 100*N + 10*E + Y.

     | ?- mm([S,E,N,D,M,O,R,Y], []).
     D = 7,
     E = 5,
     M = 1,
     N = 6,
     O = 0,
     R = 8,
     S = 9,
     Y = 2


File: sicstus.info,  Node: Reified Constraints,  Prev: A Constraint Satisfaction Problem,  Up: CLPFD Interface

10.35.3.3 Reified Constraints
.............................

Instead of merely posting constraints it is often useful to reflect its
truth value into a 0/1-variable B, so that:

   * the constraint is posted if B is set to 1

   * the negation of the constraint is posted if B is set to 0

   * B is set to 1 if the constraint becomes entailed

   * B is set to 0 if the constraint becomes disentailed

   This mechanism is known as "reification".  Several frequently used
operations can be defined in terms of reified constraints.  A reified
constraint is written:

     | ?- CONSTRAINT #<=> B.

where CONSTRAINT is reifiable.  As an example of a constraint that uses
reification, consider `exactly(X,L,N)', defined to be true if X occurs
exactly N times in the list L.  It can be defined thus:

     exactly(_, [], 0).
     exactly(X, [Y|L], N) :-
         X #= Y #<=> B,
         N #= M+B,
         exactly(X, L, M).

   Finally, reified constraints can be used as terms inside arithmetic
expression.  The value of the term is 1 if the constraint is true, and 0
otherwise. For example:

     | ?- X #= 10, B #= (X#>=2) + (X#>=4) + (X#>=8).
     B = 3,
     X = 10


File: sicstus.info,  Node: Available Constraints,  Next: Enumeration Predicates,  Prev: CLPFD Interface,  Up: lib-clpfd

10.35.4 Available Constraints
-----------------------------

This section describes constraints that can be used with this solver,
organized into classes.  Unless documented otherwise, constraints are
not reifiable and don't guarantee any particular level of consistency.
Whenever a domain variable is required in the argument of a constraint,
a small integer can be given instead.

* Menu:

* Arithmetic Constraints:: Arithmetic Constraints
* Membership Constraints:: Membership Constraints
* Propositional Constraints:: Propositional Constraints
* Arithmetic-Logical Constraints:: Arithmetic-Logical Constraints
* Extensional Constraints:: Extensional Constraints
* Graph Constraints:: Graph Constraints
* Scheduling Constraints:: Scheduling Constraints
* Placement Constraints:: Placement Constraints
* Automata Constraints:: Automata Constraints
* User-Defined Constraints:: User-Defined Constraints


File: sicstus.info,  Node: Arithmetic Constraints,  Next: Membership Constraints,  Up: Available Constraints

10.35.4.1 Arithmetic Constraints
................................

`?EXPR RELOP ?EXPR   *reifiable*'
     defines an arithmetic constraint.  The syntax for EXPR and RELOP
     is defined by a grammar (*note Syntax of Arithmetic
     Expressions::).  Note that the expressions are not restricted to
     being linear.  Constraints over nonlinear expressions, however,
     will usually yield less constraint propagation than constraints
     over linear expressions.

     Arithmetic constraints can be reified as e.g.:

          | ?- X in 1..2, Y in 3..5, X#=<Y #<=> B.
          B = 1,
          X in 1..2,
          Y in 3..5

Linear arithmetic constraints, except equalities, maintain
bounds-consistency.  Their reified versions detect bounds-entailment and
-disentailment.

   The following constraints are among the library constraints that
general arithmetic constraints compile to.  They express a relation
between a sum or a scalar product and a value, using a dedicated
algorithm, which avoids creating any temporary variables holding
intermediate values.  If you are computing a sum or a scalar product,
it can be much more efficient to compute lists of coefficients and
variables and post a single sum or scalar product constraint than to
post a sequence of elementary constraints.

`sum(+XS, +RELOP, ?VALUE)'
     where XS is a list of integers or domain variables, RELOP is a
     relational symbol as above, and VALUE is an integer or a domain
     variable.  True if `sum(XS) RELOP VALUE'.  Corresponds roughly to
     `sumlist/2' in `library(lists)'.

`scalar_product(+COEFFS, +XS, +RELOP, ?VALUE)'
`scalar_product(+COEFFS, +XS, +RELOP, ?VALUE, +OPTIONS)'
     where COEFFS is a list of length N of integers, XS is a list of
     length N of integers or domain variables, RELOP is a relational
     symbol as above, and VALUE is an integer or a domain variable.
     True if `sum(COEFFS*XS) RELOP VALUE'.

     OPTIONS is a list that may include the following option.  It can
     be used to control the level of consistency used by the constraint.

    `consistency(CONS)'
          The value is one of the following:
         `domain'
               The constraint maintains domain-consistency.  *Please
               note*: This option is only meaningful if RELOP is `#=',
               and requires that any domain variables have finite
               bounds.

         `bounds'
         `value'
               The constraint tries to maintain bounds-consistency (the
               default).

   The following constraints constrain a value to be the minimum
(maximum) of a given list of values.

`minimum(?VALUE, +XS)'
     where XS is a list of integers or domain variables, and VALUE is
     an integer or a domain variable.  True if VALUE is the minimum of
     XS.  Corresponds to `min_member/2' in `library(lists)' and to
     `minimum/2' in MiniZinc.

`maximum(?VALUE, +XS)'
     where XS is a list of integers or domain variables, and VALUE is
     an integer or a domain variable.  True if VALUE is the maximum of
     XS.  Corresponds to `max_member/2' in `library(lists)' and to
     `maximum/2' in MiniZinc.



File: sicstus.info,  Node: Membership Constraints,  Next: Propositional Constraints,  Prev: Arithmetic Constraints,  Up: Available Constraints

10.35.4.2 Membership Constraints
................................

`domain(+VARIABLES, +MIN, +MAX)'
     where VARIABLES is a list of domain variables or integers, MIN is
     an integer or the atom `inf' (minus infinity), and MAX is an
     integer or the atom `sup' (plus infinity).  True if the variables
     all are elements of the range `MIN..MAX'.

`?X in +RANGE   *reifiable*'
     defines a membership constraint.  X is an integer or a domain
     variable and RANGE is a CONSTANTRANGE (*note Syntax of
     Indexicals::).  True if X is an element of the range.

`?X in_set +FDSET   *reifiable*'
     defines a membership constraint.  X is an integer or a domain
     variable and FDSET is an FD set (*note FD Set Operations::).  True
     if X is an element of the FD set.

   `in/2' and `in_set/2' constraints maintain domain-consistency and
their reified versions detect domain-entailment and -disentailment.


File: sicstus.info,  Node: Propositional Constraints,  Next: Arithmetic-Logical Constraints,  Prev: Membership Constraints,  Up: Available Constraints

10.35.4.3 Propositional Constraints
...................................

Propositional combinators can be used to combine reifiable constraints
into propositional formulae over such constraints.  Such formulae are
goal expanded by the system into sequences of reified constraints and
arithmetic constraints.  For example,

     X #= 4 #\/ Y #= 6

expresses the disjunction of two equality constraints.

   The leaves of propositional formulae can be reifiable constraints,
the constants 0 and 1, or 0/1-variables.  New primitive, reifiable
constraints can be defined with indexicals as described in *note
Defining Primitive Constraints::.

   The propositional combinators maintain domain-consistency and their
reified versions detect domain-entailment and -disentailment.  The
following propositional combinators are available:

`#\ :Q   *reifiable*'
     True if the constraint Q is false.

`:P #/\ :Q   *reifiable*'
     True if the constraints P and Q are both true.

`:P #\ :Q   *reifiable*'
     True if exactly one of the constraints P and Q is true.

`:P #\/ :Q   *reifiable*'
     True if at least one of the constraints P and Q is true.

`:P #=> :Q   *reifiable*'
`:Q #<= :P   *reifiable*'
     True if the constraint Q is true or the constraint P is false.

`:P #<=> :Q   *reifiable*'
     True if the constraints P and Q are both true or both false.

   Note that the reification scheme introduced in *note Reified
Constraints:: is a special case of a propositional constraint.


File: sicstus.info,  Node: Arithmetic-Logical Constraints,  Next: Extensional Constraints,  Prev: Propositional Constraints,  Up: Available Constraints

10.35.4.4 Arithmetic-Logical Constraints
........................................

`smt(:CONSTRAINTBODY)   "since release 4.2"'
     The arithmetic, membership, and propositional constraints described
     earlier are transformed at compile time to conjunctions of library
     constraints.  Although linear in the size of the source code, the
     expansion of a propositional formula over reifiable constraints to
     library goals can have time and memory overheads, and propagates
     disjunctions very weakly.  Temporary variables holding intermediate
     values may have to be introduced, and the grain size of the
     constraint solver invocations can be rather small.  As an
     alternative to the default propagation of such constraint
     formulas, this constraint is a front-end to the `case/[3,4]'
     propagator, which treats such a formula globally.  The pruning can
     be stronger and it can run faster than the default propagator, but
     this is not necessarily the case.  Bounds-consistency is not
     guaranteed.

     CONSTRAINTBODY should be of one of the following forms, or a
     propositional combination of such forms.  *Note Syntax of
     Indexicals:: for the exact definition:

        * "var" `in' CONSTANTRANGE

        * `element("var",CLIST,"var")'

        * `table([VLIST],CTABLE)'

        * LINEXPR RELOP LINEXPR

        * "var" { `X' stands for `X#=1' }

`count(+VAL,+LIST,+RELOP,?COUNT)   "since release 4.0.5,deprecated"'
     where VAL is an integer, LIST is a list of integers or domain
     variables, COUNT an integer or a domain variable, and RELOP is a
     relational symbol as in *note Arithmetic Constraints::.  True if N
     is the number of elements of LIST that are equal to VAL and N
     RELOP COUNT.  Implemented by decomposition into one `sum/3'
     constraint, one arithmetic comparison, and several reified
     equalities.

     Corresponds to `count_*/3', `exactly/3' in MiniZinc.

     `count/4' maintains domain-consistency, but in practice, the
     following constraint is a better alternative.

`global_cardinality(+XS,+VALS)'
`global_cardinality(+XS,+VALS,+OPTIONS)'
     where XS = [X1,...,XD] is a list of integers or domain variables,
     and VALS = [K1-V1,...,KN-VN] is a list of pairs where each key KI
     is a unique integer and VI is a domain variable or an integer.
     True if every element of XS is equal to some key and for each pair
     KI-VI, exactly VI elements of XS are equal to KI.

     If either XS or VALS is ground, and in many other special cases,
     `global_cardinality/[2,3]' maintains domain-consistency, but
     generally, bounds-consistency cannot be guaranteed.  An
     domain-consistency algorithm [Regin 96] is used, roughly linear in
     the total size of the domains.

     Corresponds to `global_cardinality*/*' and `distribute/3' in
     MiniZinc.

     OPTIONS is a list of zero or more of the following:

    `consistency(CONS)'
          Which filtering algorithm to use.  One of the following:
         `domain'
               The constraint will use the algorithm mentioned above.
               Implies `on(dom)'.  The default.

         `bounds'
               The constraint will use the algorithm mentioned above.
               Implies `on(minmax)'.

         `value'
               The constraint will use a simple algorithm, which
               prevents too few or too many of the XS from taking
               values among the VALS.  Implies `on(val)'.

    `on(ON)'
          How eagerly to wake up the constraint.  One of the following:
         `dom'
               to wake up when the domain of a variable is changed (the
               default);

         `minmax'
               to wake up when a bound of a variable is changed;

         `val'
               to wake up when a variable becomes ground.

    `cost(COST,MATRIX)'
          Overrides any `consistency/1' option value.  A cost is
          associated with the constraint and reflected into the domain
          variable COST.  MATRIX should be a D*N matrix of integers,
          represented as a list of D lists, each of length N.  Assume
          that each XI equals K(PI).  The cost of the constraint is then
          MATRIX[1,P1]+...+MATRIX[D,PD].

          With this option, a domain-consistency algorithm [Regin 99]
          is used, the complexity of which is roughly O(D(M + N LOG N))
          where M is the total size of the domains.

`all_different(+VARIABLES)'
`all_different(+VARIABLES, +OPTIONS)'
`all_distinct(+VARIABLES)'
`all_distinct(+VARIABLES, +OPTIONS)'
     where VARIABLES is a list of domain variables or integers.  Each
     variable is constrained to take a value that is unique among the
     variables.  Declaratively, this is equivalent to an inequality
     constraint for each pair of variables.

     Corresponds to `alldifferent/1' in MiniZinc.

     OPTIONS is a list of zero or more of the following:

    `L #= R   "since release 4.3"'
          where R should be an integer, and R an expressions on one of
          the following forms, where X1, ..., XJ occur among VARIABLES:
         `X1 + ... + XJ'

         `X1*X1 + ... + XJ*XJ'

         `X1 * ... * XJ'
          The given equation is a side-constraint for the constraint to
          hold.  A special bounds-consistency algorithm is used, which
          considers the main constraint and the side-constraints
          globally.  This option is only valid if the domains of X1,
          ..., XJ consist of integers strictly greater than zero.

    `consistency(CONS)'
          Which algorithm to use, one of the following:

         `domain'
               The default for `all_distinct/[1,2]' and
               `assignment/[2,3]'.  A domain-consistency algorithm
               [Regin 94] is used, roughly linear in the total size of
               the domains.  Implies `on(dom)'.

         `bounds'
               A bounds-consistency algorithm [Lopez-Ortiz 03] is used,
               which runs in O(N LOG N) time for N variables.  Implies
               `on(minmax)'.

         `value'
               The default for `all_different/[1,2]'.  An algorithm
               achieving exactly the same pruning as a set of pairwise
               inequality constraints is used, roughly linear in the
               number of variables.  Implies `on(val)'.

    `on(ON)'
          How eagerly to wake up the constraint.  One of the following:
         `dom'
               (the default for `all_distinct/[1,2]' and
               `assignment/[2,3]'), to wake up when the domain of a
               variable is changed;

         `min'
               to wake up when the lower bound of a domain is changed;

         `max'
               to wake up when the upper bound of a domain is changed;

         `minmax'
               to wake up when some bound of a domain is changed;

         `val'
               (the default for `all_different/[1,2]'), to wake up when
               a variable becomes ground.

`nvalue(?N, +VARIABLES)'
     where VARIABLES is a list of domain variables with finite bounds
     or integers, and N is an integer or a domain variable.  True if N
     is the number of distinct values taken by VARIABLES.  Approximates
     bounds-consistency in N and domain-consistency in VARIABLES.  Can
     be thought of as a relaxed version of `all_distinct/2'.

     Corresponds to `nvalue/2' in MiniZinc.

   The following is a constraint over two lists of length N of
variables.  Each variable is constrained to take a value in [1,N] that
is unique for its list.  Furthermore, the lists are dual in a sense
described below.

`assignment(+XS, +YS)'
`assignment(+XS, +YS, +OPTIONS)'
     where XS = [X1,...,XN] and YS = [Y1,...,YN] are lists of domain
     variables or integers.  True if all XI, YI IN [1,N] and XI=J IFF
     YJ=I.

     Corresponds to `inverse/2' in MiniZinc.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `on(ON)'
          Same meaning as for `all_different/2'.

    `consistency(CONS)'
          Same meaning as for `all_different/2'.

    `circuit(BOOLEAN)'
          If `true', `circuit(XS,YS)' must hold for the constraint to
          be true.

    `cost(COST,MATRIX)'
          A cost is associated with the constraint and reflected into
          the domain variable COST.  MATRIX should be an N*N matrix of
          integers, represented as a list of lists.  The cost of the
          constraint is MATRIX[1,X1]+...+MATRIX[N,XN].

          With this option, a domain-consistency algorithm [Sellmann
          02] is used, the complexity of which is roughly O(N(M + N LOG
          N)) where M is the total size of the domains.

   The following constraint captures the relation between a list of
values, a list of the values in ascending order, and their positions in
the original list:

`sorting(+XS,+PS,+YS)'
     where XS = [X1,...,XN], PS = [P1,...,PN], and YS = [Y1,...,YN] are
     lists of domain variables or integers.  The constraint holds if
     the following are true:

        * YS is in ascending order.

        * PS is a permutation of [1,N].

        * FOR ALL I IN [1,N] : XI = Y(PI)

     In practice, the underlying algorithm [Mehlhorn 00] is likely to
     achieve bounds-consistency, and is guaranteed to do so if PS is
     ground or completely free.

     Corresponds to `sort/2' in MiniZinc.

   The following constraints express the fact that several vectors of
domain variables are in ascending lexicographic order:

`lex_chain(+VECTORS)'
`lex_chain(+VECTORS,+OPTIONS)'
     where VECTORS is a list of vectors (lists) of domain variables
     with finite bounds or integers.  The constraint holds if VECTORS
     are in ascending lexicographic order.

     Corresponds to `*lex2/1', `lex_greater*/2', `lex_less*/2' in
     MiniZinc.

     OPTIONS is a list of zero or more of the following:

    `op(OP)'
          If OP is the atom `#=<' (the default), the constraints holds
          if VECTORS are in non-descending lexicographic order.  If OP
          is the atom `#<', the constraints holds if VECTORS are in
          strictly ascending lexicographic order.

    `increasing'
          This option imposes the additional constraint that each
          vector in VECTORS be sorted in strictly ascending order.

    `among(LEAST,MOST,VALUES)'
          If given, LEAST and MOST should be integers such that 0 <=
          LEAST <= MOST and VALUES should be a list of distinct
          integers.  This option imposes the additional constraint on
          each vector in VECTORS that at least LEAST and at most MOST
          elements belong to VALUES.

    `global(BOOLEAN)   "since release 4.2.1"'
          if `true', a more expensive algorithm [Carlsson & Beldiceanu
          02], which guaranteed domain-consistency unless the
          `increasing/0' or `among/3' options are given, will be used.

   In the following constraints, a _literal_ is either a term `X' or a
term `#\ X', where `X' is a 0/1 variable.  They maintain
domain-consistency:

`bool_and(+LITS, +LIT)   "since release 4.3"'
     where LITS is a list of literals `[L0,...,Lj]' and LIT is a
     literal.  True if LIT equals the Boolean conjunction of LITS, and
     usually more efficient than the equivalent `L0#/\...#/\Lj #<=>
     Lit'.

`bool_or(+LITS, +LIT)   "since release 4.3"'
     where LITS is a list of literals `[L0,...,Lj]' and LIT is a
     literal.  True if LIT equals the Boolean disjunction of LITS, and
     usually more efficient than the equivalent `L0#\/...#\/Lj #<=>
     Lit'.

`bool_xor(+LITS, +LIT)   "since release 4.3"'
     where LITS is a list of literals `[L0,...,Lj]' and LIT is a
     literal.  True if LIT equals the Boolean exclusive or of LITS, and
     usually more efficient than the equivalent `L0#\...#\Lj #<=> Lit'.

`bool_channel(+LITS, ?Y, +RELOP, +OFFSET)   "since release 4.3"'
     where LITS is a list of literals `[L0,...,Lj]', Y is a domain
     variable, RELOP is an arithmetic comparison as in *note Syntax of
     Arithmetic Expressions::, and OFFSET is an integer.  Expresses the
     constraint LI #<=> (Y RELOP I+OFFSET) for `I in 0..j'. Usually
     more efficient than a bunch of reified comparisons between a given
     variable and a sequence of integers.


File: sicstus.info,  Node: Extensional Constraints,  Next: Graph Constraints,  Prev: Arithmetic-Logical Constraints,  Up: Available Constraints

10.35.4.5 Extensional Constraints
.................................

`element(?X,+LIST,?Y)'
     where X and Y are integers or domain variables and LIST is a list
     of integers or domain variables.  True if the X:th element of LIST
     is Y.  Operationally, the domains of X and Y are constrained so
     that for every element in the domain of X, there is a compatible
     element in the domain of Y, and vice versa.

     Maintains domain-consistency in X and bounds-consistency in LIST
     and Y.  Corresponds to `nth1/3' in `library(lists)' and to
     `element/3' and `member/2' in MiniZinc.

`relation(?X,+MAPLIST,?Y)   "since release 4.0.5,deprecated"'
     where X and Y are integers or domain variables and MAPLIST is a
     list of `INTEGER-CONSTANTRANGE' pairs, where the integer keys
     occur uniquely (*note Syntax of Indexicals::).  True if MAPLIST
     contains a pair `X-R' and Y is in the range denoted by R.
     Maintains domain-consistency.

     An arbitrary binary constraint can be defined with `relation/3'.
     `relation/3' is implemented by straightforward transformation to
     the following, more general constraint, with which arbitrary
     relations can be defined compactly:

`table(+TUPLES,+EXTENSION)'
`table(+TUPLES,+EXTENSION,+OPTIONS)'
     Defines an N-ary constraint by extension.  EXTENSION should be a
     list of lists of integers, each of length N.  TUPLES should be a
     list of lists of domain variables or integers, each also of length
     N.  The constraint holds if every TUPLE in TUPLES occurs in the
     EXTENSION.  The constraint will maintain domain-consistency.

     Corresponds to `table/2' in MiniZinc.

     For convenience, EXTENSION may contain CONSTANTRANGE (*note Syntax
     of Indexicals::) expressions in addition to integers.

     OPTIONS is a list of zero or more of the following:

    `consistency(CONS)   *obsolescent*'
          Ignored.

    `nodes(NB)'
          NB is unified with the number of DAG nodes.

    `order(ORDER)   "since release 4.1"'
          Determines the variable order of the DAG.  The following
          values are valid:
         `leftmost'
               The order is the one given in the arguments (the
               default).

         `id3'
               Each tuple, and the columns of the extension, is
               permuted according to the heuristic that more
               discriminating columns should precede less
               discriminating ones.

    `method(METHOD)   "since release 4.1"'
          Controls the way the DAG is generated from the extension,
          after permuting it if `order(id3)' was chosen.  The following
          values are valid:
         `noaux'
               Equivalent DAG nodes are merged until no further merger
               is possible.

         `aux'
               An auxiliary, first variable is introduced, denoting
               extension row number.  Then equivalent DAG nodes are
               merged until no further merger is possible.

`table/[2,3]' is implemented in terms of the following, more general
constraint, with which arbitrary relations can be defined compactly:

`case(+TEMPLATE, +TUPLES, +DAG)'
`case(+TEMPLATE, +TUPLES, +DAG, +OPTIONS)'
     This constraint encodes an N-ary constraint, defined by extension
     and/or linear inequalities.  It uses a DAG-shaped data structure
     where nodes corresponds to variables and every arc is labeled by
     an admissible interval for the node above it and optionally by
     linear inequalities.  The variable order is fixed: every path from
     the root node to a leaf node should visit every variable exactly
     once, in the order in which they occur lexically in TEMPLATE.  The
     constraint is true for a single ground tuple if there is a path
     from the root node to a leaf node such that (a) each tuple element
     is contained in the corresponding MIN..MAX interval on the path,
     and (b) any encountered linear inequalities along the path are
     true.  The constraint is true for a set of ground tuples if it is
     true for each tuple of the set. The details are given below.

     TEMPLATE is a nonground Prolog term, each variable of which should
     occur exactly once.  Its variables are merely place-holders; they
     should not occur outside the constraint nor inside TUPLES.

     TUPLES is a list of terms of the same shape as TEMPLATE.  They
     should not share any variables with TEMPLATE.

     DAG is a list of "nodes" of the form `node(ID,X,CHILDREN)', where
     X is a template variable, and ID should be an integer, uniquely
     identifying each node.  The first node in the list is the "root
     node".   Nodes are either INTERNAL NODES or LEAF NODES.  For an
     internal node, CHILDREN is a list of terms `(MIN..MAX)-ID2' or
     `(MIN..MAX)-SIDECONSTRAINTS-ID2', where ID2 is the ID of a child
     node, MIN is an integer or the atom `inf' (minus infinity), and
     MAX is an integer or the atom `sup' (plus infinity).  For a leaf
     node, CHILDREN is a list of terms `(MIN..MAX)' or
     `(MIN..MAX)-SIDECONSTRAINTS'.

     SIDECONSTRAINTS is a list of side constraints of the form
     `scalar_product(COEFFS, XS, #=<, BOUND)', where COEFFS is a list
     of length K of integers, XS is a list of length K of template
     variables, and BOUND is an integer.

     Variables in TUPLES for which their template variable counterparts
     are constrained by side constraints, must have bounded domains.
     In the absence of side constraint, the constraint maintains
     domain-consistency.

     OPTIONS is a list of zero or more of the following:

    `scalar_product(COEFFS, XS, #=<, BOUND)   "since release 4.2"'
          A side constraint located at the root of the DAG.

    `on(SPEC)   *obsolescent*'
          Ignored.

    `prune(SPEC)   *obsolescent*'
          Ignored.

     For example, recall that `element(X,L,Y)' wakes up when the domain
     of X or the lower or upper bound of Y has changed, performs full
     pruning of X, but only prunes the bounds of Y.  The following two
     constraints:

          element(X, [1,1,1,1,2,2,2,2], Y),
          element(X, [10,10,20,20,10,10,30,30], Z)

     can be replaced by the following single constraint, which is
     equivalent declaratively, but which maintains domain-consistency:

          elts(X, Y, Z) :-
              case(f(A,B,C), [f(X,Y,Z)],
                   [node(0, A,[(1..2)-1,(3..4)-2,(5..6)-3,(7..8)-4]),
                    node(1, B,[(1..1)-5]),
                    node(2, B,[(1..1)-6]),
                    node(3, B,[(2..2)-5]),
                    node(4, B,[(2..2)-7]),
                    node(5, C,[(10..10)]),
                    node(6, C,[(20..20)]),
                    node(7, C,[(30..30)])]).

     The DAG of the previous example has the following shape:


      [image src="images/clpfd1.png" text="" ]                     DAG corresponding to `elts/3'.

     A couple of sample queries:

          | ?- elts(X, Y, Z).
          X in 1..8,
          Y in 1..2,
          Z in {10}\/{20}\/{30}

          | ?- elts(X, Y, Z), Z #>= 15.
          X in(3..4)\/(7..8),
          Y in 1..2,
          Z in {20}\/{30}

          | ?- elts(X, Y, Z), Y = 1.
          Y = 1,
          X in 1..4,
          Z in {10}\/{20}

     As an example with side constraints, consider assigning tasks to
     machines with given unavailibility periods. In this case, one can
     use a "calendar" constraint [CHIP 03, Beldiceanu, Carlsson &
     Rampon 05] to link the real origins of the tasks (taking the
     unavailibility periods into account) with virtual origins of the
     tasks (not taking the unavailibility periods into account). One
     can then state machine resource constraints using the virtual
     origins, and temporal constraints between the tasks using the real
     origins.

     Assume, for example, three machines with unavailibility periods
     given by the following table:

                       [image src="images/clpfd3.png" ]
                 Unavailibility periods for three machines.

     Machine `1' is not available during (real) time periods `1-2' and
     `6-6', machine `2' is not available during (real) time periods
     `3-4' and `7-7', and machine `3' is always available.

     The following can then be used to express a calendar constraint
     for a given task scheduled on machine `M in 1..3', with virtual
     origin `V in 1..8', and real origin `R in 1..8':

          calendar(M, V, R) :-
                  M in 1..3,
                  V in 1..8,
                  R in 1..8,
                  smt((M#=1 #/\ V in 1..3 #/\ R#=V+2) #\/
                      (M#=1 #/\ V in 4..5 #/\ R#=V+3) #\/
                      (M#=2 #/\ V in 1..2 #/\ R#=V) #\/
                      (M#=2 #/\ V in 3..4 #/\ R#=V+2) #\/
                      (M#=2 #/\ V in 5..5 #/\ R#=V+3) #\/
                      (M#=3               #/\ R#=V)).

     or equivalently as:

          calendar(M, V, R) :-
              case(f(A,B,C),
                   [f(M,V,R)],
                   [node(0, A, [(1..1)-1, (2..2)-2, (3..3)-3]),
                    node(1, B, [(1..3)-[scalar_product([1,-1],[B,C],#=<,-2),
                                        scalar_product([1,-1],[C,B],#=<, 2)]-4,
                                (4..5)-[scalar_product([1,-1],[B,C],#=<,-3),
                                        scalar_product([1,-1],[C,B],#=<, 3)]-4]),
                    node(2, B, [(1..2)-[scalar_product([1,-1],[B,C],#=<, 0),
                                        scalar_product([1,-1],[C,B],#=<, 0)]-4,
                                (3..4)-[scalar_product([1,-1],[B,C],#=<,-2),
                                        scalar_product([1,-1],[C,B],#=<, 2)]-4,
                                (5..5)-[scalar_product([1,-1],[B,C],#=<,-3),
                                        scalar_product([1,-1],[C,B],#=<, 3)]-4]),
                    node(3, B, [(1..8)-[scalar_product([1,-1],[B,C],#=<, 0),
                                        scalar_product([1,-1],[C,B],#=<, 0)]-4]),
                    node(4, C, [(1..8)])]).

     Note that equality must be modeled as the conjunction of
     inequalities, as only constraints of the form
     `scalar_product(+COEFFS, +XS, #=<, +BOUND)' are allowed as side
     constraints.

     The DAG of the calendar constraint has the following shape:


      [image src="images/clpfd2.png" ]                   DAG corresponding to `calendar/3'.

     A couple of sample queries:

          | ?- M in 1..3, V in 1..8, R in 1..8, calendar(M, V, R).
          M in 1..3,
          V in 1..8,
          R in 1..8

          | ?- M in 1..3, V in 1..8, R in 1..8, calendar(M, V, R), M #= 1.
          M = 1,
          V in 1..5,
          R in 1..8

          | ?- M in 1..3, V in 1..8, R in 1..8, calendar(M, V, R), M #= 2, V #> 4.
          M = 2,
          V = 5,
          R = 8


File: sicstus.info,  Node: Graph Constraints,  Next: Scheduling Constraints,  Prev: Extensional Constraints,  Up: Available Constraints

10.35.4.6 Graph Constraints
...........................

The following constraint can be thought of as constraining N nodes in a
graph to form a Hamiltonian circuit.  The nodes are numbered from 1 to
N.  The circuit starts in node 1, visits each node, and returns to the
origin.

`circuit(+SUCC)'
`circuit(+SUCC, +PRED)'
     where SUCC is a list of length N of domain variables or integers.
     The I:th element of SUCC (PRED) is the successor (predecessor) of
     I in the graph.  True if the values form a Hamiltonian circuit.

     Corresponds to `circuit/1' in MiniZinc.


File: sicstus.info,  Node: Scheduling Constraints,  Next: Placement Constraints,  Prev: Graph Constraints,  Up: Available Constraints

10.35.4.7 Scheduling Constraints
................................

The following constraint can be thought of as constraining N tasks so
that the total resource consumption does not exceed a given limit at
any time.  *API change wrt. release 3:*

`cumulative(+TASKS)'
`cumulative(+TASKS,+OPTIONS)'
     A task is represented by a term `task(OI,DI,EI,HI,TI)' where OI is
     the start time, DI the non-negative duration, EI the end time, HI
     the non-negative resource consumption, and TI the task identifier.
     All fields are domain variables with bounded domains, or integers.

     Let N be the number of tasks and L the global resource limit (by
     default 1, but see below), and:

          HIJ = HI, if OI <= J < OI+DI
          HIJ = 0 otherwise

     The constraint holds if:

       1. For every task I, OI+DI=EI, and

       2. For all instants J, H1J+...+HNJ <= L.

     Corresponds to `cumulative/4' in MiniZinc.  If all durations are
     1, corresponds to `bin_packing/3' in MiniZinc.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default).

    `limit(L)'
          See above.

    `precedences(PS)'
          PS encodes a set of precedence constraints to apply to the
          tasks.  PS should be a list of terms of the form:

               `TI-TJ #= DIJ'

          where TI and TJ should be task identifiers, and DIJ should be
          a a domain variable (or an integer), denoting:

               OI-OJ = DIJ AND DIJ IN R

    `global(BOOLEAN)'
          if `true', a more expensive algorithm will be used in order to
          achieve tighter pruning of the bounds of the parameters.

     This constraint is due to Aggoun and Beldiceanu [Aggoun &
     Beldiceanu 93].

   The following constraint can be thought of as constraining N tasks
to be placed in time and on M machines.  Each machine has a resource
limit, which is interpreted as a lower or upper bound on the total
amount of resource used on that machine at any point in time that
intersects with some task.

`cumulatives(+TASKS,+MACHINES)'
`cumulatives(+TASKS,+MACHINES,+OPTIONS)'
     A task is represented by a term `task(OI,DI,EI,HI,MI)' where OI is
     the start time, DI the non-negative duration, EI the end time, HI
     the resource consumption (if positive) or production (if
     negative), and MI a machine identifier.  All fields are domain
     variables with bounded domains, or integers.

     A machine is represented by a term `machine(MJ,LJ)' where MJ is
     the identifier, an integer; and LJ is the resource bound of the
     machine, which must be a domain variable with bounded domains or
     an integer.

     Let there be N tasks and:

          HIJM = HI, if MI=M and OI <= J < OI+DI
          HIJM = 0 otherwise

     If the resource bound is `lower' (the default), the constraint
     holds if:

       1. For every task I, SI+DI=EI, and

       2. For all machines M and instants J such that there exists a
          task I where MI=M and OI <= J < OI+DI, H1JM+...+HNJM >= LM.

     If the resource bound is `upper', the constraint holds if:

       1. For every task I, SI+DI=EI, and

       2. For all machines M and instants J, H1JM+...+HNJM <= LM.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `bound(B)'
          If `lower' (the default), each resource limit is treated as a
          lower bound.  If `upper', each resource limit is treated as
          an upper bound.

    `prune(P)'
          If `all' (the default), the constraint will try to prune as
          many variables as possible.  If `next', only variables that
          occur in the first nonground task term (wrt. the order given
          when the constraint was posted) can be pruned.

    `generalization(BOOLEAN)'
          If `true', extra reasoning based on assumptions on machine
          assignment will be done to infer more.

    `task_intervals(BOOLEAN)'
          If `true', extra global reasoning will be performed in an
          attempt to infer more.


File: sicstus.info,  Node: Placement Constraints,  Next: Automata Constraints,  Prev: Scheduling Constraints,  Up: Available Constraints

10.35.4.8 Placement Constraints
...............................

The following constraints model a set of lines or rectangles,
respectively, so that no pair of objects overlap:

`disjoint1(+LINES)'
`disjoint1(+LINES,+OPTIONS)'
     where LINES is a list of terms F(SJ,DJ) or F(SJ,DJ,TJ), SJ and DJ
     are domain variables with finite bounds or integers denoting the
     origin and length of line J respectively, F is any functor, and
     the optional TJ is an atomic term denoting the type of the line.
     TJ defaults to 0 (zero).

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `decomposition(BOOLEAN)'
          if `true', an attempt is made to decompose the constraint
          each time it is resumed.

    `global(BOOLEAN)'
          if `true', a redundant algorithm using global reasoning is
          used to achieve more complete pruning.

    `wrap(MIN,MAX)'
          If used, the space in which the lines are placed should be
          thought of as a circle where positions MIN and MAX coincide,
          where MIN and MAX should be integers.  That is, the space
          wraps around.  Furthermore, this option forces the domains of
          the origin variables to be inside [MIN,MAX-1].

    `margin(T1,T2,D)'
          This option imposes a minimal distance D between the end
          point of any line of type T1 and the origin of any line of
          type T2.  D should be a positive integer or `sup'.  If `sup'
          is used, all lines of type T2 must be placed before any line
          of type T1.

          This option interacts with the `wrap/2' option in the sense
          that distances are counted with possible wrap-around, and the
          distance between any end point and origin is always finite.

     The file `library('clpfd/examples/bridge.pl')' contains an example
     where `disjoint1/2' is used for scheduling non-overlapping tasks.

`disjoint2(+RECTANGLES)'
`disjoint2(+RECTANGLES,+OPTIONS)'
     where RECTANGLES is a list of terms F(XJ,LJ,YJ,HJ) or
     F(XJ,LJ,YJ,HJ,TJ), XJ and LJ are domain variables with finite
     bounds or integers denoting the origin and size of rectangle J in
     the X dimension, YJ and HJ are the values for the Y dimension, F
     is any functor, and the optional TJ is an atomic term denoting the
     type of the rectangle.  TJ defaults to 0 (zero).

     Corresponds to `diffn/4' in MiniZinc.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `decomposition(BOOLEAN)'
          If `true', an attempt is made to decompose the constraint
          each time it is resumed.

    `global(BOOLEAN)'
          If `true', a redundant algorithm using global reasoning is
          used to achieve more complete pruning.

    `wrap(MIN1,MAX1,MIN2,MAX2)'
          MIN1 and MAX1 should be either integers or the atoms `inf'
          and `sup' respectively.  If they are integers, the space in
          which the rectangles are placed should be thought of as a
          cylinder wrapping around the X dimension where positions MIN1
          and MAX1 coincide.  Furthermore, this option forces the
          domains of the XJ variables to be inside [MIN1,MAX1-1].

          MIN2 and MAX2 should be either integers or the atoms `inf'
          and `sup' respectively.  If they are integers, the space in
          which the rectangles are placed should be thought of as a
          cylinder wrapping around the Y dimension where positions MIN2
          and MAX2 coincide.  Furthermore, this option forces the
          domains of the YJ variables to be inside [MIN2,MAX2-1].

          If all four are integers, the space is a toroid wrapping
          around both dimensions.

    `margin(T1,T2,D1,D2)'
          This option imposes minimal distances D1 in the X dimension
          and D2 in the Y dimension between the end point of any
          rectangle of type T1 and the origin of any rectangle of type
          T2.  D1 and D2 should be positive integers or `sup'.  If
          `sup' is used, all rectangles of type T2 must be placed
          before any rectangle of type T1 in the relevant dimension.

          This option interacts with the `wrap/4' option in the sense
          that distances are counted with possible wrap-around, and the
          distance between any end point and origin is always finite.

    `synchronization(BOOLEAN)'
          Let the "assignment dimension" and the "temporal dimension"
          denote the two dimensions, no matter which is the X and which
          is the Y dimension.  If BOOLEAN is `true', a redundant
          algorithm is used to achieve more complete pruning for the
          following case:

             * All rectangles have size 1 in the assignment dimension.

             * Some rectangles have the same origin and size in the
               temporal dimension, and that origin is not yet fixed.

          The following example shows an artificial placement problem
          involving 25 rectangles including four groups of rectangles
          whose left and right borders must be aligned.  If `Synch' is
          `true', it can be solved with first-fail labeling in 23
          backtracks.  If `Synch' is `false', 60 million backtracks
          don't suffice to solve it.

               ex([O1,Y1a,Y1b,Y1c,
                   O2,Y2a,Y2b,Y2c,Y2d,
                   O3,Y3a,Y3b,Y3c,Y3d,
                   O4,Y4a,Y4b,Y4c],
                  Synch) :-
                       domain([Y1a,Y1b,Y1c,
                               Y2a,Y2b,Y2c,Y2d,
                               Y3a,Y3b,Y3c,Y3d,
                               Y4a,Y4b,Y4c], 1, 5),
                       O1 in 1..28,
                       O2 in 1..26,
                       O3 in 1..22,
                       O4 in 1..25,
                       disjoint2([t(1,1,5,1),    t(20,4,5,1),
                                  t(1,1,4,1),    t(14,4,4,1),
                                  t(1,2,3,1),    t(24,2,3,1),
                                  t(1,2,2,1),    t(21,1,2,1),
                                  t(1,3,1,1),    t(14,2,1,1),
                                  t(O1,3,Y1a,1),
                                  t(O1,3,Y1b,1),
                                  t(O1,3,Y1c,1),
                                  t(O2,5,Y2a,1),
                                  t(O2,5,Y2b,1),
                                  t(O2,5,Y2c,1),
                                  t(O2,5,Y2d,1),
                                  t(O3,9,Y3a,1),
                                  t(O3,9,Y3b,1),
                                  t(O3,9,Y3c,1),
                                  t(O3,9,Y3d,1),
                                  t(O4,6,Y4a,1),
                                  t(O4,6,Y4b,1),
                                  t(O4,6,Y4c,1)],
                                 [synchronization(Synch)]).

`geost(+OBJECTS,+SHAPES)   "since release 4.1"'
`geost(+OBJECTS,+SHAPES,+OPTIONS)   "since release 4.1"'
`geost(+OBJECTS,+SHAPES,+OPTIONS,+RULES)   "since release 4.1"'
     constrains the location in space of non-overlapping
     multi-dimensional OBJECTS, each of which taking a shape among a
     set of SHAPES.

     Each shape is defined as a finite set of "shifted boxes", where
     each shifted box is described by a box in a K-dimensional space at
     the given offset with the given sizes.  A shifted box is described
     by a ground term `sbox(SID,OFFSET,SIZE)' where SID, an integer, is
     the shape id; OFFSET, a list of K integers, denotes the offset of
     the shifted box from the origin of the object; and SIZE, a list of
     K integers greater than zero, denotes the size of the shifted box.
     Then, a "shape" is a collection of shifted boxes all sharing the
     same shape id.  The shifted boxes associated with a given shape
     must not overlap. SHAPES is thus the list of such `sbox/3' terms.

     Each object is described by a term `object(OID,SID,ORIGIN' where
     OID, an integer, is the unique object id; SID, an integer or domain
     variable, is the shape id; and ORIGIN, a list of integers or
     domain variables, is the origin coordinate of the object. If SID
     is nonground, the object is said to be "polymorphic". The possible
     values for SID are the shape ids that occur in SHAPES.  OBJECTS is
     thus the list of such `object/3' terms.

     If given, OPTIONS is a list of zero or more of the following,
     where BOOLEAN must be `true' or `false' (`false' is the default):

    `lex(LISTOFOID)'
          where LISTOFOID should be a list of distinct object ids,
          denotes that the origin vectors of the objects according to
          LISTOFOID should be in ascending lexicographic order.
          Multiple `lex/1' options can be given, but should mention
          disjoint sets of objects.

    `cumulative(BOOLEAN)'
          If `true', redundant reasoning methods are enabled, based on
          projecting the objects onto each dimension.

    `disjunctive(BOOLEAN)'
          If `true', cliques of objects are detected that clash in one
          dimension and so must be separated in the other dimension.
          This method only applies in the 2D case.

    `longest_hole(VALUE,MAXBACKS)'
          This method only applies in the 2D case and in the absence of
          polymorphic objects.  VALUE can be `all', `true' or `false'.
          If `true', the filtering algorithm computes and uses
          information about holes that can be tolerated without
          necessarily failing the constraint.  If `all', more precise
          information is computed.  If `false', no such information is
          computed.  MAXBACKS should be an integer `>= -1' and gives a
          bound on the effort spent tightening the longest hole
          information.  Experiments suggest that 1000 may be a
          reasonable compromise value.

    `parconflict(BOOLEAN)'
          If `true', redundant reasoning methods are enabled, based on
          computing the number of items that can be put in parallel in
          the different dimensions.

    `visavis_init(BOOLEAN)'
          If `true', a redundant method is enabled that statically
          detects placements that would cause too large holes.  This
          method can be quite effective.

    `visavis_floating(BOOLEAN)'
          If `true', a redundant method is enabled that dynamically
          detects placements that would cause too large holes.  It's
          more general than the following option, but only applies in
          the 2D case and in the absence of polymorphic objects.  This
          method has been shown to pay off only in rare cases.

    `visavis(BOOLEAN)'
          If `true', a redundant method is enabled that dynamically
          detects placements that would cause too large holes.  This
          method has not been shown to pay off experimentally.

    `corners(BOOLEAN)'
          If `true', a redundant method is enabled that reasons in
          terms on borders that impinge on the corners of objects.
          This method only applies in the 2D case.  It has not been
          shown to pay off experimentally.

    `task_intervals(BOOLEAN)'
          If `true', a redundant reasoning method is enabled that
          detects overcrowded and undercrowded regions of the placement
          space.  This method has not been shown to pay off
          experimentally.

    `dynamic_programming(BOOLEAN)'
          If `true', a redundant reasoning method is enabled that
          solves a 2D knapsack problem for every two adjacent columns
          of the projection of the objects onto each dimension.  This
          method has pseudo-polynomial complexity but can be quite
          powerful.

    `polymorphism(BOOLEAN)'
          If `true', a reasoning method is enabled that is relevant in
          the context of polymorphic objects and no slack.  The method
          detects parts of the placement space that cannot be filled
          and thus fails the constraint.  This method has not been
          shown to pay off experimentally.

    `pallet_loading(BOOLEAN)'
          If `true', and if all objects consist of a single shifted box
          of the same shape, modulo rotations, a redundant method is
          enabled that recognizes necessary conditions for this special
          case.

    `overlap(BOOLEAN)'
          If `true', the constraint that objects be non-overlapping is
          lifted.  This option is useful mainly in conjunction with the
          RULES argument, in case the placement of objects should be
          restricted by the RULES only.

    `volume(TOTAL)'
          If given, TOTAL is constrained to be the total volume of
          OBJECTS.

    `bounding_box(LOWER,UPPER)'
          LOWER=[L1,...,LK] and UPPER=[U1,...,UK] should be lists of
          integers or domain variables.  The following conditions are
          imposed:
             * For every point P = [P1,...,PK] occupied by an object,
               L1 <= P1 < U1, ..., LK <= PK < UK.

             * For every J in 1..K, there exists a point P =
               [P1,...,PJ,...,PK] occupied by an object such that PJ=LJ.

             * For every J in 1..K, there exists a point P =
               [P1,...,PJ,...,PK] occupied by an object such that
               PJ=UJ-1.

    `fixall(FLAG,PATTERNS)'
          If given, FLAG is an integer or domain variable in `0..1'.
          If FLAG equals 1, either initially or by binding FLAG during
          search, the constraint switches behavior into greedy
          assignment mode. The greedy assignment will either succeed
          and assign all shape ids and origin coordinates to values
          that satisfy the constraint, or merely fail.  FLAG is never
          bound by the constraint; its sole function is to control the
          behavior of the constraint.

          Greedy assignment is done one object at a time, in the order
          of OBJECTS.  The assignment per object is controlled by
          PATTERNS, which should be a list of one or more pattern terms
          of the form `object(_,SidSpec,OriginSpec)', where SIDSPEC is a
          term `min(I)' or `max(I)', ORIGINSPEC is a list of K such
          terms, and I is a unique integer between 1 and K+1.

          The meaning of the pattern is as follows.  The variable in
          the position of `min(1)' or `max(1)' is fixed first; the
          variable in the position of `min(2)' or `max(2)' is fixed
          second; and so on.  `min(I)' means trying values in ascending
          order; `max(I)' means descending order.

          If PATTERNS contains M pattern, then object 1 is fixed
          according to pattern 1, ..., object M is fixed according to
          pattern M, object M+1 is fixed according to pattern 1, and so
          on.  For example, suppose that the following option is given:

               fixall(F, [object(_,min(1),[min(3),max(2)]),
                          object(_,max(1),[min(2),max(3)])])

          Then, if the program binds `F' to 1, the constraint enters
          greedy assignment mode and endeavors to fix all objects as
          follows.

             * For object 1, 3, ..., (a) the shape is fixed to the
               smallest possible value, (b) the Y coordinate is fixed
               to the largest possible value, (c) the X coordinate is
               fixed to the smallest possible value.

             * For object 2, 4, ..., (a) the shape is fixed to the
               largest possible value, (b) the X coordinate is fixed to
               the smallest possible value, (c) the Y coordinate is
               fixed to the largest possible value.

     If given, RULES is a list of zero or more terms of the form shown
     below, and impose extra constraints on the placement of the
     objects.  For the time being, the details are described in
     [Carlsson, Beldiceanu & Martin 08].  *Please note:* the rules
     require that all shapes of a polymorphic objects consist of the
     same number of shifted boxes.  For example, `Shapes =
     [sbox(1,[0,0],[3,1]),sbox(1,[0,1],[2,4]),sbox(2,[0,0],[3,1])]'
     will not work.

     SENTENCE      ::=           MACRO | FOL   

     MACRO         ::=           HEAD `--->'   
                                 BODY          

     HEAD          ::=           TERM          { to be substituted
                                               by a BODY }

     BODY          ::=           TERM          { to substitute for
                                               a HEAD }

     FOL           ::=           `#\' FOL      { negation }
                   |             FOL `#/\'     { conjunction }
                                 FOL           
                   |             FOL `#\/'     { disjunction }
                                 FOL           
                   |             FOL `#=>'     { implication }
                                 FOL           
                   |             FOL `#<=>'    { equivalence }
                                 FOL           
                   |             `exists(VAR,COLLECTION,FOL)'{ existential
                                               quantification }
                   |             `forall(VAR,COLLECTION,FOL)'{ universal
                                               quantification }
                   |             `card(VAR,COLLECTION,INTEGER,INTEGER,FOL)'{ cardinality }
                   |             `true'        
                   |             `false'       
                   |             EXPR RELOP    { rational
                                 EXPR          arithmetic }
                   |             HEAD          { macro application
                                               }

     EXPR          ::=           EXPR `+' EXPR 
                   |             `-' EXPR      
                   |             EXPR `-' EXPR 
                   |             `min(EXPR,EXPR)'
                   |             `max(EXPR,EXPR)'
                   |             EXPR `*'      
                                 GROUNDEXPR    
                   |             GROUNDEXPR    
                                 `*' EXPR      
                   |             EXPR `/'      
                                 GROUNDEXPR    
                   |             ATTREF        
                   |             INTEGER       
                   |             `fold(VAR,COLLECTION,FOP,EXPR,EXPR)'
                   |             VARIABLE      { quantified
                                               variable }
                   |             HEAD          { macro application
                                               }

     GROUNDEXPR    ::=           EXPR          { where EXPR is
                                               ground }

     ATTREF        ::=           ENTITY `^'    
                                 ATTR          

     ATTR          ::=           TERM          { attribute name }
                   |             VARIABLE      { quantified
                                               variable }

     RELOP         ::=           `#<' | `#='   
                                 | `#>' |      
                                 `#\=' |       
                                 `#=<' | `#>=' 

     FOP           ::=           `+' | `min'   
                                 | `max'       

     COLLECTION    ::=           LIST          
                   |             `objects(LIST)'{ list of oids }
                   |             `sboxes(LIST)'{ list of sids }

     The following example shows `geost/2' modeling three
     non-overlapping objects.  The first object has four possible
     shapes, and the other two have two possible shapes each.

          | ?- domain([X1,X2,X3,Y1,Y2,Y3], 1, 4),
               S1 in 1..4,
               S2 in 5..6,
               S3 in 7..8,
               geost([object(1,S1,[X1,Y1]),
                      object(2,S2,[X2,Y2]),
                      object(3,S3,[X3,Y3])],
                     [sbox(1,[0,0],[2,1]),
                      sbox(1,[0,1],[1,2]),
                      sbox(1,[1,2],[3,1]),
                      sbox(2,[0,0],[3,1]),
                      sbox(2,[0,1],[1,3]),
                      sbox(2,[2,1],[1,1]),
                      sbox(3,[0,0],[2,1]),
                      sbox(3,[1,1],[1,2]),
                      sbox(3,[2,2],[3,1]),
                      sbox(4,[0,0],[3,1]),
                      sbox(4,[0,1],[1,1]),
                      sbox(4,[2,1],[1,3]),
                      sbox(5,[0,0],[2,1]),
                      sbox(5,[1,1],[1,1]),
                      sbox(5,[0,2],[2,1]),
                      sbox(6,[0,0],[3,1]),
                      sbox(6,[0,1],[1,1]),
                      sbox(6,[2,1],[1,1]),
                      sbox(7,[0,0],[3,2]),
                      sbox(8,[0,0],[2,3])]).

     The shapes are illustrated in the following picture:


      [image src="images/geost1a.png" text="" ]                `geost/2': three objects and eight shapes

     A ground solution is shown in the following picture:


      [image src="images/geost1b.png" text="" ]                      `geost/2': a ground solution

     The following example shows how to encode in RULES "objects with
     oid 1, 2 and 3 must all be at least 2 units apart from objects
     with oid 4, 5 and 6".

          [ (origin(O1,S1,D) ---> O1^x(D)+S1^t(D))),

            (end(O1,S1,D) ---> O1^x(D)+S1^t(D)+S1^l(D)),

            (tooclose(O1,O2,S1,S2,D) --->
                end(O1,S1,D)+2 #> origin(O2,S2,D) #/\
                end(O2,S2,D)+2 #> origin(O1,S1,D)),

            (apart(O1,O2) --->
                forall(S1,sboxes([O1^sid]),
                    forall(S2,sboxes([O2^sid]),
                        #\ tooclose(O1,O2,S1,S2,1) #\/
                        #\ tooclose(O1,O2,S1,S2,2)))),

            (forall(O1,objects([1,2,3]),
                forall(O2,objects([4,5,6]), apart(O1,O2))))].

     The following example shows how to encode in RULES "objects 3 and
     7 model rooms that must be adjacent and have a common border at
     least 1 unit long".

          [ (origin(O1,S1,D) ---> O1^x(D)+S1^t(D))),

            (end(O1,S1,D) ---> O1^x(D)+S1^t(D)+S1^l(D)),

            (overlap(O1,S1,O2,S2,D) --->
                end(O1,S1,D) #> origin(O2,S2,D) #/\
                end(O2,S2,D) #> origin(O1,S1,D)),

            (abut(O1,O2) --->
                forall(S1,sboxes([O1^sid]),
                    forall(S2,sboxes([O2^sid]),
                        ((origin(O1,S1,1) #= end(O2,S2,1) #\/
                          origin(O2,S2,1) #= end(O1,S1,1)) #/\
                         overlap(O1,S1,O2,S2,2)) #\/
                        ((origin(O1,S1,2) #= end(O2,S2,2) #\/
                          origin(O2,S2,2) #= end(O1,S1,2)) #/\
                         overlap(O1,S1,O2,S2,1))))),

            (forall(O1,objects([3]),
                forall(O2,objects([7]), abut(O1,O2))))].


File: sicstus.info,  Node: Automata Constraints,  Next: User-Defined Constraints,  Prev: Placement Constraints,  Up: Available Constraints

10.35.4.9 Automata Constraints
..............................

The following constraint provides a general way of defining any
constraint involving sequences whose "checker", i.e. a procedure that
classifies ground instances as solutions or non-solutions, can be
expressed by a finite automaton, deterministic or nondeterministic,
extended with counter operations on its arcs. The point is that it is
very much easier to come up with such a checker than to come up with a
filtering algorithm for the constraint of interest.  In the absence of
counters, it maintains domain-consistency.

   Corresponds to `regular/6' in MiniZinc.

`automaton(SIGNATURE, SOURCESSINKS, ARCS)   "since release 4.1"'
`automaton(SEQUENCE, TEMPLATE, SIGNATURE, SOURCESSINKS, ARCS, COUNTERS, INITIAL, FINAL)'
`automaton(SEQUENCE, TEMPLATE, SIGNATURE, SOURCESSINKS, ARCS, COUNTERS, INITIAL, FINAL, OPTIONS)   "since release 4.1"'
     The arguments are described below in terms of their abstract
     syntax:

    SEQUENCE
          The sequence of terms of interest; abstract grammar category
          SEQUENCE.

    TEMPLATE
          A template for an item of the sequence; abstract grammar
          category TEMPLATE.  Only relevant if some state transition
          involving counter arithmetic mentions a variable occurring in
          TEMPLATE, in which case the corresponding term in a sequence
          element will be accessed.

    SIGNATURE
          The "signature" of SEQUENCE; abstract grammar category
          SIGNATURE.  The automaton is not driven by SEQUENCE itself,
          but by SIGNATURE, which ranges over some alphabet, implicitly
          defined by the values used by ARCS.  In addition to
          `automaton/[8,9]', you must call a constraint that maps
          SEQUENCE to SIGNATURE.

    SOURCESSINKS
          The source and sink nodes of the automaton; abstract grammar
          category SOURCESSINKS.

    ARCS
          The arcs (transitions) of the automaton; abstract grammar
          category ARCS.  Any transition not mentioned is assumed to go
          to an implicit failure node. An arc optionally contains
          expressions for updated counter values; by default, the
          counters remain unchanged. Conditional updates can be
          specified.

    COUNTERS
          A list of variables, local to the constraint; abstract
          grammar category COUNTERS.

    INITIAL
          A list of initial values, usually instantiated; abstract
          grammar category INITIAL.

    FINAL
          A list of final values, usually uninstantiated; abstract
          grammar category FINAL.

    OPTIONS
          Abstract grammar category OPTIONS; a list of zero or more of
          the following terms.  All but the last option are implemented
          by adding auxiliary counters to the automaton including the
          necessary updates in the arcs:

         `valueprec(FIRST,LATER,N)   "since release 4.1.3"'
               N is unified with N, computed such that: if the value
               LATER occurs in the SIGNATURE, FIRST occurs N times
               before the first occurrence of LATER, otherwise N=0.

         `anystretchocc(N)   "since release 4.1.3"'
               N is unified with the number of (nonempty) stretches of
               any single value in the SIGNATURE.

         `stretchocc(VALUEPAT,N)   "since release 4.1.3"'
               N is unified with the number of stretches of values
               matching VALUEPAT (abstract grammar category VALUEPAT)
               in the SIGNATURE.

         `stretchoccmod(VALUEPAT,MOD,N)   "since release 4.1.3"'
               N is unified with the number (modulo MOD) of stretches of
               values matching VALUEPAT (abstract grammar category
               VALUEPAT) the SIGNATURE.

         `stretchmaxlen(VALUEPAT,N)   "since release 4.1.3"'
               N is unified with N, computed such that: if values
               matching VALUEPAT (abstract grammar category VALUEPAT)
               occur the SIGNATURE, N is the length of the longest such
               stretch, otherwise N=0.

         `stretchminlen(VALUEPAT,N)   "since release 4.1.3"'
               N is unified with N, computed such that: if values
               matching VALUEPAT (abstract grammar category VALUEPAT)
               occur the SIGNATURE, N is the length of the shortest
               such stretch, otherwise N is a large integer.

         `wordocc(WORDPAT,N)   "since release 4.1.3"'
               N is unified with the number of words matching WORDPAT
               (abstract grammar category WORDPAT) in the SIGNATURE.

         `wordoccmod(WORDPAT,MOD,N)   "since release 4.1.3"'
               N is unified with the number (modulo MOD) of words
               matching WORDPAT (abstract grammar category WORDPAT) in
               the SIGNATURE.

         `wordprefix(WORDPAT,ZO)   "since release 4.1.3"'
               If the prefix of the SIGNATURE matches WORDPAT (abstract
               grammar category WORDPAT), ZO is unified with 1,
               otherwise with 0.

         `wordsuffix(WORDPAT,ZO)   "since release 4.1.3"'
               If the suffix of the SIGNATURE matches WORDPAT (abstract
               grammar category WORDPAT), ZO is unified with 1,
               otherwise with 0.

         `state(MAP,STATESEQUENCE)   "since release 4.1"'
               For a signature of length K, the constraint is
               implemented by decomposition into K smaller constraints
               mapping an old state to a new state.  The states are
               represented as domain variables.  STATESEQUENCE forms
               the list of these K+1 domain variables, starting with
               the initial state and ending with the final state.  MAP
               gives the interpretation of their values: it is a list of
               pairs NODE-VALUE such that if the nth state variable SN
               equals VALUE, then the automaton is in state NODE having
               read N symbols.

         `counterseq(COUNTERSEQUENCE)   "since release 4.2.1"'
               Similarly to the list of states, COUNTERSEQUENCE forms
               the list of the K+1 instances of COUNTERS, beginning
               with INITIAL and ending with FINAL.

     Abstract syntax:

     SEQUENCE      ::= LIST OF TEMPLATE        {all of which of the same
                                               shape}

     TEMPLATE      ::= TERM                    {most general shape of the
                                               SEQUENCE}
                                               {its variables should be
                                               local to the constraint}

     SIGNATURE     ::= LIST OF VARIABLE        

     SOURCESSINKS  ::= LIST OF NODESPEC        

     NODESPEC      ::= `source(NODE)'          {an initial state}
                   | `sink(NODE)'              {an accept state}

     NODE          ::= TERM                    

     ARCS          ::= LIST OF ARC             

     ARC           ::=                         {from node, integer, to
                   `arc(NODE,INTEGER,NODE)'    node}
                   |                           {EXPRS correspond to new
                   `arc(NODE,INTEGER,NODE,EXPRS)'counter values}
                   |                           
                   `arc(NODE,INTEGER,NODE,CONDITIONAL)'

     CONDITIONAL   ::= (COND -> EXPRS)         
                   | (CONDITIONAL ;            
                   CONDITIONAL)                

     EXPRS         ::= LIST OF EXPR            {of same length as
                                               COUNTERS}
                                               {EXPR as defined in *note
                                               Syntax of Arithmetic
                                               Expressions::}
                                               {over COUNTERS, TEMPLATE
                                               and constants}
                                               {variables occurring in
                                               COUNTERS correspond to old
                                               counter values}
                                               {variables occurring in
                                               TEMPLATE refer to the
                                               current element of
                                               SEQUENCE}

     COND          ::= CONSTRAINT              {over COUNTERS, TEMPLATE
                                               and constants}
                                               {must be reifiable or
                                               `true'}

     COUNTERS      ::= LIST OF VARIABLE        {should be local to the
                                               constraint}

     INITIAL       ::= LIST OF DVAR            {of same length as
                                               COUNTERS}

     FINAL         ::= LIST OF DVAR            {of same length as
                                               COUNTERS}

     OPTION        ::= `state(LIST OF          
                   TERM,LIST OF DVAR)'         
                   |                           
                   `valueprec(INTEGER,INTEGER,DVAR)'
                   | `anystretchocc(DVAR)'     
                   |                           
                   `stretchocc(VALUEPAT,DVAR)' 
                   |                           
                   `stretchoccmod(VALUEPAT,DVAR,INTEGER)'
                   |                           
                   `stretchmaxlen(VALUEPAT,DVAR)'
                   |                           
                   `stretchminlen(VALUEPAT,DVAR)'
                   | `wordocc(WORDPAT,DVAR)'   
                   |                           
                   `wordoccmod(WORDPAT,DVAR,INTEGER)'
                   |                           
                   `wordprefix(WORDPAT,DVAR)'  
                   |                           
                   `wordsuffix(WORDPAT,DVAR)'  

     VALUEPAT      ::= INTEGER                 
                   | LIST OF INTEGER           {alternatives}
                   | VALUEPAT`/'VALUEPAT       {alternatives}

     WORDPAT       ::= LIST OF VALUEPAT        

     DVAR          ::= VARIABLE OR INTEGER     

     If no counters are used, the arguments COUNTERS, INITIAL and FINAL
     should be `[]'.  The arguments TEMPLATE and SEQUENCE are only
     relevant if some EXPR mentions a variable in TEMPLATE, in which
     case the corresponding position in SEQUENCE will be used at that
     point.

     The constraint holds for a ground instance SEQUENCE if:

        * SIGNATURE is the signature corresponding to SEQUENCE.

        * The finite automaton encoded by SOURCESSINKS and ARCS stops
          in an accept state.

        * Any counter arithmetic on the transitions map their INITIAL
          values to the FINAL values.

        * Any extra constraint imposed by OPTIONS are true.

     Here is an example.  Suppose that you want to define the predicate
     `inflexion(N,L,OPT)' which should hold if L is a list of domain
     variables, and N is the number of times that the sequence order
     switches between strictly increasing and strictly decreasing.  For
     example, the sequence `[1,1,4,8,8,2,7,1]' switches order three
     times.

     Such a constraint is conveniently expressed by a finite automaton
     over the alphabet `[<,=,>]' denoting the order between consecutive
     list elements.  A counter is incremented when the order switches,
     and is mapped to the first argument of the constraint.  The
     automaton could look as follows:


      [image src="images/inflexion2.png" text="" ]                       Automaton for `inflexion/3'

     The following piece of code encodes this using `automaton/9'.  The
     auxiliary predicate `inflexion_signature/2' maps the sequence to a
     signature where the consecutive element order is encoded over the
     alphabet `[0,1,2]'.  We use one counter with initial value 0 and
     final value N (an argument of `inflexion/3').  Two transitions
     increment the counter.  All states are accept states.

          inflexion(N, Vars, Opt) :-
                  inflexion_signature(Vars, Sign),
                  automaton(Sign, _, Sign,
                            [source(s),sink(i),sink(j),sink(s)],
                            [arc(s,1,s      ),
                             arc(s,2,i      ),
                             arc(s,0,j      ),
                             arc(i,1,i      ),
                             arc(i,2,i      ),
                             arc(i,0,j,[C+1]),
                             arc(j,1,j      ),
                             arc(j,0,j      ),
                             arc(j,2,i,[C+1])],
                            [C],[0],[N],Opt).

          inflexion_signature([], []).
          inflexion_signature([_], []) :- !.
          inflexion_signature([X,Y|Ys], [S|Ss]) :-
                  S in 0..2,
                  X #> Y #<=> S #= 0,
                  X #= Y #<=> S #= 1,
                  X #< Y #<=> S #= 2,
                  inflexion_signature([Y|Ys], Ss).

     Some queries:

          /* count the #inflections of a ground string */
          | ?- inflexion(N, [1,1,4,8,8,2,7,1], []).
          N = 3 ? <RET>
          yes

          /* find strings with two inflections */
          | ?- length(L,4), domain(L,0,1), inflexion(2,L,[]), labeling([],L).
          L = [0,1,0,1] ? ;
          L = [1,0,1,0] ? ;
          no

          /* find strings that are strictly increasing, strictly decreasing or all equal */
          | ?- length(L,4), domain(L,0,3), inflexion(I,L,[anystretchocc(1)]), labeling([],L).
          I = 0,
          L = [0,0,0,0] ? ;
          I = 0,
          L = [0,1,2,3] ? ;
          I = 0,
          L = [1,1,1,1] ? ;
          I = 0,
          L = [2,2,2,2] ? ;
          I = 0,
          L = [3,2,1,0] ? ;
          I = 0,
          L = [3,3,3,3] ? ;
          no

          /* find strings that contain an increase followed by a decrease */
          | ?- length(L,4), domain(L,0,1), inflexion(I,L,[wordocc([2,0],1)]), labeling([],L).
          I = 1,
          L = [0,0,1,0] ? ;
          I = 1,
          L = [0,1,0,0] ? ;
          I = 2,
          L = [0,1,0,1] ? ;
          I = 2,
          L = [1,0,1,0] ? ;
          no

     This constraint uses techniques from [Beldiceanu, Carlsson & Petit
     04] and [Beldiceanu, Carlsson, Flener & Pearson 10].



File: sicstus.info,  Node: User-Defined Constraints,  Prev: Automata Constraints,  Up: Available Constraints

10.35.4.10 User-Defined Constraints
...................................

New, primitive constraints can be added defined by the user on two
different levels.  On a higher level, constraints can be defined using
the global constraint programming interface; *note Defining Global
Constraints::.  Such constraints can embody specialized algorithms and
use the full power of Prolog.  They cannot be reified.

   On a lower level, new primitive constraints can be defined with
indexicals.  In this case, they take part in the basic constraint
solving algorithm and express custom designed rules for special cases of
the overall local propagation scheme.  Such constraints are called "FD
predicates"; *note Defining Primitive Constraints::.  They can
optionally be reified.  


File: sicstus.info,  Node: Enumeration Predicates,  Next: Statistics Predicates,  Prev: Available Constraints,  Up: lib-clpfd

10.35.5 Enumeration Predicates
------------------------------

As is usually the case with finite domain constraint solvers, this
solver is not "complete".  That is, it does not ensure that the set of
posted constraints is satisfiable.  One must resort to search
(enumeration) to check satisfiability and get particular solutions.

   The following predicates provide several variants of search:

`indomain(?X)'
     where X is a domain variable with a bounded domain or an integer.
     Assigns, in increasing order via backtracking, a feasible value to
     X.

`labeling(:OPTIONS, +VARIABLES)'
     where VARIABLES is a list of domain variables or integers and
     OPTIONS is a list of search options.  The domain variables must
     all have bounded domains.  True if an assignment of the variables
     can be found, which satisfies the posted constraints.

`first_bound(+BB0, -BB)'
`later_bound(+BB0, -BB)'
     Provides an auxiliary service for the `value(ENUM)' option (see
     below).

`minimize(:GOAL,?X)'
`minimize(:GOAL,?X,+OPTIONS)   "since release 4.3"'
`maximize(:GOAL,?X)'
`maximize(:GOAL,?X,+OPTIONS)   "since release 4.3"'
     Uses a restart algorithm to find an assignment that minimizes
     (maximizes) the domain variable X.  GOAL should be a Prolog goal
     that constrains X to become assigned, and could be a `labeling/2'
     goal.  The algorithm calls GOAL repeatedly with a progressively
     tighter upper (lower) bound on X until a proof of optimality is
     obtained.

     Whether to enumerate every solution that improves the objective
     function, or only the optimal one after optimality has been
     proved, is controlled by OPTIONS.  If given, it whould be a list
     containing a single atomic value, one of:

    `best   "since release 4.3"'
          Return the optimal solution after proving its optimality.
          This is the default.

    `all   "since release 4.3"'
          Enumerate all improving solutions, on backtracking seek the
          next improving solution.  Merely fail after proving
          optimality.

   The OPTIONS argument of `labeling/2' controls the order in which
variables are selected for assignment (variable choice heuristic), the
way in which choices are made for the selected variable (value choice
heuristic), whether the problem is a satisfaction one or an
optimization one, and whether all solutions or only the optimal one
should be returned.  The options are divided into five groups.  One
option may be selected per group.  Also, the number of assumptions
(choices) made during the search can be counted.  Finally, limits on
the execution time and discrepancy of the search can be imposed:

     The following options control the order in which the next variable
     is selected for assignment.

    `leftmost'
    `input_order'
          The leftmost variable is selected.  This is the default.

    `min'
    `smallest'
          The leftmost variable with the smallest lower bound is
          selected.

    `max'
    `largest'
          The leftmost variable with the greatest upper bound is
          selected.

    `ff'
    `first_fail'
          The first-fail principle is used: the leftmost variable with
          the smallest domain is selected.

    `anti_first_fail   "since release 4.3"'
          The leftmost variable with the largest domain is selected.

    `occurrence   "since release 4.3"'
          The leftmost variable among those that have the most
          constraints suspended on it is selected.

    `ffc'
    `most_constrained'
          The most constrained heuristic is used: a variable with the
          smallest domain is selected, breaking ties by (a) selecting
          the variable that has the most constraints suspended on it
          and (b) selecting the leftmost one.

    `max_regret   "since release 4.3"'
          The variable with the largest difference between its first
          two domain elements is selected.  Ties are broken by
          selecting the leftmost variable.

    `variable(SEL)'
          SEL is a predicate to select the next variable.  Given VARS,
          the variables that remain to label, it will be called as
          SEL(VARS,SELECTED,REST).

          SEL is expected to succeed determinately, unifying SELECTED
          and REST with the selected variable and the remaining list,
          respectively.

          SEL should be a callable term, optionally with a module
          prefix, and the arguments VARS,SELECTED,REST will be appended
          to it.  For example, if SEL is `mod:sel(Param)', it will be
          called as `mod:sel(Param,Vars,Selected,Rest)'.

     The following options control the way in which choices are made
     for the selected variable X:

    `step'
          Makes a binary choice between `X #= B' and `X #\= B', where B
          is the lower or upper bound of X.  This is the default.

    `enum'
          Makes a multiple choice for X corresponding to the values in
          its domain.

    `bisect'
          Makes a binary choice between `X #=< M' and `X #> M', where M
          is the middle of the domain of X, i.e. the mean of `min(X)'
          and `max(X)' rounded down to the nearest integer.  This
          strategy is also known as domain splitting.

    `median   "since release 4.3"'
          Makes a binary choice between `X #= M' and `X #\= M', where M
          is the median of the domain of X. If the domain has an even
          number of elements, the smaller middle value is used.

    `middle   "since release 4.3"'
          Makes a binary choice between `X #= M' and `X #\= M', where M
          is the middle of the domain of X, i.e. the mean of `min(X)'
          and `max(X)' rounded down to the nearest integer.

    `value(ENUM)'
          ENUM is a predicate that should prune the domain of X,
          possibly but not necessarily to a singleton.  It will be
          called as ENUM(X,REST,BB0,BB) where REST is the list of
          variables that need labeling except X, and BB0 and BB are
          parameters described below.

          ENUM is expected to succeed nondeterminately, pruning the
          domain of X, and to backtrack one or more times, providing
          alternative prunings.  To ensure that branch-and-bound search
          works correctly, it must call the auxiliary predicate
          `first_bound(BB0,BB)' in its first solution.  Similarly, it
          must call the auxiliary predicate `later_bound(BB0,BB)' in
          any alternative solution.

          ENUM should be a callable term, optionally with a module
          prefix, and the arguments X,REST,BB0,BB will be appended to
          it.  For example, if ENUM is `mod:enum(Param)', it will be
          called as `mod:enum(Param,X,Rest,BB0,BB)'.

     The following options control the order in which the choices are
     made for the selected variable X.  Not useful with the
     `value(ENUM)' option:

    `up'
          The domain is explored in ascending order.  This is the
          default.

    `down'
          The domain is explored in descending order.

     The following options tell the solver whether the given problem is
     a satisfaction problem or an optimization problem.  In a
     satisfaction problem, we wish to find values for the domain
     variables, but we don't care about which values.  In an
     optimization problem, we wish to find values that minimize or
     maximize some objective function reflected in a domain variable:

    `satisfy   "since release 4.3"'
          We have a satisfication problem.  Its solutions are
          enumerated by backtracking.  This is the default.

    `minimize(X)'
    `maximize(X)'
          We have an optimization problem, seeking an assignment that
          minimizes (maximizes) the domain variable X.  The labeling
          should constrain X to become assigned for all assignments of
          VARIABLES.  It is useful to combine these option with the
          `time_out/2', `best', and `all' options (see below).  If
          these options occur more than once, the last occurrence
          overrides previous ones.

     The following options are only meaningful for optimization
     problems.  They tell the solver whether to enumerate every
     solution that improves the objective function, or only the optimal
     one after optimality has been proved:

    `best   "since release 4.3"'
          Return the optimal solution after proving its optimality.
          This is the default.

    `all   "since release 4.3"'
          Enumerate all improving solutions, on backtracking seek the
          next improving solution.  Merely fail after proving
          optimality.

     The following options are only meaningful for optimization
     problems.  They tell the solver what search scheme to use:

    `bab   "since release 4.3"'
          Use a branch-and-bound scheme, which incrementally tightens
          the bound on the objective as more and more solutions are
          found.  This is the default, and is usually the more
          efficient scheme.

    `restart   "since release 4.3"'
          Use a scheme that restarts the search with a tighter bound on
          the objective each time a solution is found.

     The following option counts the number of assumptions (choices)
     made during the search:

    `assumptions(K)'
          When a solution is found, K is unified with the number of
          choices made.

     Finally, limits on the discrepancy of the search and the execution
     time can be imposed:

    `discrepancy(D)'
          On the path leading to the solution there are at most D
          choicepoints in which a non-leftmost branch was taken.

    `time_out(TIME,FLAG)'
          If combined with the `best', `bab', and `minimize(V)' or
          `maximize(V)' options, and the time limit TIME in
          milliseconds is reached, then (if at least one solution was
          found, then FLAG, VARIABLES and V are respectively unified
          with `time_out' and the values of the best solution found,
          else the search merely fails).  If used otherwise, equivalent
          to a goal `time_out(labeling(...),Time,Flag)' (*note
          lib-timeout::).

   For example, to enumerate solutions using a static variable
ordering, use:

     | ?- constraints(Variables),
          labeling([], Variables).
          %same as [leftmost,step,up,satisfy]

   To minimize a cost function using branch-and-bound search, computing
the best solution only, with a dynamic variable ordering using the
first-fail principle, and domain splitting exploring the upper part of
domains first, use:

     | ?- constraints(Variables, Cost),
          labeling([ff,bisect,down,minimize(Cost)], Variables).

   The file `library('clpfd/examples/tsp.pl')' contains an example of
user-defined variable and value choice heuristics.

   Note that, when used for optimization, `labeling/2' has a limitation
compared to `minimize/[2,3]' and `maximize/[2,3]': the variable and
value choice heuristics specified by `labeling/2' must apply to the
whole set of variables, with no provision for different heuristics for
different subsets.  As of release 4.3, this limitation is overcome by
the following predicate:

`solve(:OPTIONS, :SEARCHES)   "since release 4.3"'
     where OPTIONS is a list of options of the same shape as taken by
     `labeling/2', and SEARCHES is a list of `labeling/2' and
     `indomain/1' goals, or a single such goal.  The domain variables of
     SEARCHES must all have bounded domains.  True if the conjunction
     of SEARCHES is true.

     The main purpose of this predicate is for optimization, allowing to
     use different heuristics in the different SEARCHES.  For
     satisfiability problems, a simple sequence of `labeling/2' and
     `indomain/1' goals does the trick.

     The treatment of the OPTIONS, as well as the suboption lists given
     in the `labeling/2' goals of SEARCHES, is a bit special.  Some
     options are global for the whole search, and are ignored if they
     occur in the suboption lists.  Others are local to the given
     `labeling/2' goal, but provides a default value for the whole
     search if it occurs in OPTIONS.  The following table defines the
     role of each option as `global' or `local':

     `all'                       `global'
     `anti_first_fail'           `local'
     `assumptions/1'             `global'
     `bab'                       `global'
     `best'                      `global'
     `bisect'                    `local'
     `discrepancy/1'             `local'
     `down'                      `local'
     `enum'                      `local'
     `ffc'                       `local'
     `ff'                        `local'
     `first_fail'                `local'
     `input_order'               `local'
     `largest'                   `local'
     `leftmost'                  `local'
     `maximize/1'                `global'
     `max'                       `local'
     `max_regret'                `local'
     `median'                    `local'
     `middle'                    `local'
     `minimize/1'                `global'
     `min'                       `local'
     `most_constrained'          `local'
     `occurrence'                `local'
     `restart'                   `global'
     `satisfy'                   `global'
     `smallest'                  `local'
     `step'                      `local'
     `time_out/2'                `global'
     `up'                        `local'
     `value/1'                   `local'
     `variable/1'                `local'

   For example, suppose that you want to  minimize a cost function using
branch-and-bound search, enumerating every improving solution, using
left-to-right search on some variables followed by first-fail domain
splitting search on some other variables.  This can be expressed as:

     | ?- constraints([X1,X2,X3,Y1,Y2,Y3], Cost),
          solve([minimize(Cost),all],
                [labeling([leftmost],[X1,X2,X3]),
                 labeling([ff,bisect],[Y1,Y2,Y3])]).


File: sicstus.info,  Node: Statistics Predicates,  Next: Answer Constraints,  Prev: Enumeration Predicates,  Up: lib-clpfd

10.35.6 Statistics Predicates
-----------------------------

The following predicates can be used to access execution statistics.

`fd_statistics'
`fd_statistics(?KEY, ?VALUE)'
     This allows a program to access execution statistics specific to
     this solver.  General statistics about CPU time and memory
     consumption etc.  is available from the built-in predicate
     `statistics/2'.

     Without arguments, displays on the standard error stream a summary
     of the following statistics, and zeroes all counters.  With
     arguments, for each of the possible keys KEY, VALUE is unified
     with the current value of a counter, which is simultaneously
     zeroed.  The following counters are maintained:

    `resumptions'
          The number of times a constraint was resumed.

    `entailments'
          The number of times a (dis)entailment was detected by a
          constraint.

    `prunings'
          The number of times a domain was pruned.

    `backtracks'
          The number of times a contradiction was found by a domain
          being wiped out, or by a global constraint signalling
          failure.  Other causes of backtracking, such as failed Prolog
          tests, are not covered by this counter.

    `constraints'
          The number of propagators created.


File: sicstus.info,  Node: Answer Constraints,  Next: CLPFD Debugging,  Prev: Statistics Predicates,  Up: lib-clpfd

10.35.7 Answer Constraints
--------------------------

By default, the answer constraint only shows the projection of the store
onto the variables that occur in the query, but not any constraints that
may be attached to these variables, nor any domains or constraints
attached to other variables.  This is a conscious decision, as no
efficient algorithm for projecting answer constraints onto the query
variables is known for this constraint system.

   It is possible, however, to get a complete answer constraint
including all variables that took part in the computation and their
domains and attached constraints.  This is done by asserting a clause
for the following predicate:

`clpfd:full_answer   "hook,volatile"'
     If false (the default), the answer constraint, as well as
     constraints projected by `copy_term/3',
     `clpfd:project_attributes/2', `clpfd:attribute_goal/2' and their
     callers, only contain the domains of the query variables.  If
     true, those constraints contain the domains and any attached
     constraints of all variables. Initially defined as a dynamic,
     volatile predicate with no clauses.


File: sicstus.info,  Node: CLPFD Debugging,  Next: Defining Global Constraints,  Prev: Answer Constraints,  Up: lib-clpfd

10.35.8 Debugging
-----------------

Code using `library(clpfd)' can be debugged with the usual debugger,
but it does not capture all relevant aspects of constraint execution:
the propagation cascade and domain changes are not visible.  To capture
such aspects, a separate, dedicated debugger is available; *note
lib-fdbg::.

   The `v' command ("print variable bindings") of the usual debugger
can be handy.  It will endeavor to print the variable bindings of the
clause containing the current goal, as well as any goals that are
blocked on a variable found among those bindings.  In particular, it
will show the current domains of such variables.  *Note Debug
Commands::.


File: sicstus.info,  Node: Defining Global Constraints,  Next: Defining Primitive Constraints,  Prev: CLPFD Debugging,  Up: lib-clpfd

10.35.9 Defining Global Constraints
-----------------------------------

* Menu:

* The Global Constraint Programming Interface:: The Global Constraint Programming Interface
* Reflection Predicates:: Reflection Predicates
* FD Set Operations:: FD Set Operations
* A Global Constraint Example:: A Global Constraint Example


File: sicstus.info,  Node: The Global Constraint Programming Interface,  Next: Reflection Predicates,  Up: Defining Global Constraints

10.35.9.1 The Global Constraint Programming Interface
.....................................................

This section describes a programming interface by means of which new
constraints can be written.  The interface consists of a set of
predicates provided by this library module.  Constraints defined in this
way can take arbitrary arguments and may use any constraint solving
algorithm, provided it makes sense.  Reification cannot be expressed in
this interface; instead, reification may be achieved by explicitly
passing a 0/1-variable to the constraint in question.

   Global constraints have state, which may be updated each time the
constraint is resumed.  The state information may be used e.g. in
incremental constraint solving.

   The following two predicates are the principal entrypoints for
defining and posting new global constraints:

`clpfd:dispatch_global(+CONSTRAINT, +STATE0, -STATE, -ACTIONS)   "extendible"'
     Tells the solver how to solve constraints of the form CONSTRAINT.
     Defined as a multifile predicate.

     When defining a new constraint, a clause of this predicate must be
     added. Its body defines a constraint solving method and should
     always succeed determinately.  When a global constraint is called
     or resumed, the solver will call this predicate to deal with the
     constraint.

          *Please note*: the constraint is identified by its principal
          functor; there is no provision for having two constraints
          with the same name in different modules.  It is good practice
          to include a cut in every clause of `clpfd:dispatch_global/4'.

     STATE0 and STATE are the old and new state respectively.

     The constraint solving method must not invoke the constraint solver
     recursively e.g. by binding variables or posting new constraints;
     instead, ACTIONS should be unified with a list of requests to the
     solver.  Each request should be of the following form:

    `exit'
          The constraint has become entailed, and ceases to exist.

    `fail'
          The constraint has become disentailed, causing the solver to
          backtrack.

    `X = V'
          The solver binds X to V.

    `X in R'
          The solver constrains X to be a member of the CONSTANTRANGE R
          (*note Syntax of Indexicals::).

    `X in_set S'
          The solver constrains X to be a member of the FD set S (*note
          FD Set Operations::).

    `call(GOAL)'
          The solver calls the goal or constraint GOAL, which should be
          module prefixed unless it is a built-in predicate or an
          exported predicate of the `clpfd' module.

          GOAL is executed as any Prolog goal, but in a context where
          some constraints may already be enqueued for execution, in
          which case those constraints will run after the completion of
          the call request.


`fd_global(:CONSTRAINT, +STATE, +SUSP)'
`fd_global(:CONSTRAINT, +STATE, +SUSP, +OPTIONS)'
     where CONSTRAINT is a constraint goal, STATE is its initial state,
     and SUSP is a term encoding how the constraint should wake up in
     response to domain changes.  This predicate posts the constraint.

     SUSP is a list of F(VAR) terms where VAR is a variable to suspend
     on and F is a functor encoding when to wake up:

    `dom(X)'
          wake up when the domain of X has changed

    `min(X)'
          wake up when the lower bound of X has changed

    `max(X)'
          wake up when the upper bound of X has changed

    `minmax(X)'
          wake up when the lower or upper of X has changed

    `val(X)'
          wake up when X has become ground

     OPTIONS is a list of zero or more of the following:

    `source(TERM)'
          By default, the symbolic form computed by `copy_term/3', and
          shown in the answer constraint if `clpfd:full_answer' holds,
          equals CONSTRAINT, module name expanded.  With this option,
          the symbolic form will instead be TERM.  In particular, if
          TERM equals `true', the constraint will not appear in the
          BODY argument of `copy_term/3'.  This can be useful if you
          are posting some redundant (implied) constraint.

    `idempotent(BOOLEAN)'
          If `true' (the default), the constraint solving method is
          assumed to be idempotent.  That is, in the scope of
          `clpfd:dispatch_global/4', the solver will not check for the
          resumption conditions for the given constraint, while
          performing its ACTIONS.  If `false', an action may well cause
          the solver to resume the constraint that produced the action.

          If a variable occurs more than once in a global constraint
          that is being posted, or due to a variable-variable
          unification, the solver will no longer trust the constraint
          solving method to be idempotent.

   For an example of usage, *note A Global Constraint Example::.

   The following predicate controls operational aspects of the
constraint solver:

`fd_flag(+FLAGNAME, ?OLDVALUE, ?NEWVALUE)'
     OLDVALUE is the value of the FD flag FLAGNAME, and the new value
     of FLAGNAME is set to NEWVALUE.  The possible FD flag names and
     values are:

    `overflow'
          Determines the behavior on integer overflow conditions.
          Possible values:

         `error'
               Raises a representation error (the default).

         `fail'
               Silently fails.

    `debug'
          Controls the visibility of constraint propagation. Possible
          values are `on' and `off' (the default).  For internal use by
          `library(fdbg)'.



File: sicstus.info,  Node: Reflection Predicates,  Next: FD Set Operations,  Prev: The Global Constraint Programming Interface,  Up: Defining Global Constraints

10.35.9.2 Reflection Predicates
...............................

The constraint solving method needs access to information about the
current domains of variables.  This is provided by the following
predicates, which are all constant time operations.

`fd_var(?X)'
     Checks that X is currently an unbound variable that is known to
     the CLPFD solver.

`fd_min(?X, ?MIN)'
     where X is a domain variable (or an integer).  MIN is unified with
     the smallest value in the current domain of X, i.e.  an integer or
     the atom `inf' denoting minus infinity.

`fd_max(?X, ?MAX)'
     where X is a domain variable (or an integer).  MAX is unified with
     the upper bound of the current domain of X, i.e. an integer or the
     atom `sup' denoting infinity.

`fd_size(?X, ?SIZE)'
     where X is a domain variable (or an integer).  SIZE is unified
     with the size of the current domain of X, if the domain is
     bounded, or the atom `sup' otherwise.

`fd_set(?X, ?SET)'
     where X is a domain variable (or an integer).  SET is unified with
     an FD set denoting the internal representation of the current
     domain of X; see below.

`fd_dom(?X, ?RANGE)'
     where X is a domain variable (or an integer).  RANGE is unified
     with a CONSTANTRANGE (*note Syntax of Indexicals::) denoting the
     current domain of X.

`fd_degree(?X, ?DEGREE)'
     where X is a domain variable (or an integer).  DEGREE is unified
     with the number of constraints that are attached to X.

          *Please note*: this number may include some constraints that
          have been detected as entailed.  Also, DEGREE is not the
          number of neighbors of X in the constraint network.

   The following predicates can be used for computing the set of
variables that are (transitively) connected via constraints to some
given variable(s).

`fd_neighbors(+VAR, -NEIGHBORS)'
     Given a domain variable VAR, NEIGHBORS is the set of variables
     that can be reached from VAR via constraints posted so far.

`fd_closure(+VARS, -CLOSURE)'
     Given a list VARS of domain variables, CLOSURE is the set of
     variables (including VARS) that can be transitively reached via
     constraints posted so far.  Thus, `fd_closure/2' is the transitive
     closure of `fd_neighbors/2'.


File: sicstus.info,  Node: FD Set Operations,  Next: A Global Constraint Example,  Prev: Reflection Predicates,  Up: Defining Global Constraints

10.35.9.3 FD Set Operations
...........................

The domains of variables are internally represented compactly as "FD
set" terms.  The details of this representation are subject to change
and should not be relied on.  Therefore, a number of operations on FD
sets are provided, as such terms play an important role in the
interface.  The following operations are the primitive ones:

`is_fdset(+SET)'
     SET is a valid FD set.

`empty_fdset(?SET)'
     SET is the empty FD set.

`fdset_parts(?SET, ?MIN, ?MAX, ?REST)'
     SET is an FD set, which is a union of the non-empty interval
     [MIN,MAX] and the FD set REST, and all elements of REST are
     greater than MAX+1.  MIN and MAX are both integers or the atoms
     `inf' and `sup', denoting minus and plus infinity, respectively.
     Either SET or all the other arguments must be ground.

   The following operations can all be defined in terms of the primitive
ones, but in most cases, a more efficient implementation is used:

`empty_interval(+MIN, +MAX)'
     [MIN,MAX] is an empty interval.

`fdset_interval(?SET, ?MIN, ?MAX)'
     SET is an FD set, which is the non-empty interval [MIN,MAX].

`fdset_singleton(?SET, ?ELT)'
     SET is an FD set containing ELT only.  At least one of the
     arguments must be ground.

`fdset_min(+SET, -MIN)'
     MIN is the lower bound of SET.

`fdset_max(+SET, -MIN)'
     MAX is the upper bound of SET.  This operation is linear in the
     number of intervals of SET.

`fdset_size(+SET, -SIZE)'
     SIZE is the cardinality of SET, represented as `sup' if SET is
     infinite.  This operation is linear in the number of intervals of
     SET.

`list_to_fdset(+LIST, -SET)'
     SET is the FD set containing the elements of LIST.  Slightly more
     efficient if LIST is ordered.

`fdset_to_list(+SET, -LIST)'
     LIST is an ordered list of the elements of SET, which must be
     finite.

`range_to_fdset(+RANGE, -SET)'
     SET is the FD set containing the elements of the CONSTANTRANGE
     (*note Syntax of Indexicals::) RANGE.

`fdset_to_range(+SET, -RANGE)'
     RANGE is a constant interval, a singleton constant set, or a union
     of such, denoting the same set as SET.

`fdset_add_element(+SET1, +ELT -SET2)'
     SET2 is SET1 with ELT inserted in it.

`fdset_del_element(+SET1, +ELT, -SET2)'
     SET2 is like SET1 but with ELT removed.

`fdset_disjoint(+SET1, +SET2)'
     The two FD sets have no elements in common.

`fdset_intersect(+SET1, +SET2)'
     The two FD sets have at least one element in common.

`fdset_intersection(+SET1, +SET2, -INTERSECTION)'
     INTERSECTION is the intersection between SET1 and SET2.

`fdset_intersection(+SETS, -INTERSECTION)'
     INTERSECTION is the intersection of all the sets in SETS.

`fdset_member(?ELT, +SET)'
     is true when ELT is a member of SET.  If ELT is unbound, SET must
     be finite.

`fdset_eq(+SET1, +SET2)'
     Is true when the two arguments represent the same set i.e. they
     are identical.

`fdset_subset(+SET1, +SET2)'
     Every element of SET1 appears in SET2.

`fdset_subtract(+SET1, +SET2, -DIFFERENCE)'
     DIFFERENCE contains all and only the elements of SET1 that are not
     also in SET2.

`fdset_union(+SET1, +SET2, -UNION)'
     UNION is the union of SET1 and SET2.

`fdset_union(+SETS, -UNION)'
     UNION is the union of all the sets in SETS.

`fdset_complement(+SET, -COMPLEMENT)'
     COMPLEMENT is the complement of SET wrt. `inf..sup'.


File: sicstus.info,  Node: A Global Constraint Example,  Prev: FD Set Operations,  Up: Defining Global Constraints

10.35.9.4 A Global Constraint Example
.....................................

The following example defines a new global constraint `exactly(X,L,N)',
which is true if X occurs exactly N times in the list L of integers and
domain variables.  N must be an integer when the constraint is posted.
A version without this restriction and defined in terms of reified
equalities was presented earlier; *note Reified Constraints::.

   This example illustrates the use of state information.  The state has
two components: the list of variables that could still be X, and the
number of variables still required to be X.

   The constraint is defined to wake up on any domain change.

                                                         _% exactly.pl_
     /*
     An implementation of exactly(I, X[1]...X[m], N):

     Necessary condition: 0 <= N <= m.
     Rewrite rules:

     [1] |= X[i]=I  ==> exactly(I, X[1]...X[i-1],X[i+1]...X[m], N-1):
     [2] |= X[i]!=I ==> exactly(I, X[1]...X[i-1],X[i+1]...X[m], N):
     [3] |= N=0     ==> X[1]!=I ... X[m]!=I
     [4] |= N=m     ==> X[1]=I  ... X[m]=I
     */
     :- use_module(library(clpfd)).

     % the entrypoint
     exactly(I, Xs, N) :-
             dom_suspensions(Xs, Susp),
             fd_global(exactly(I,Xs,N), state(Xs,N), Susp).

     dom_suspensions([], []).
     dom_suspensions([X|Xs], [dom(X)|Susp]) :-
             dom_suspensions(Xs, Susp).

     % the solver method
     :- multifile clpfd:dispatch_global/4.
     clpfd:dispatch_global(exactly(I,_,_), state(Xs0,N0), state(Xs,N), Actions) :-
             exactly_solver(I, Xs0, Xs, N0, N, Actions).

     exactly_solver(I, Xs0, Xs, N0, N, Actions) :-
             ex_filter(Xs0, Xs, N0, N, I),
             length(Xs, M),
             (   N=:=0 -> Actions = [exit|Ps], ex_neq(Xs, I, Ps)
             ;   N=:=M -> Actions = [exit|Ps], ex_eq(Xs, I, Ps)
             ;   N>0, N<M -> Actions = []
             ;   Actions = [fail]
             ).

                                                         _% exactly.pl_
     % rules [1,2]: filter the X's, decrementing N
     ex_filter([], [], N, N, _).
     ex_filter([X|Xs], Ys, L, N, I) :- X==I, !,
             M is L-1,
             ex_filter(Xs, Ys, M, N, I).
     ex_filter([X|Xs], Ys0, L, N, I) :-
             fd_set(X, Set),
             fdset_member(I, Set), !,
             Ys0 = [X|Ys],
             ex_filter(Xs, Ys, L, N, I).
     ex_filter([_|Xs], Ys, L, N, I) :-
             ex_filter(Xs, Ys, L, N, I).

     % rule [3]: all must be neq I
     ex_neq(Xs, I, Ps) :-
             fdset_singleton(Set0, I),
             fdset_complement(Set0, Set),
             eq_all(Xs, Set, Ps).

     % rule [4]: all must be eq I
     ex_eq(Xs, I, Ps) :-
             fdset_singleton(Set, I),
             eq_all(Xs, Set, Ps).

     eq_all([], _, []).
     eq_all([X|Xs], Set, [X in_set Set|Ps]) :-
             eq_all(Xs, Set, Ps).

     end_of_file.

     % sample queries:

     | ?- exactly(5,[A,B,C],1), A=5.
     A = 5,
     B in(inf..4)\/(6..sup), C in(inf..4)\/(6..sup)

     | ?- exactly(5,[A,B,C],1), A in 1..2, B in 3..4.
     C = 5,
     A in 1..2,
     B in 3..4


File: sicstus.info,  Node: Defining Primitive Constraints,  Next: CLPFD Coexisting,  Prev: Defining Global Constraints,  Up: lib-clpfd

10.35.10 Defining Primitive Constraints
---------------------------------------

Indexicals are the principal means of defining constraints, but it is
usually not necessary to resort to this level of programming--most
commonly used constraints are available in a library and/or via
macro-expansion.  The key feature about indexicals is that they give the
programmer precise control over aspects of the operational semantics of
the constraints. Trade-offs can be made between the computational cost
of the constraints and their pruning power.  The indexical language
provides many degrees of freedom for the user to select the level of
consistency to be maintained depending on application-specific needs.

* Menu:

* Definitions:: Definitions
* Pitfalls of Interval Reasoning:: Pitfalls of Interval Reasoning
* Indexicals:: Indexicals
* Range Expressions:: Range Expressions
* Term Expressions:: Term Expressions
* Monotonicity of Ranges:: Monotonicity of Ranges
* FD Predicates:: FD Predicates
* Execution of Propagating Indexicals:: Execution of Propagating Indexicals
* Execution of Checking Indexicals:: Execution of Checking Indexicals
* Compiled Indexicals:: Compiled Indexicals


File: sicstus.info,  Node: Definitions,  Next: Pitfalls of Interval Reasoning,  Up: Defining Primitive Constraints

10.35.10.1 Definitions
......................

For constraint store S, variable X, and finite domain R:

   * D(X,S) denotes the domain of X in S.

   * (X IN R)(S) denotes the extension of S where D(X,S) has been
     intersected with R.

   The following definitions, adapted from [Van Hentenryck et al. 95],
define important notions of consistency and entailment of constraints
wrt. stores.

   A ground constraint is "true" if it holds and "false" otherwise.

   A constraint C is "domain-consistent wrt. S" iff, for each variable
XI and value VI in D(XI,S), there exist values VJ in D(XJ,S), 1 <= J <=
N /\ I != J, such that C(V1,...,VN) is true.

   A constraint C is "domain-entailed by S" iff, for all values VJ in
D(XJ,S), 1 <= J <= N, C(V1,...,VN) is true.

   Let D'(X,S) denote the interval [MIN(D(X,S)),MAX(D(X,S))].

   A constraint C is "bounds-consistent wrt. S" iff, for each variable
XI, there exist values VJ and WJ in D'(XJ,S), 1 <= J <= N, I != J, such
that C(V1,...,MIN(D(XI,S)),...,VN) and C(W1,...,MAX(D(XI,S)),...,WN)
are both true.

   A constraint C is "bounds-entailed by S" iff, for all values VJ in
D'(XJ,S), 1 <= J <= N, C(V1,...,VN) is true.

   Finally, a constraint is "domain-disentailed (bounds-disentailed)" by
S iff its negation is domain-entailed (bounds-entailed) by S.


File: sicstus.info,  Node: Pitfalls of Interval Reasoning,  Next: Indexicals,  Prev: Definitions,  Up: Defining Primitive Constraints

10.35.10.2 Pitfalls of Interval Reasoning
.........................................

In most circumstances, arithmetic constraints maintain
bounds-consistency and detect bounds-entailment and -disentailment.
There are cases where a bounds-consistency maintaining constraint may
detect a contradiction when the constraint is not yet
bounds-disentailed, as the following example illustrates.  Note that `X
#\= Y' maintains domain-consistency if both arguments are constants or
variables:

     | ?- X+Y #= Z, X=1, Z=6, Y in 1..10, Y #\= 5.
     no
     | ?- X+Y #= Z #<=> B, X=1, Z=6, Y in 1..10, Y #\= 5.
     X = 1,
     Z = 6,
     Y in(1..4)\/(6..10),
     B in 0..1

   Since `1+5#=6' holds, `X+Y #= Z' is not bounds-disentailed, although
any attempt to make it bounds-consistent wrt. the store results in a
contradictory store.


File: sicstus.info,  Node: Indexicals,  Next: Range Expressions,  Prev: Pitfalls of Interval Reasoning,  Up: Defining Primitive Constraints

10.35.10.3 Indexicals
.....................

An "indexical" is a reactive functional rule of the form `X in R',
where R is a finite domain valued "range expression" (see below).
*Note Syntax of Indexicals:: for a grammar defining indexicals and
range expressions.

   Indexicals can play one of two roles: "propagating indexicals" are
used for constraint solving, and "checking indexicals" are used for
entailment checking.  Let S(R) denote the value of R in S.  When a
propagating indexical fires, the current store S is extended to (X IN
S(R))(S).  When a checking indexical fires, it checks if D(X,S) is
contained in S(R), in which case the constraint corresponding to the
indexical is detected as entailed.


File: sicstus.info,  Node: Range Expressions,  Next: Term Expressions,  Prev: Indexicals,  Up: Defining Primitive Constraints

10.35.10.4 Range Expressions
............................

A range expression has one of the following forms, where RI denote
range expressions, TI denote integer valued "term expressions", S(TI)
denotes the integer value of TI in S, X denotes a variable, I denotes
an integer, and S denotes the current store.

`dom(X)'
     evaluates to D(X,S)

`{T1,...,TN}'
     evaluates to {S(T1),...,S(TN)}.  Any TI containing a variable that
     is not "quantified" by `unionof/3' will cause the indexical to
     suspend until this variable has been assigned.

`T1..T2'
     evaluates to the interval between S(T1) and S(T2).

`R1/\R2'
     evaluates to the intersection of S(R1) and S(R2)

`R1\/R2'
     evaluates to the union of S(R1) and S(R2)

`\R2'
     evaluates to the complement of S(R2)

`R1+R2'
`R1+T2'
     evaluates to S(R2) or S(T2) added pointwise to S(R1)

`-R2'
     evaluates to S(R2) negated pointwise

`R1-R2'
`R1-T2'
`T1-R2'
     evaluates to S(R2) or S(T2) subtracted pointwise from S(R1) or
     S(T1)

`R1 mod R2'
`R1 mod T2'
     evaluates to the pointwise floored modulo of S(R1) and S(R2) or
     S(T2)

`R1 rem R2'
`R1 rem T2'
     evaluates to the pointwise truncated remainder of S(R1) and S(R2)
     or S(T2)

`R1 ? R2'
     evaluates to S(R2) if S(R1) is a non-empty set; otherwise,
     evaluates to the empty set.  This expression is commonly used in
     the context `(R1 ? (inf..sup) \/ R3)', which evaluates to S(R3) if
     S(R1) is an empty set; otherwise, evaluates to `inf..sup'.  As an
     optimization, R3 is not evaluated while the value of R1 is a
     non-empty set.

`unionof(X,R1,R2)'
     evaluates to the union of S(E1),...,S(EN), where each EI has been
     formed by substituting K for X in R2, where K is the I:th element
     of S(R1).  *Note N Queens:: for an example of usage.

          *Please note*: if S(R1) is infinite, the evaluation of the
          indexical will be abandoned, and the indexical will simply
          suspend.

`switch(T,MAPLIST)'
     evaluates to S(E) if S(T1) equals K and MAPLIST contains a pair
     `K-E'.  Otherwise, evaluates to the empty set.  If T contains a
     variable that is not "quantified" by `unionof/3', the indexical
     will suspend until this variable has been assigned.


File: sicstus.info,  Node: Term Expressions,  Next: Monotonicity of Ranges,  Prev: Range Expressions,  Up: Defining Primitive Constraints

10.35.10.5 Term Expressions
...........................

A term expression has one of the following forms, where T1 and T2
denote term expressions, X denotes a variable, I denotes an integer,
and S denotes the current store.

`min(X)'
     evaluates to the minimum of D(X,S)

`max(X)'
     evaluates to the maximum of D(X,S)

`card(X)'
     evaluates to the size of D(X,S)

`X'
     evaluates to the integer value of X.  The indexical will suspend
     until X is assigned.

`I'
     an integer

`inf'
     minus infinity

`sup'
     plus infinity

`-T1'
     evaluates to S(T1) negated

`T1+T2'
     evaluates to the sum of S(T1) and S(T2)

`T1-T2'
     evaluates to the difference of S(T1) and S(T2)

`T1*T2'
     evaluates to the product of S(T1) and S(T2), where S(T2) must not
     be negative

`T1/>T2'
     evaluates to the floored quotient of S(T1) and S(T2), where S(T2)
     must be positive

`T1/<T2'
     evaluates to the ceilinged quotient of S(T1) and S(T2), where
     S(T2) must be positive

`T1 mod T2'
     evaluates to the floored remainder of S(T1) and S(T2)

`T1 rem T2'
     evaluates to the truncated remainder of S(T1) and S(T2)


File: sicstus.info,  Node: Monotonicity of Ranges,  Next: FD Predicates,  Prev: Term Expressions,  Up: Defining Primitive Constraints

10.35.10.6 Monotonicity of Ranges
.................................

A range R is "monotone in S" iff the value of R in S' is contained in
the value of R in S, for every extension S' of S.  A range R is
"anti-monotone in S" iff the value of R in S is contained in the value
of R in S', for every extension S' of S.  By abuse of notation, we will
say that `X in R' is (anti-)monotone iff R is (anti-)monotone.

   The consistency or entailment of a constraint C expressed as
indexicals `X in R' in a store S is checked by considering the
relationship between D(X,S) and S(R), together with the
(anti-)monotonicity of R in S.  The details are given in *note
Execution of Propagating Indexicals:: and *note Execution of Checking
Indexicals::.

   The solver checks (anti-)monotonicity by requiring that certain
variables occurring in the indexical be ground.  This sufficient
condition can sometimes be false for an (anti-)monotone indexical, but
such situations are rare in practice.


File: sicstus.info,  Node: FD Predicates,  Next: Execution of Propagating Indexicals,  Prev: Monotonicity of Ranges,  Up: Defining Primitive Constraints

10.35.10.7 FD Predicates
........................

The following example defines the constraint X+Y=T as an FD predicate
in terms of three indexicals.  Each indexical is a rule responsible for
removing values detected as incompatible from one particular constraint
argument.  Indexicals are _not_ Prolog goals; thus, the example does
not express a conjunction.  However, an indexical may make the store
contradictory, in which case backtracking is triggered:

     plus(X,Y,T) +:
             X in min(T) - max(Y) .. max(T) - min(Y),
             Y in min(T) - max(X) .. max(T) - min(X),
             T in min(X) + min(Y) .. max(X) + max(Y).

   The above definition contains a single clause used for constraint
solving.  The first indexical wakes up whenever the bounds of S(T) or
S(Y) are updated, and removes from D(X,S) any values that are not
compatible with the new bounds of T and Y.  Note that in the event of
"holes" in the domains of T or Y, D(X,S) may contain some values that
are incompatible with X+Y=T but go undetected.  Like most built-in
arithmetic constraints, the above definition maintains
bounds-consistency, which is significantly cheaper to maintain than
domain-consistency and suffices in most cases.  The constraint could
for example be used as follows:

     | ?- X in 1..5, Y in 2..8, plus(X,Y,T).
     X in 1..5,
     Y in 2..8,
     T in 3..13

   Thus, when an FD predicate is called, the `+:' clause is activated.

   The definition of a user constraint has to specify the variables
involved and the finite domains with which their domains should be
intersected when the propagator is run.  Therefore the FD predicate with
N arguments consists of N indexicals, each specifying a left hand side
variable and a right hand side expression that evaluates to a finite
domain, which is a function of the expression and of the constraint
store.  For example, the third indexical in the above FD predicate
evaluates to the finite domain 3..13 for T if D(X,S) = 1..5 and D(Y,S)
= 2..8.  As the domain of some variables gets smaller, the indexical
may further narrow the domain of other variables.  Therefore such an
indexical (called a propagating indexical) acts as a coroutine reacting
to the changes in the store by enforcing further changes in the store.

   In general there are three stages in the lifetime of a propagating
indexical.  When it is posted it may not be evaluated immediately (e.g.
has to wait until some variables are ground before being able to modify
the store).  Until the preconditions for the evaluation are satisfied,
the coroutine is blocked.  When the indexical becomes unblocked, it
computes a finite domain for intersecting with the domain of its left
hand side.  The coroutine then waits until some change occurs in a
domain of a variable occurring in its right hand side.  Eventually, the
computation reaches a point when the indexical is entailed by the
store, i.e. no changes in its right hand side can prune its left hand
side any longer, and the coroutine can cease to exist.

   Note that FD predicates must be correct and checking (*note CLPFD
Interface::).

   There can be several alternative definitions for the same user
constraint with different strengths in propagation.  For example, the
definition of `plusd' below encodes the same `X+Y=T' constraint as the
`plus' predicate above, but maintaining domain-consistency:

     plusd(X,Y,T) +:
             X in dom(T) - dom(Y),
             Y in dom(T) - dom(X),
             T in dom(X) + dom(Y).

     | ?- X in {1}\/{3}, Y in {10}\/{20}, plusd(X, Y, T).
     X in{1}\/{3},
     Y in{10}\/{20},
     T in{11}\/{13}\/{21}\/{23}

   This costs more in terms of execution time, but gives more precise
results. For singleton domains `plus' and `plusd' behave in the same
way.

   In our design, general indexicals can only appear in the context of
FD predicate definitions.  The rationale for this restriction is the
need for general indexicals to be able to suspend and resume, and this
ability is only provided by the FD predicate mechanism.

   If the program merely posts a constraint, it suffices for the
definition to contain a single clause for solving the constraint.  If a
constraint is reified or occurs in a propositional formula, the
definition must contain four clauses for solving and checking
entailment of the constraint and its negation.  The role of each clause
is reflected in the "neck" operator.  The following table summarizes
the different forms of indexical clauses corresponding to a constraint
C.  In all cases, HEAD should be a compound term with all arguments
being distinct variables:

`HEAD +: INDEXICALS.'
     The body consists of propagating indexicals for solving C.  The
     body can in fact be of a more general form--*note Compiled
     Indexicals::.

`HEAD -: INDEXICALS.'
     The body consists of propagating indexicals for solving the
     negation of C.

`HEAD +? INDEXICAL.'
     The body consists of a single checking indexical for testing
     entailment of C.

`HEAD -? INDEXICAL.'
     The body consists of a single checking indexical for testing
     entailment of the negation of C.

   When a constraint is reified as in `CONSTRAINT #<=> B', the solver
spawns two coroutines corresponding to detecting entailment and
disentailment.  Eventually, one of them will succeed in this and
consequently will bind B to 0 or 1.  A third coroutine is spawned,
waiting for B to become assigned, at which time the constraint (or its
negation) is posted.  In the mean time, the constraint may have been
detected as (dis)entailed, in which case the third coroutine is
dismissed.

   As an example of a constraint with all methods defined, consider the
following library constraint defining a disequation between two domain
variables:

     'x\\=y'(X,Y) +:
             X in \{Y},
             Y in \{X}.
     'x\\=y'(X,Y) -:
             X in dom(Y),
             Y in dom(X).
     'x\\=y'(X,Y) +?
             X in \dom(Y).
     'x\\=y'(X,Y) -?
             X in {Y}.

   The following sections provide more precise coding rules and
operational details for indexicals.  `X in R' denotes an indexical
corresponding to a constraint C.  S denotes the current store.


File: sicstus.info,  Node: Execution of Propagating Indexicals,  Next: Execution of Checking Indexicals,  Prev: FD Predicates,  Up: Defining Primitive Constraints

10.35.10.8 Execution of Propagating Indexicals
..............................................

Consider the definition of a constraint C containing a propagating
indexical `X in R'.  Let TV(X,C,S) denote the set of values for X that
can make C true in some ground extension of the store S.  Then the
indexical should obey the following coding rules:

   * all arguments of C except X should occur in R

   * if R is ground in S, S(R) = TV(X,C,S)

   If the coding rules are observed, S(R) can be proven to contain
TV(X,C,S) for all stores in which R is monotone.  Hence it is natural
for the implementation to wait until R becomes monotone before
admitting the propagating indexical for execution.  The execution of `X
in R' thus involves the following:

   * If D(X,S) is disjoint from S(R), a contradiction is detected.

   * If D(X,S) is contained in S(R), D(X,S) does not contain any values
     known to be incompatible with C, and the indexical suspends,
     unless R is ground in S, in which case C is detected as entailed.

   * Otherwise, D(X,S) contains some values that are known to be
     incompatible with C.  Hence, S is extended to (X IN S(R))(S) (X is
     "pruned"), and the indexical suspends, unless R is ground in S, in
     which case C is detected as entailed.

   A propagating indexical is scheduled for execution as follows:

   * it is evaluated initially as soon as it has become monotone

   * it is re-evaluated when one of the following conditions occurs:
       1. the domain of a variable Y that occurs as `dom(Y)'       or
          `card(Y)' in R has been updated

       2. the lower bound of a variable Y that occurs as `min(Y)'
          in R has been updated

       3. the upper bound of a variable Y that occurs as `max(Y)'
          in R has been updated


File: sicstus.info,  Node: Execution of Checking Indexicals,  Next: Compiled Indexicals,  Prev: Execution of Propagating Indexicals,  Up: Defining Primitive Constraints

10.35.10.9 Execution of Checking Indexicals
...........................................

Consider the definition of a constraint C containing a checking
indexical `X in R'.  Let FV(X,C,S) denote the set of values for X that
can make C false in some ground extension of the store S.  Then the
indexical should obey the following coding rules:

   * all arguments of C except X should occur in R

   * if R is ground in S, S(R) = TV(X,C,S)

   If the coding rules are observed, S(R) can be proven to exclude
FV(X,C,S) for all stores in which R is anti-monotone.  Hence it is
natural for the implementation to wait until R becomes anti-monotone
before admitting the checking indexical for execution.  The execution
of `X in R' thus involves the following:

   * If D(X,S) is contained in S(R), none of the possible values for X
     can make C false, and so C is detected as entailed.

   * Otherwise, if D(X,S) is disjoint from S(R) and R is ground in S,
     all possible values for X will make C false, and so C is detected
     as disentailed.

   * Otherwise, D(X,S) contains some values that could make C true and
     some that could make C false, and the indexical suspends.

   A checking indexical is scheduled for execution as follows:

   * it is evaluated initially as soon as it has become anti-monotone

   * it is re-evaluated when one of the following conditions occurs:
       1. the domain of X has been pruned, or X has been assigned

       2. the domain of a variable Y that occurs as `dom(Y)'       or
          `card(Y)' in R has been pruned

       3. the lower bound of a variable Y that occurs as `min(Y)'
          in R has been increased

       4. the upper bound of a variable Y that occurs as `max(Y)'
          in R has been decreased


File: sicstus.info,  Node: Compiled Indexicals,  Prev: Execution of Checking Indexicals,  Up: Defining Primitive Constraints

10.35.10.10 Compiled Indexicals
...............................

The arithmetic, membership, and propositional constraints described
earlier are transformed at compile time to conjunctions of library
constraints.  Although linear in the size of the source code, the
expansion of a constraint to library goals can have time and memory
overheads.  Temporary variables holding intermediate values may have to
be introduced, and the grain size of the constraint solver invocations
can be rather small.  Therefore, an automatic translation by compilation
to indexicals is also provided for a selected set of constraints.  The
syntax for this construction is:

`HEAD +: CONSTRAINTBODY   "since release 4.1.3"'
     HEAD should be a compound term with all arguments being distinct
     variables.  CONSTRAINTBODY should be a constraint amenable to
     compilation to indexicals, and should not contain any variable not
     mentioned in HEAD.  This clause defines the constraint HEAD to
     hold iff CONSTRAINTBODY is true.

   Roughly, a constraint amenable to such compilation is of one of the
following forms, or is a propositional combination of such forms.
*Note Syntax of Indexicals:: for the exact definition:

   * "var" `in' CONSTANTRANGE

   * `element("var",CLIST,"var")'

   * `table([VLIST],CTABLE)'

   * LINEXPR RELOP LINEXPR

   * "var" { `X' stands for `X#=1' }


File: sicstus.info,  Node: CLPFD Coexisting,  Next: CLPFD Example Programs,  Prev: Defining Primitive Constraints,  Up: lib-clpfd

10.35.11 Coexisting with Attributes and Blocked Goals
-----------------------------------------------------

Domain variables may have attributes from other modules, as well as
blocked goals, attached to them.  However, the CLPFD propagation phase
runs to completion before invoking handlers for such attributes and
resuming such blocked goals.  This could mean in particular that upon
completion of the propagation phase, attribute handlers and blocked
goals for multiple variables are ready to execute.  For details, see the
`verify_attributes/3' hook at *note lib-atts::.


File: sicstus.info,  Node: CLPFD Example Programs,  Next: Syntax Summary,  Prev: CLPFD Coexisting,  Up: lib-clpfd

10.35.12 Example Programs
-------------------------

* Menu:

* Send More Money:: Send More Money
* N Queens:: N Queens
* Cumulative Scheduling:: Cumulative Scheduling

   This section contains a few example programs.  The first two programs
are included in a benchmark suite that comes with the distribution.  The
benchmark suite is run by typing:

     | ?- compile(library('clpfd/examples/bench')).
     | ?- bench.


File: sicstus.info,  Node: Send More Money,  Next: N Queens,  Up: CLPFD Example Programs

10.35.12.1 Send More Money
..........................

Let us return briefly to the Send More Money problem (*note A
Constraint Satisfaction Problem::).  Its `sum/8' predicate will expand
to a `scalar_product/4' constraint.  An indexical version is defined
simply by changing the neck symbol of `sum/8' from `:-' to `+:', thus
turning it into an FD predicate:

     sum(S, E, N, D, M, O, R, Y) +:
                       1000*S + 100*E + 10*N + D
          +            1000*M + 100*O + 10*R + E
          #= 10000*M + 1000*O + 100*N + 10*E + Y.


File: sicstus.info,  Node: N Queens,  Next: Cumulative Scheduling,  Prev: Send More Money,  Up: CLPFD Example Programs

10.35.12.2 N Queens
...................

The problem is to place N queens on an NxN chess board so that no queen
is threatened by another queen.

   The variables of this problem are the N queens.  Each queen has a
designated row.  The problem is to select a column for it.

   The main constraint of this problem is that no queen threaten
another.  This is encoded by the `no_threat/3' constraint and holds
between all pairs `(X,Y)' of queens.  It could be defined as:

     no_threat(X, Y, I) :-
             X   #\= Y,
             X+I #\= Y,
             X-I #\= Y.

   However, this formulation introduces new temporary domain variables
and creates twelve fine-grained indexicals.  Worse, the disequalities
only maintain bounds-consistency and so may miss some opportunities for
pruning elements in the middle of domains.

   A better idea is to formulate `no_threat/3' as an FD predicate with
two indexicals, as shown in the program below.  This constraint will not
fire until one of the queens has been assigned (the corresponding
indexical does not become monotone until then).  Hence, the constraint
is still not as strong as it could be.

   For example, if the domain of one queen is `2..3', it will threaten
any queen placed in column 2 or 3 on an adjacent row, no matter which of
the two open positions is chosen for the first queen.  The commented out
formulation of the constraint captures this reasoning, and illustrates
the use of the `unionof/3' operator.  This stronger version of the
constraint indeed gives less backtracking, but is computationally more
expensive and does not pay off in terms of execution time, except
possibly for very large chess boards.

   It is clear that `no_threat/3' cannot detect any incompatible values
for a queen with domain of size greater than three.  This observation
is exploited in the third version of the constraint.

   The first-fail principle is appropriate in the enumeration part of
this problem.

     :- use_module(library(clpfd)).

     queens(N, L, LabelingType) :-
          length(L, N),
          domain(L, 1, N),
          constrain_all(L),
          labeling(LabelingType, L).

     constrain_all([]).
     constrain_all([X|Xs]) :-
          constrain_between(X, Xs, 1),
          constrain_all(Xs).

     constrain_between(_X, [], _N).
     constrain_between(X, [Y|Ys], N) :-
          no_threat(X, Y, N),
          N1 is N+1,
          constrain_between(X, Ys, N1).


     % version 1: weak but efficient
     no_threat(X, Y, I) +:
          X in \({Y} \/ {Y+I} \/ {Y-I}),
          Y in \({X} \/ {X+I} \/ {X-I}).

     /*
     % version 2: strong but very inefficient version
     no_threat(X, Y, I) +:
         X in unionof(B,dom(Y),\({B} \/ {B+I} \/ {B-I})),
         Y in unionof(B,dom(X),\({B} \/ {B+I} \/ {B-I})).

     % version 3: strong but somewhat inefficient version
     no_threat(X, Y, I) +:
         X in (4..card(Y)) ? (inf..sup) \/
               unionof(B,dom(Y),\({B} \/ {B+I} \/ {B-I})),
         Y in (4..card(X)) ? (inf..sup) \/
               unionof(B,dom(X),\({B} \/ {B+I} \/ {B-I})).
     */

     | ?- queens(8, L, [ff]).
     L = [1,5,8,6,3,7,2,4]


File: sicstus.info,  Node: Cumulative Scheduling,  Prev: N Queens,  Up: CLPFD Example Programs

10.35.12.3 Cumulative Scheduling
................................

This example is a very small scheduling problem.  We consider seven
tasks where each task has a fixed duration and a fixed amount of used
resource:

TASK     DURATION     RESOURCE
`t1'     16           2
`t2'     6            9
`t3'     13           3
`t4'     7            7
`t5'     5            10
`t6'     18           1
`t7'     4            11

   The goal is to find a schedule that minimizes the completion time for
the schedule while not exceeding the capacity 13 of the resource.  The
resource constraint is succinctly captured by a `cumulative/2'
constraint.  Branch-and-bound search is used to find the minimal
completion time.

   This example was adapted from [Beldiceanu & Contejean 94].

     :- use_module(library(clpfd)).

     schedule(Ss, End) :-
             Ss = [S1,S2,S3,S4,S5,S6,S7],
             Es = [E1,E2,E3,E4,E5,E6,E7],
             Tasks = [task(S1,16,E1, 2,0),
                      task(S2, 6,E2, 9,0),
                      task(S3,13,E3, 3,0),
                      task(S4, 7,E4, 7,0),
                      task(S5, 5,E5,10,0),
                      task(S6,18,E6, 1,0),
                      task(S7, 4,E7,11,0)],
             domain(Ss, 1, 30),
             domain(Es, 1, 50),
             domain([End], 1, 50),
             maximum(End, Es),
             cumulative(Tasks, [limit(13)]),
             append(Ss, [End], Vars),
             labeling([minimize(End)], Vars). % label End last

     %% End of file

     | ?- schedule(Ss, End).
     Ss = [1,17,10,10,5,5,1],
     End = 23


File: sicstus.info,  Node: Syntax Summary,  Prev: CLPFD Example Programs,  Up: lib-clpfd

10.35.13 Syntax Summary
-----------------------

* Menu:

* Syntax of Indexicals:: Syntax of Indexicals
* Syntax of Arithmetic Expressions:: Syntax of Arithmetic Expressions
* Operator Declarations:: Operator Declarations


File: sicstus.info,  Node: Syntax of Indexicals,  Next: Syntax of Arithmetic Expressions,  Up: Syntax Summary

10.35.13.1 Syntax of Indexicals
...............................

CONSTANT       ::= "integer"                 
               | `inf'                       { minus infinity }
               | `sup'                       { plus infinity }

TERM           ::= CONSTANT                  
               | "var"                       { suspend until assigned }
               | `min("var")'                { min. of domain of X }
               | `max("var")'                { max. of domain of X }
               | `card("var")'               { size of domain of X }
               | `-' TERM                    
               | TERM `+' TERM               
               | TERM `-' TERM               
               | TERM `*' TERM               
               | TERM `/>' TERM              { ceilinged division }
               | TERM `/<' TERM              { floored division }
               | TERM `mod' TERM             { floored remainder }
               | TERM `rem' TERM             { truncated remainder }

TERMSET        ::= `{TERM,...,TERM}'         

RANGE          ::= TERMSET                   
               | `dom("var")'                { domain of X }
               | TERM `..' TERM              { interval }
               | RANGE `/\' RANGE            { intersection }
               | RANGE `\/' RANGE            { union }
               | `\' RANGE                   { complement }
               | `-' RANGE                   { pointwise negation }
               | RANGE `+' RANGE             { pointwise addition }
               | RANGE `-' RANGE             { pointwise subtraction }
               | RANGE `mod' RANGE           { pointwise modulo }
               | RANGE `rem' RANGE           { pointwise remainder }
               | RANGE `+' TERM              { pointwise addition }
               | RANGE `-' TERM              { pointwise subtraction }
               | TERM `-' RANGE              { pointwise subtraction }
               | RANGE `mod' TERM            { pointwise floored
                                             remainder }
               | RANGE `rem' TERM            { pointwise truncated
                                             remainder }
               | RANGE `?' RANGE             
               |                             
               `unionof("var",RANGE,RANGE)'  
               | `switch(TERM,MAPLIST)'      

CONSTANTSET    ::= `{INTEGER,...,INTEGER}'   

CONSTANTRANGE  ::= CONSTANTSET               
               | CONSTANT `..' CONSTANT      
               | CONSTANTRANGE `/\'          
               CONSTANTRANGE                 
               | CONSTANTRANGE `\/'          
               CONSTANTRANGE                 
               | `\' CONSTANTRANGE           

MAPLIST        ::= `[]'                      
               |                             
               `["integer"-CONSTANTRANGE|MAPLIST]'

CTABLE         ::= `[]'                      
               | `[CROW|CTABLE]'             

CROW           ::= `[]'                      
               | `["integer"|CROW]'          
               | `[CONSTANTRANGE|CROW]'      

CLIST          ::= `[]'                      
               | `["integer"|CLIST]'         

VLIST          ::= `[]'                      
               | `["var"|VLIST]'             

INDEXICAL      ::= "var" `in' RANGE          

INDEXICALS     ::= INDEXICAL                 
               | INDEXICAL `,' INDEXICALS    

CONSTRAINTBODY ::= "var" { `X' stands for    
               `X#=1' }                      
               | `true'                      
               | `false'                     
               | `1'                         
               | `0'                         
               | "var" `in' CONSTANTRANGE    
               |                             
               `element("var",CLIST,"var")'  
               | `table([VLIST],CTABLE)'     
               | LINEXPR RELOP LINEXPR       
               | `#\ CONSTRAINTBODY'         
               | `CONSTRAINTBODY #/\         
               CONSTRAINTBODY'               
               | `CONSTRAINTBODY #\/         
               CONSTRAINTBODY'               
               | `CONSTRAINTBODY #=>         
               CONSTRAINTBODY'               
               | `CONSTRAINTBODY #\          
               CONSTRAINTBODY'               
               | `CONSTRAINTBODY #<=>        
               CONSTRAINTBODY'               

IXCONSTRAINTBODY::= INDEXICALS                
               | CONSTRAINTBODY              

HEAD           ::= "term"                    { a compound term with
                                             unique variable args }

TELLPOS        ::= HEAD `+:'                 
               IXCONSTRAINTBODY              
TELLNEG        ::= HEAD `-:' INDEXICALS      
ASKPOS         ::= HEAD `+?' INDEXICAL       
ASKNEG         ::= HEAD `-?' INDEXICAL       

CONSTRAINTDEF  ::= TELLPOS                   
               | TELLNEG                     
               | ASKPOS                      
               | ASKNEG                      


File: sicstus.info,  Node: Syntax of Arithmetic Expressions,  Next: Operator Declarations,  Prev: Syntax of Indexicals,  Up: Syntax Summary

10.35.13.2 Syntax of Arithmetic Expressions
...........................................

*Please note*: that the Prolog arithmetic operators `/' and `//' do not
mean the same thing.

N              ::= "integer"                 

LINEXPR        ::= N                         
               | "var"                       
               | N `*' "var"                 
               | N `*' N                     
               | `-' LINEXPR                 
               | LINEXPR `+' LINEXPR         
               | LINEXPR `-' LINEXPR         
               | CONSTRAINTBODY              { if true then 1 else 0 }

EXPR           ::= LINEXPR                   
               | `-' EXPR                    
               | EXPR `+' EXPR               
               | EXPR `-' EXPR               
               | EXPR `*' EXPR               
               | EXPR `/' EXPR               { truncated division }
               | EXPR `//' EXPR              { truncated division }
                                               "since release 4.3"
               | EXPR `div' EXPR             { floored division }  
                                             "since release 4.3"
               | EXPR `rem' EXPR             { truncated remainder }
               | EXPR `mod' EXPR             { floored remainder }
               | `min(EXPR,EXPR)'            
               | `max(EXPR,EXPR)'            
               | `abs(EXPR)'                 

RELOP          ::= `#=' | `#\=' | `#<' |     
               `#=<' | `#>' | `#>='          


File: sicstus.info,  Node: Operator Declarations,  Prev: Syntax of Arithmetic Expressions,  Up: Syntax Summary

10.35.13.3 Operator Declarations
................................

     :- op(1200, xfx, [+:,-:,+?,-?]).
     :- op(760, yfx, #<=>).
     :- op(750, xfy, #=>).
     :- op(750, yfx, #<=).
     :- op(740, yfx, #\/).
     :- op(730, yfx, #\).
     :- op(720, yfx, #/\).
     :- op(710, fy, #\).
     :- op(700, xfx, [in,in_set]).
     :- op(700, xfx, [#=,#\=,#<,#=<,#>,#>=]).
     :- op(550, xfx, ..).
     :- op(500, fy, \).
     :- op(490, yfx, ?).
     :- op(400, yfx, [/>,/<]).


File: sicstus.info,  Node: lib-clpb,  Next: lib-clpqr,  Prev: lib-clpfd,  Up: The Prolog Library

10.36 Constraint Logic Programming over Booleans--`library(clpb)'
=================================================================

* Menu:

* CLPB Introduction:: Introduction
* CLPB Interface:: Solver Interface
* CLPB Examples:: Examples


File: sicstus.info,  Node: CLPB Introduction,  Next: CLPB Interface,  Up: lib-clpb

10.36.1 Introduction
--------------------

The clp(B) system provided by this library module is an instance of the
general Constraint Logic Programming scheme introduced in [Jaffar &
Michaylov 87].  It is a solver for constraints over the Boolean domain,
i.e. the values 0 and 1.  The library module is a direct port from
SICStus Prolog 3. It is not supported by SICS in any way.

   The Boolean domain is particularly useful for modeling digital
circuits, and the constraint solver can be used for verification,
design, optimization etc. of such circuits.

   To load the solver, enter the query:

     | ?- use_module(library(clpb)).

   The solver contains predicates for checking the consistency and
entailment of a constraint wrt. previous constraints, and for computing
particular solutions to the set of previous constraints.

   The underlying representation of Boolean functions is based on
Boolean Decision Diagrams [Bryant 86].  This representation is very
efficient, and allows many combinatorial problems to be solved with
good performance.

   Boolean expressions are composed from the following operands: the
constants 0 and 1 (`FALSE' and `TRUE'), logical variables, and symbolic
constants, and from the following connectives.  P and Q are Boolean
expressions, X is a logical variable, IS is a list of integers or
integer ranges, and ES is a list of Boolean expressions:

`~ P'
     True if P is false.

`P * Q'
     True if P and Q are both true.

`P + Q'
     True if at least one of P and Q is true.

`P # Q'
     True if exactly one of P and Q is true.

`X ^ P'
     True if there exists an X such that P is true.  Same as `P[X/0] +
     P[X/1]'.

`P =:= Q'
     Same as `~P # Q'.

`P =\= Q'
     Same as `P # Q'.

`P =< Q'
     Same as `~P + Q'.

`P >= Q'
     Same as `P + ~Q'.

`P < Q'
     Same as `~P * Q'.

`P > Q'
     Same as `P * ~Q'.

`card(IS, ES)'
     True if the number of true expressions in ES is a member of the
     set denoted by IS.

   Symbolic constants (Prolog atoms) denote parametric values and can
be viewed as all-quantified variables whose quantifiers are placed
outside the entire expression.  They are useful for forcing certain
variables of an equation to be treated as input parameters.


File: sicstus.info,  Node: CLPB Interface,  Next: CLPB Examples,  Prev: CLPB Introduction,  Up: lib-clpb

10.36.2 Solver Interface
------------------------

The following predicates are defined:

`sat(+EXPRESSION)'
     EXPRESSION is a Boolean expression.  This checks the consistency
     of the expression wrt. the accumulated constraints, and, if the
     check succeeds, _tells_ the constraint that the expression be true.

     If a variable X, occurring in the expression, is subsequently
     unified with some term T, this is treated as a shorthand for the
     constraint
          | ?- sat(X=:=T).

`taut(+EXPRESSION, ?TRUTH)'
     EXPRESSION is a Boolean expression.  This _asks_ whether the
     expression is now entailed by the accumulated constraints
     (TRUTH=1), or whether its negation is entailed by the accumulated
     constraints (TRUTH=0).  Otherwise, it fails.

`labeling(+VARIABLES)'
     VARIABLES is a list of variables.  The variables are instantiated
     to a list of 0s and 1s, in a way that satisfies any accumulated
     constraints.  Enumerates all solutions by backtracking, but
     creates choicepoints only if necessary.


File: sicstus.info,  Node: CLPB Examples,  Prev: CLPB Interface,  Up: lib-clpb

10.36.3 Examples
----------------

* Menu:

* CLPB Example 1:: Example 1
* CLPB Example 2:: Example 2
* CLPB Example 3:: Example 3                   A one-bit adder circuit.
* CLPB Example 4:: Example 4                   Fault detection.


File: sicstus.info,  Node: CLPB Example 1,  Next: CLPB Example 2,  Up: CLPB Examples

10.36.3.1 Example 1
...................

     | ?- sat(X + Y).

     sat(X=\=_A*Y#Y)

illustrates three facts.  First, any accumulated constraints affecting
the top-level variables are displayed floundered goals, since the query
is not true for all `X' and `Y'.  Secondly, accumulated constraints are
displayed as `sat(V=:=EXPR)' or `sat(V=\=EXPR)' where V is a variable
and EXPR is a "polynomial", i.e. an exclusive or of conjunctions of
variables and constants.  Thirdly, `_A' had to be introduced as an
artificial variable, since `Y' cannot be expressed as a function of
`X'.  That is, `X + Y' is true iff there exists an `_A' such that
`X=\=_A*Y#Y'.  Let's check it!

     | ?- taut(_A ^ (X=\=_A*Y#Y) =:= X + Y, T).

     T = 1

verifies the above answer.  Notice that the formula in this query is a
tautology, and so it is entailed by an empty set of constraints.


File: sicstus.info,  Node: CLPB Example 2,  Next: CLPB Example 3,  Prev: CLPB Example 1,  Up: CLPB Examples

10.36.3.2 Example 2
...................

     | ?- taut(A =< C, T).

     no
     | ?- sat(A =< B), sat(B =< C), taut(A =< C, T).

     T = 1,
     sat(A=:=_A*_B*C),
     sat(B=:=_B*C)

     | ?- taut(a, T).

     T = 0

     | ?- taut(~a, T).

     T = 0

illustrates the entailment predicate.  In the first query, the
expression "A implies C" is neither known to be true nor false, so the
query fails.  In the second query, the system is told that "A implies
B" and "B implies C", so "A implies C" is entailed.  The expressions in
the third and fourth queries are to be read "for each a, a is true" and
"for each a, a is false", respectively, and so `T = 0' in both cases
since both are unsatisfiable.  This illustrates the fact that the
implicit universal quantifiers introduced by symbolic constants are
placed in front of the entire expression.


File: sicstus.info,  Node: CLPB Example 3,  Next: CLPB Example 4,  Prev: CLPB Example 2,  Up: CLPB Examples

10.36.3.3 Example 3
...................

     | ?- [user].
     | adder(X, Y, Sum, Cin, Cout) :-
          sat(Sum =:= card([1,3],[X,Y,Cin])),
          sat(Cout =:= card([2-3],[X,Y,Cin])).
     | ^D
     % consulted user in module user, 0 msec 424 bytes

     | ?- adder(x, y, Sum, cin, Cout).

     sat(Sum=:=cin#x#y),
     sat(Cout=:=x*cin#x*y#y*cin)

     | ?- adder(x, y, Sum, 0, Cout).

     sat(Sum=:=x#y),
     sat(Cout=:=x*y)

     | ?- adder(X, Y, 0, Cin, 1), labeling([X,Y,Cin]).

     Cin = 0,
     X = 1,
     Y = 1 ? ;

     Cin = 1,
     X = 0,
     Y = 1 ? ;

     Cin = 1,
     X = 1,
     Y = 0 ? ;

illustrates the use of cardinality constraints and models a one-bit
adder circuit.  The first query illustrates how representing the input
signals by symbolic constants forces the output signals to be displayed
as functions of the inputs and not vice versa.  The second query
computes the simplified functions obtained by setting carry-in to 0.
The third query asks for particular input values satisfying sum and
carry-out being 0 and 1, respectively.


File: sicstus.info,  Node: CLPB Example 4,  Prev: CLPB Example 3,  Up: CLPB Examples

10.36.3.4 Example 4
...................

The predicate `fault/3' below describes a 1-bit adder consisting of
five gates, with at most one faulty gate.  If one of the variables `Fi'
is equal to 1, the corresponding gate is faulty, and its output signal
is undefined (i.e. the constraint representing the gate is relaxed).

   Assuming that we have found some incorrect output from a circuit, we
are interesting in finding the faulty gate.  Two instances of incorrect
output are listed in `fault_ex/2':

     fault([F1,F2,F3,F4,F5], [X,Y,Cin], [Sum,Cout]) :-
             sat(
                         card([0-1],[F1,F2,F3,F4,F5]) *
                         (F1 + (U1 =:= X * Cin)) *
                         (F2 + (U2 =:= Y * U3)) *
                         (F3 + (Cout =:= U1 + U2)) *
                         (F4 + (U3 =:= X # Cin)) *
                         (F5 + (Sum =:= Y # U3))
                     ).

     fault_ex(1, Faults) :- fault(Faults, [1,1,0], [1,0]).
     fault_ex(2, Faults) :- fault(Faults, [1,0,1], [0,0]).

   To find the faulty gates, we run the query

     | ?- fault_ex(I,L), labeling(L).

     I = 1,
     L = [0,0,0,1,0] ? ;

     I = 2,
     L = [1,0,0,0,0] ? ;

     I = 2,
     L = [0,0,1,0,0] ? ;

     no

   Thus for input data `[1,1,0]', gate 4 must be faulty.  For input
data `[1,0,1]', either gate 1 or gate 3 must be faulty.

   To get a symbolic representation of the outputs interms of the
input, we run the query

     | ?- fault([0,0,0,0,0], [x,y,cin], [Sum,Cout]).

     sat(Cout=:=x*cin#x*y#y*cin),
     sat(Sum=:=cin#x#y)

which shows that the sum and carry out signals indeed compute the
intended functions if no gate is faulty.


File: sicstus.info,  Node: lib-clpqr,  Next: lib-fdbg,  Prev: lib-clpb,  Up: The Prolog Library

10.37 Constraint Logic Programming over Rationals or Reals--`library([clpq,clpr])'
==================================================================================

* Menu:

* CLPQR Introduction:: Introduction
* CLPQR Interface:: Solver Interface
* CLPQR Linearity::                   Linearity and Nonlinear Residues
* CLPQR Numerical Precision::         Numerical Precision and Rationals
* CLPQR Projection::                  Projection and Redundancy Elimination
* CLPQR Why Disequations::            Why Disequations
* CLPQR Monash Examples::             Monash Examples
* CLPQR MIP::                         A Mixed Integer Linear Optimization Example
* CLPQR Implementation Architecture:: Implementation Architecture


File: sicstus.info,  Node: CLPQR Introduction,  Next: CLPQR Interface,  Up: lib-clpqr

10.37.1 Introduction
--------------------

The clp(Q,R) system described in this chapter is an instance of the
general Constraint Logic Programming scheme introduced by [Jaffar &
Michaylov 87].  It is a third-party product, bundled with SICStus
Prolog as two library packages.  It is not supported by SICS in any way.

   The implementation is at least as complete as other existing clp(R)
implementations: It solves linear equations over rational or real valued
variables, covers the lazy treatment of nonlinear equations, features a
decision algorithm for linear inequalities that detects implied
equations, removes redundancies, performs projections (quantifier
elimination), allows for linear dis-equations, and provides for linear
optimization.

* Menu:

* CLPQR Referencing:: Referencing this Software
* CLPQR Acknowledging:: Acknowledgments


File: sicstus.info,  Node: CLPQR Referencing,  Next: CLPQR Acknowledging,  Up: CLPQR Introduction

10.37.1.1 Referencing this Software
...................................

When referring to this implementation of clp(Q,R) in publications, you
should use the following reference:

     Holzbaur C., `OFAI clp(q,r) Manual', Edition 1.3.3, Austrian
     Research Institute for Artificial Intelligence, Vienna, TR-95-09,
     1995.


File: sicstus.info,  Node: CLPQR Acknowledging,  Prev: CLPQR Referencing,  Up: CLPQR Introduction

10.37.1.2 Acknowledgments
.........................

The development of this software was supported by the Austrian _Fonds
zur Foerderung der Wissenschaftlichen Forschung_ under grant P9426-PHY.
Financial support for the Austrian Research Institute for Artificial
Intelligence is provided by the Austrian Federal Ministry for Science
and Research.

   We include a collection of examples that has been distributed with
the Monash University version of clp(R) [Heintze et al. 87], and its
inclusion into this distribution was kindly permitted by Roland Yap.


File: sicstus.info,  Node: CLPQR Interface,  Next: CLPQR Linearity,  Prev: CLPQR Introduction,  Up: lib-clpqr

10.37.2 Solver Interface
------------------------

Until rational numbers become first class citizens in SICStus Prolog,
rational arithmetics has to be emulated. Because of the emulation it is
too expensive to support arithmetics with automatic coercion between
all sorts of numbers, like you find it in CommonLisp, for example.

   You must choose whether you want to operate in the field of Q
(Rationals) or R (Reals):

     | ?- use_module(library(clpq)).

     or

     | ?- use_module(library(clpr)).

   You can also load both modules, but the exported predicates listed
below will name clash (*note ref-mod-ncl::).  You can avoid the
interactive resolution dialog if the importation is skipped, e.g. via:
`use_module(library(clpq),[]),use_module(library(clpr),[])'.

* Menu:

* CLPQR Notational Conventions:: Notational Conventions
* CLPQR Solver Predicates:: Solver Predicates
* CLPQR Unification:: Unification
* CLPQR Feedback:: Feedback and Bindings


File: sicstus.info,  Node: CLPQR Notational Conventions,  Next: CLPQR Solver Predicates,  Up: CLPQR Interface

10.37.2.1 Notational Conventions
................................

Throughout this chapter, the prompts `clp(q) ?-' and `clp(r) ?-' are
used to differentiate between clp(Q) and clp(R) in exemplary
interactions.

   In general there are many ways to express the same linear
relationship. This degree of freedom is manifest in the fact that the
printed manual and an actual interaction with the current version of
clp(Q,R) may show syntactically different answer constraints, despite
the fact the same semantic relationship is being expressed.  There are
means to control the presentation; *note CLPQR Variable Ordering::.
The approximative nature of floating point numbers may also produce
numerical differences between the text in this manual and the actual
results of clp(R), for a given edition of the software.


File: sicstus.info,  Node: CLPQR Solver Predicates,  Next: CLPQR Unification,  Prev: CLPQR Notational Conventions,  Up: CLPQR Interface

10.37.2.2 Solver Predicates
...........................

The solver interface for both Q and R consists of the following
predicates, which are exported from `module(linear)'.

`{+CONSTRAINT}'
     CONSTRAINT is a term accepted by the grammar below.  The
     corresponding constraint is added to the current constraint store
     and checked for satisfiability.  Use the module prefix to
     distinguish the solvers if both clp(Q) and clp(R) were loaded
          | ?- clpr:{Ar+Br=10}, Ar=Br, clpq:{Aq+Bq=10}, Aq=Bq.

          Aq = 5,
          Ar = 5.0,
          Bq = 5,
          Br = 5.0

     Although clp(Q) and clp(R) are independent modules, you are asking
     for trouble if you (accidently) share variables between them:
          | ?- clpr:{A+B=10}, clpq:{A=B}.
          ! Type error in argument 2 of clpq:=/2
          ! a rational number expected, but 5.0 found
          ! goal:  _118=5.0

     This is because both solvers eventually compute values for the
     variables and Reals are incompatible with Rationals.

     Here is the constraint grammar:
     CONSTRAINT::= C                
             | C `,' C            { conjunction }

     C       ::= EXPR `=:=' EXPR  { equation }
             | EXPR  `='  EXPR    { equation }
             | EXPR  `<'  EXPR    { strict inequation }
             | EXPR  `>'  EXPR    { strict inequation }
             | EXPR `=<'  EXPR    { nonstrict inequation }
             | EXPR `>='  EXPR    { nonstrict inequation }
             | EXPR `=\=' EXPR    { disequation }

     EXPR    ::= "variable"       { Prolog variable }
             | "number"           { floating point or
                                  integer }
             | `+' EXPR           { unary plus }
             | `-' EXPR           { unary minus }
             | EXPR `+' EXPR      { addition }
             | EXPR `-' EXPR      { subtraction }
             | EXPR `*' EXPR      { multiplication }
             | EXPR `/' EXPR      { division }
             | `abs(EXPR)'        { absolute value }
             | `sin(EXPR)'        { trigonometric sine }
             | `cos(EXPR)'        { trigonometric cosine }
             | `tan(EXPR)'        { trigonometric tangent }
             | `pow(EXPR,EXPR)'   { raise to the power }
             | `exp(EXPR,EXPR)'   { raise to the power }
             | `min(EXPR,EXPR)'   { minimum of the two
                                  arguments }
             | `max(EXPR,EXPR)'   { maximum of the two
                                  arguments }
             | `#(CONST)'         { symbolic numerical
                                  constants }

     Conjunctive constraints `{C,C}' have been made part of the syntax
     to control the granularity of constraint submission, which will be
     exploited by future versions of this software.  Symbolic numerical
     constants are provided for compatibility only; *note CLPQR Monash
     Examples::.

`entailed(+CONSTRAINT)'
     Succeeds iff the linear CONSTRAINT is entailed by the current
     constraint store. This predicate does not change the state of the
     constraint store.
          clp(q) ?- {A =< 4}, entailed(A=\=5).

          {A=<4}

          clp(q) ?- {A =< 4}, entailed(A=\=3).

          no

`inf(+EXPR, -INF)'
`inf(+EXPR, -INF, +VECTOR, -VERTEX)'
     Computes the infimum of the linear expression EXPR and unifies it
     with INF. If given, VECTOR should be a list of variables relevant
     to EXPR, and VERTEX will be unified a list of the same length as
     VECTOR containing the values for VECTOR, such that the infimum is
     produced when assigned.  Failure indicates unboundedness.

`sup(+EXPR, -SUP)'
`sup(+EXPR, -SUP, +VECTOR, -VERTEX)'
     Computes the supremum of the linear expression EXPR and unifies it
     with SUP. If given, VECTOR should be a list of variables relevant
     to EXPR, and VERTEX will be unified a list of the same length as
     VECTOR containing the values for VECTOR, such that the supremum is
     produced when assigned.  Failure indicates unboundedness.

          clp(q) ?- { 2*X+Y =< 16, X+2*Y =< 11,
                      X+3*Y =< 15, Z = 30*X+50*Y
                    }, sup(Z, Sup, [X,Y], Vertex).

          Sup = 310,
          Vertex = [7,2],
          {Z=30*X+50*Y},
          {X+1/2*Y=<8},
          {X+3*Y=<15},
          {X+2*Y=<11}

`minimize(+EXPR)'
     Computes the infimum of the linear expression EXPR and equates it
     with the expression, i.e. as if defined as:
          minimize(Expr) :- inf(Expr, Expr).

`maximize(+EXPR)'
     Computes the supremum of the linear expression EXPR and equates it
     with the expression.
          clp(q) ?- { 2*X+Y =< 16, X+2*Y =< 11,
                      X+3*Y =< 15, Z = 30*X+50*Y
                    }, maximize(Z).

          X = 7,
          Y = 2,
          Z = 310

`bb_inf(+INTS, +EXPR, -INF)'
     Computes the infimum of the linear expression EXPR under the
     additional constraint that all of variables in the list INTS
     assume integral values at the infimum. This allows for the
     solution of mixed integer linear optimization problems; *note
     CLPQR MIP::.
          clp(q) ?- {X >= Y+Z, Y > 1, Z > 1}, bb_inf([Y,Z],X,Inf).

          Inf = 4,
          {Y>1},
          {Z>1},
          {X-Y-Z>=0}

`bb_inf(+INTS, +EXPR, -INF, -VERTEX, +EPS)'
     Computes the infimum of the linear expression EXPR under the
     additional constraint that all of variables in the list INTS
     assume integral values at the infimum. EPS is a positive number
     between 0 and 0.5 that specifies how close a number X must be to
     the next integer to be considered integral: `abs(round(X)-X) <
     EPS'.  The predicate `bb_inf/3' uses `EPS = 0.001'.  With clp(Q),
     `EPS = 0' makes sense.  VERTEX is a list of the same length as
     INTS and contains the (integral) values for INTS, such that the
     infimum is produced when assigned. Note that this will only
     generate one particular solution, which is different from the
     situation with `minimize/1', where the general solution is
     exhibited.

     `bb_inf/5' works properly for non-strict inequalities only!
     Disequations (`=\=') and higher dimensional strict inequalities
     (`>',`<') are beyond its scope. Strict bounds on the decision
     variables are honored however:

          clp(q) ?- {X >= Y+Z, Y > 1, Z > 1}, bb_inf([Y,Z],X,Inf,Vertex,0).

          Inf = 4,
          Vertex = [2,2],
          {Y>1},
          {Z>1},
          {X-Y-Z>=0}

     The limitation(s) can be addressed by:

        * transforming the original problem statement so that only
          non-strict inequalities remain; for example, `{X + Y > 0}'
          becomes `{X + Y >= 1}' for integral `X' and `Y';

        * contemplating the use of clp(FD).

`ordering(+SPEC)'
     Provides a means to control one aspect of the presentation of the
     answer constraints; *note CLPQR Variable Ordering::.

`dump(+TARGET, -NEWVARS, -CODEDANSWER)'
     Reflects the constraints on the target variables into a term,
     where TARGET and NEWVARS are lists of variables of equal length
     and CODEDANSWER is the term representation of the projection of
     constraints onto the target variables where the target variables
     are replaced by the corresponding variables from NEWVARS (*note
     CLPQR Turning Answers into Terms::).
          clp(q) ?- {A+B =< 10, A>=4},
                    dump([A,B],Vs,Cs),
                    dump([B],Bp,Cb).

          Cb = [_A=<6],
          Bp = [_A],
          Cs = [_B>=4,_C+_B=<10],
          Vs = [_C,_B],
          {A>=4},
          {A+B=<10}
     The current version of `dump/3' is incomplete with respect to
     nonlinear constraints. It only reports nonlinear constraints that
     are connected to the target variables. The following example has no
     solution. From the top-level's report we have a chance to deduce
     this fact, but `dump/3' currently has no means to collect global
     constraints ...
          q(X) :-
                  {X>=10},
                  {sin(Z)>3}.

          clp(r) ?- q(X), dump([X],V,C).

          C = [_A>=10.0],
          V = [_A],
          clpr:{3.0-sin(_B)<0.0},
          {X>=10.0}

`projecting_assert/1(:CLAUSE)'
     If you use the database, the clauses you assert might have
     constraints associated with their variables.  Use this predicate
     instead of `assert/1' in order to ensure that only the relevant
     and projected constraints get stored in the database.  It will
     transform the clause into one with plain variables and extra body
     goals that set up the relevant constraint when called.



File: sicstus.info,  Node: CLPQR Unification,  Next: CLPQR Feedback,  Prev: CLPQR Solver Predicates,  Up: CLPQR Interface

10.37.2.3 Unification
.....................

Equality constraints are added to the store implicitly each time
variables that have been mentioned in explicit constraints are
bound--either to another such variable or to a number.
     clp(r) ?- {2*A+3*B=C/2}, C=10.0, A=B.

     A = 1.0,
     B = 1.0,
     C = 10.0
Is equivalent modulo rounding errors to
     clp(r) ?- {2*A+3*B=C/2, C=10, A=B}.

     A = 1.0,
     B = 0.9999999999999999,
     C = 10.0
The shortcut bypassing the use of `{}/1' is allowed and makes sense
because the interpretation of this equality in Prolog and clp(R)
coincides.  In general, equations involving interpreted functors, `+/2'
in this case, must be fed to the solver explicitly:
     clp(r) ?- X=3.0+1.0, X=4.0.

     no

   Moreover, variables known by clp(R) may be bound directly to floats
only.  Likewise, variables known by clp(Q) may be bound directly to
rational numbers only; *note CLPQR Fragments and Bits::. Failing to do
so is rewarded with an exception:
     clp(q) ?- {2*A+3*B=C/2}, C=10.0, A=B.
     ! Type error in argument 2 of = /2
     ! 'a rational number' expected, but 10.0 found
     ! goal:  _254=10.0

   This is because `10.0' is not a rational constant. To make clp(Q)
happy you have to say:
     clp(q) ?- {2*A+3*B=C/2}, C=rat(10,1), A=B.

     A = 1,
     B = 1,
     C = 10

   If you use `{}/1', you don't have to worry about such details.


File: sicstus.info,  Node: CLPQR Feedback,  Prev: CLPQR Unification,  Up: CLPQR Interface

10.37.2.4 Feedback and Bindings
...............................

What was covered so far was how the user populates the constraint
store. The other direction of the information flow consists of the
success and failure of the above predicates and the binding of
variables to numerical values. Example:
     clp(r) ?- {A-B+C=10, C=5+5}.

     {A = B},
     C = 10.0
The linear constraints imply `C=10.0' and the solver consequently
exports this binding to the Prolog world. The fact that `A=B' is
deduced and represented by the solver but not exported as a binding.
More about answer presentation in *note CLPQR Projection::.


File: sicstus.info,  Node: CLPQR Linearity,  Next: CLPQR Numerical Precision,  Prev: CLPQR Interface,  Up: lib-clpqr

10.37.3 Linearity and Nonlinear Residues
----------------------------------------

The clp(Q,R) system is restricted to deal with linear constraints
because the decision algorithms for general nonlinear constraints are
prohibitively expensive to run. If you need this functionality badly,
you should look into symbolic algebra packages.  Although the clp(Q,R)
system cannot solve nonlinear constraints, it will collect them
faithfully in the hope that through the addition of further (linear)
constraints they might get simple enough to solve eventually.  If an
answer contains nonlinear constraints, you have to be aware of the fact
that success is qualified modulo the existence of a solution to the
system of residual (nonlinear) constraints:
     clp(r) ?- {sin(X) = cos(X)}.

     clpr:{sin(X)-cos(X)=0.0}
There are indeed infinitely many solutions to this constraint (`X =
0.785398 + n*Pi'), but clp(Q,R) has no direct means to find and
represent them.

   The systems goes through some lengths to recognize linear expressions
as such. The method is based on a normal form for multivariate
polynomials. In addition, some simple isolation axioms, that can be
used in equality constraints, have been added.  The current major
limitation of the method is that full polynomial division has not been
implemented.  Examples:

This is an example where the isolation axioms are sufficient to
determine the value of X.
     clp(r) ?- {sin(cos(X)) = 1/2}.

     X = 1.0197267436954502

If we change the equation into an inequation, clp(Q,R) gives up:
     clp(r) ?- {sin(cos(X)) < 1/2}.

     clpr:{sin(cos(X))-0.5<0.0}

The following is easy again:
     clp(r) ?- {sin(X+2+2)/sin(4+X) = Y}.

     Y = 1.0

And so is this:
     clp(r) ?- {(X+Y)*(Y+X)/X = Y*Y/X+99}.

     {Y=49.5-0.5*X}

An ancient symbol manipulation benchmark consists in rising the
expression `X+Y+Z+1' to the 15th power:
     clp(q) ?- {exp(X+Y+Z+1,15)=0}.
     clpq:{Z^15+Z^14*15+Z^13*105+Z^12*455+Z^11*1365+Z^10*3003+...
            ... polynomial continues for a few pages ...
            =0}
Computing its roots is another story.

* Menu:

* CLPQR How Nonlinear Residues Are Made to Disappear:: How Nonlinear Residues Are Made to Disappear
* CLPQR Isolation Axioms:: Isolation Axioms


File: sicstus.info,  Node: CLPQR How Nonlinear Residues Are Made to Disappear,  Next: CLPQR Isolation Axioms,  Up: CLPQR Linearity

10.37.3.1 How Nonlinear Residues Are Made to Disappear
......................................................

Binding variables that appear in nonlinear residues will reduce the
complexity of the nonlinear expressions and eventually results in
linear expressions:
     clp(q) ?- {exp(X+Y+1,2) = 3*X*X+Y*Y}.

     clpq:{Y*2-X^2*2+Y*X*2+X*2+1=0}
Equating X and Y collapses the expression completely and even
determines the values of the two variables:
     clp(q) ?- {exp(X+Y+1,2) = 3*X*X+Y*Y}, X=Y.

     X = -1/4,
     Y = -1/4


File: sicstus.info,  Node: CLPQR Isolation Axioms,  Prev: CLPQR How Nonlinear Residues Are Made to Disappear,  Up: CLPQR Linearity

10.37.3.2 Isolation Axioms
..........................

These axioms are used to rewrite equations such that the variable to be
solved for is moved to the left hand side and the result of the
evaluation of the right hand side can be assigned to the variable. This
allows, for example, to use the exponentiation operator for the
computation of roots and logarithms; see below.
`A = B * C'
     Residuates unless B or C is ground or A and B or C are ground.

`A = B / C'
     Residuates unless C is ground or A and B are ground.

`X = min(Y,Z)'
     Residuates unless Y and Z are ground.

`X = max(Y,Z)'
     Residuates unless Y and Z are ground.

`X = abs(Y)'
     Residuates unless Y is ground.

`X = pow(Y,Z), X = exp(Y,Z)'
     Residuates unless any pair of two of the three variables is
     ground.  Example:

          clp(r) ?- { 12=pow(2,X) }.

          X = 3.5849625007211565

          clp(r) ?- { 12=pow(X,3.585) }.

          X = 1.9999854993443926

          clp(r) ?- { X=pow(2,3.585) }.

          X = 12.000311914286545

`X = sin(Y)'
     Residuates unless X or Y is ground. Example:

          clp(r) ?- { 1/2 = sin(X) }.

          X = 0.5235987755982989

`X = cos(Y)'
     Residuates unless X or Y is ground.

`X = tan(Y)'
     Residuates unless X or Y is ground.


File: sicstus.info,  Node: CLPQR Numerical Precision,  Next: CLPQR Projection,  Prev: CLPQR Linearity,  Up: lib-clpqr

10.37.4 Numerical Precision and Rationals
-----------------------------------------

The fact that you can switch between clp(R) and clp(Q) should solve most
of your numerical problems regarding precision.  Within clp(Q), floating
point constants will be coerced into rational numbers automatically.
Transcendental functions will be approximated with rationals.  The
precision of the approximation is limited by the floating point
precision.  These two provisions allow you to switch between clp(R) and
clp(Q) without having to change your programs.

   What is to be kept in mind however is the fact that it may take
quite big rationals to accommodate the required precision. High levels
of precision are for example required if your linear program is
ill-conditioned, i.e. in a full rank system the determinant of the
coefficient matrix is close to zero.  Another situation that may call
for elevated levels of precision is when a linear optimization problem
requires exceedingly many pivot steps before the optimum is reached.

   If your application approximates irrational numbers, you may be out
of space particularly soon.  The following program implements N steps
of Newton's approximation for the square root function at point 2.
                                     _% library('clpqr/examples/root')_
     root(N, R) :-
       root(N, 1, R).

     root(0, S, R) :- !, S=R.
     root(N, S, R) :-
       N1 is N-1,
       { S1 = S/2 + 1/S },
       root(N1, S1, R).
It is known that this approximation converges quadratically, which
means that the number of correct digits in the decimal expansion
roughly doubles with each iteration. Therefore the numerator and
denominator of the rational approximation have to grow likewise:
     clp(q) ?- [library('clpqr/examples/root')].
     clp(q) ?- root(3,R),print_decimal(R,70).
     1.4142156862 7450980392 1568627450 9803921568 6274509803 9215686274
     5098039215

     R = 577/408

     clp(q) ?- root(4,R),print_decimal(R,70).
     1.4142135623 7468991062 6295578890 1349101165 5962211574 4044584905
     0192000543

     R = 665857/470832

     clp(q) ?- root(5,R),print_decimal(R,70).
     1.4142135623 7309504880 1689623502 5302436149 8192577619 7428498289
     4986231958

     R = 886731088897/627013566048

     clp(q) ?- root(6,R),print_decimal(R,70).
     1.4142135623 7309504880 1688724209 6980785696 7187537723 4001561013
     1331132652

     R = 1572584048032918633353217/1111984844349868137938112

     clp(q) ?- root(7,R),print_decimal(R,70).
     1.4142135623 7309504880 1688724209 6980785696 7187537694 8073176679
     7379907324

     R = 4946041176255201878775086487573351061418968498177 /
         3497379255757941172020851852070562919437964212608
Iterating for 8 steps produces no further change in the first 70
decimal digits of `sqrt(2)'. After 15 steps the approximating rational
number has a numerator and a denominator with 12543 digits each, and
the next step runs out of memory.

   Another irrational number that is easily computed is E.  The
following program implements an alternating series for `1/e', where the
absolute value of last term is an upper bound on the error.
                                     _% library('clpqr/examples/root')_
     e(N, E) :-
       { Err =:= exp(10,-(N+2)), Half =:= 1/2 },
       inv_e_series(Half, Half, 3, Err, Inv_E),
       { E =:= 1/Inv_E }.

     inv_e_series(Term, S0, _, Err, Sum) :-
       { abs(Term) =< Err }, !,
       S0 = Sum.
     inv_e_series(Term, S0, N, Err, Sum) :-
       N1 is N+1,
       { Term1 =:= -Term/N, S1 =:= Term1+S0 },
       inv_e_series(Term1, S1, N1, Err, Sum).
The computation of the rational number E that approximates E up to at
least 1000 digits in its decimal expansion requires the evaluation of
450 terms of the series, i.e. 450 calls of `inv_e_series/5'.
     clp(q) ?- e(1000,E).

     E = 7149056228932760213666809592072842334290744221392610955845565494
         3708750229467761730471738895197792271346693089326102132000338192
         0131874187833985420922688804220167840319199699494193852403223700
         5853832741544191628747052136402176941963825543565900589161585723
         4023097417605004829991929283045372355639145644588174733401360176
         9953973706537274133283614740902771561159913069917833820285608440
         3104966899999651928637634656418969027076699082888742481392304807
         9484725489080844360397606199771786024695620205344042765860581379
         3538290451208322129898069978107971226873160872046731879753034549
         3130492167474809196348846916421782850086985668680640425192038155
         4902863298351349469211627292865440876581064873866786120098602898
         8799130098877372097360065934827751120659213470528793143805903554
         7928682131082164366007016698761961066948371407368962539467994627
         1374858249110795976398595034606994740186040425117101588480000000
         0000000000000000000000000000000000000000000000000000000000000000
         00000000000000000000000000000000000000
         /
         2629990810403002651095959155503002285441272170673105334466808931
         6863103901346024240326549035084528682487048064823380723787110941
         6809235187356318780972302796570251102928552003708556939314795678
         1978390674393498540663747334079841518303636625888963910391440709
         0887345797303470959207883316838346973393937778363411195624313553
         8835644822353659840936818391050630360633734935381528275392050975
         7271468992840907541350345459011192466892177866882264242860412188
         0652112744642450404625763019639086944558899249788084559753723892
         1643188991444945360726899532023542969572584363761073528841147012
         2634218045463494055807073778490814692996517359952229262198396182
         1838930043528583109973872348193806830382584040536394640895148751
         0766256738740729894909630785260101721285704616818889741995949666
         6303289703199393801976334974240815397920213059799071915067856758
         6716458821062645562512745336709063396510021681900076680696945309
         3660590933279867736747926648678738515702777431353845466199680991
         73361873421152165477774911660108200059

   The decimal expansion itself looks like this:
     clp(q) ?- e(1000, E), print_decimal(E, 1000).
     2.
     7182818284 5904523536 0287471352 6624977572 4709369995 9574966967
     6277240766 3035354759 4571382178 5251664274 2746639193 2003059921
     8174135966 2904357290 0334295260 5956307381 3232862794 3490763233
     8298807531 9525101901 1573834187 9307021540 8914993488 4167509244
     7614606680 8226480016 8477411853 7423454424 3710753907 7744992069
     5517027618 3860626133 1384583000 7520449338 2656029760 6737113200
     7093287091 2744374704 7230696977 2093101416 9283681902 5515108657
     4637721112 5238978442 5056953696 7707854499 6996794686 4454905987
     9316368892 3009879312 7736178215 4249992295 7635148220 8269895193
     6680331825 2886939849 6465105820 9392398294 8879332036 2509443117
     3012381970 6841614039 7019837679 3206832823 7646480429 5311802328
     7825098194 5581530175 6717361332 0698112509 9618188159 3041690351
     5988885193 4580727386 6738589422 8792284998 9208680582 5749279610
     4841984443 6346324496 8487560233 6248270419 7862320900 2160990235
     3043699418 4914631409 3431738143 6405462531 5209618369 0888707016
     7683964243 7814059271 4563549061 3031072085 1038375051 0115747704
     1718986106 8739696552 1267154688 9570350354

