This is info/sicstus.info, produced by makeinfo version 4.13 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 8 May 2014.


File: sicstus.info,  Node: CLPQR Projection,  Next: CLPQR Why Disequations,  Prev: CLPQR Numerical Precision,  Up: lib-clpqr

10.37.5 Projection and Redundancy Elimination
---------------------------------------------

Once a derivation succeeds, the Prolog system presents the bindings for
the variables in the query. In a CLP system, the set of answer
constraints is presented in analogy. A complication in the CLP context
are variables and associated constraints that were not mentioned in the
query. A motivating example is the familiar `mortgage' relation:
                                       _% library('clpqr/examples/mg')_
     mg(P,T,I,B,MP):-
       {
          T = 1,
          B + MP = P * (1 + I)
       }.
     mg(P,T,I,B,MP):-
       {
          T > 1,
          P1 = P * (1 + I) - MP,
          T1 = T - 1
       },
       mg(P1, T1, I, B, MP).
A sample query yields:
     clp(r) ?- [library('clpqr/examples/mg')].
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=1.1268250301319698*P-12.682503013196973*Mp}
Without projection of the answer constraints onto the query variables
we would observe the following interaction:
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=12.682503013196973*_A-11.682503013196971*P},
     {Mp= -(_A)+1.01*P},
     {_B=2.01*_A-1.01*P},
     {_C=3.0301*_A-2.0301*P},
     {_D=4.060401000000001*_A-3.0604009999999997*P},
     {_E=5.101005010000001*_A-4.10100501*P},
     {_F=6.152015060100001*_A-5.152015060099999*P},
     {_G=7.213535210701001*_A-6.213535210700999*P},
     {_H=8.285670562808011*_A-7.285670562808009*P},
     {_I=9.368527268436091*_A-8.36852726843609*P},
     {_J=10.462212541120453*_A-9.46221254112045*P},
     {_K=11.566834666531657*_A-10.566834666531655*P}
The variables _A ... _K are not part of the query, they originate from
the mortgage program proper. Although the latter answer is equivalent
to the former in terms of linear algebra, most users would prefer the
former.

* Menu:

* CLPQR Variable Ordering:: Variable Ordering
* CLPQR Turning Answers into Terms:: Turning Answers into Terms
* CLPQR Projecting Inequalities:: Projecting Inequalities


File: sicstus.info,  Node: CLPQR Variable Ordering,  Next: CLPQR Turning Answers into Terms,  Up: CLPQR Projection

10.37.5.1 Variable Ordering
...........................

In general, there are many ways to express the same linear relationship
between variables. clp(Q,R) does not care to distinguish between them,
but the user might. The predicate `ordering(+SPEC)' gives you some
control over the variable ordering. Suppose that instead of B, you want
MP to be the defined variable:
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=1.1268250301319698*P-12.682503013196973*Mp}
This is achieved with:
     clp(r) ?- mg(P,12,0.01,B,Mp), ordering([Mp]).

     {Mp= -0.0788487886783417*B+0.08884878867834171*P}
One could go one step further and require P to appear before (to the
left of) B in an addition:
     clp(r) ?- mg(P,12,0.01,B,Mp), ordering([Mp,P]).

     {Mp=0.08884878867834171*P-0.0788487886783417*B}

   SPEC in `ordering(+SPEC)' is either a list of variables with the
intended ordering, or of the form `A<B'.  The latter form means that A
goes to the left of B.  In fact, `ordering([A,B,C,D])' is shorthand for:
     ordering(A < B), ordering(A < C), ordering(A < D),
     ordering(B < C), ordering(B < D),
     ordering(C < D)

   The ordering specification only affects the final presentation of the
constraints. For all other operations of clp(Q,R), the ordering is
immaterial.  Note that `ordering/1' acts like a constraint: you can put
it anywhere in the computation, and you can submit multiple
specifications.
     clp(r) ?- ordering(B < Mp), mg(P,12,0.01,B,Mp).

     {B= -12.682503013196973*Mp+1.1268250301319698*P}

     clp(r) ?- ordering(B < Mp), mg(P,12,0.01,B,Mp), ordering(P < Mp).

     {P=0.8874492252651537*B+11.255077473484631*Mp}


File: sicstus.info,  Node: CLPQR Turning Answers into Terms,  Next: CLPQR Projecting Inequalities,  Prev: CLPQR Variable Ordering,  Up: CLPQR Projection

10.37.5.2 Turning Answers into Terms
....................................

In meta-programming applications one needs to get a grip on the results
computed by the clp(Q,R) solver. You can use the predicate `dump/3' for
that purpose:
     clp(r) ?- {2*A+B+C=10,C-D=E,A<10}, dump([A,B,C,D,E],[a,b,c,d,e],Constraints).

     Constraints = [e<10.0,a=10.0-c-d-2.0*e,b=c+d],
     {C=10.0-2.0*A-B},
     {E=10.0-2.0*A-B-D},
     {A<10.0}


File: sicstus.info,  Node: CLPQR Projecting Inequalities,  Prev: CLPQR Turning Answers into Terms,  Up: CLPQR Projection

10.37.5.3 Projecting Inequalities
.................................

As soon as linear inequations are involved, projection gets more
demanding complexity wise.  The current clp(Q,R) version uses a
Fourier-Motzkin algorithm for the projection of linear inequalities.
The choice of a suitable algorithm is somewhat dependent on the number
of variables to be eliminated, the total number of variables, and other
factors. It is quite easy to produce problems of moderate size where
the elimination step takes some time.  For example, when the dimension
of the projection is 1, you might be better off computing the supremum
and the infimum of the remaining variable instead of eliminating `n-1'
variables via implicit projection.

   In order to make answers as concise as possible, redundant
constraints are removed by the system as well. In the following set of
inequalities, half of them are redundant.
                                 _% library('clpqr/examples/eliminat')_
     example(2, [X0,X1,X2,X3,X4]) :-
       {
            +87*X0  +52*X1  +27*X2  -54*X3  +56*X4 =<  -93,
            +33*X0  -10*X1  +61*X2  -28*X3  -29*X4 =<   63,
            -68*X0   +8*X1  +35*X2  +68*X3  +35*X4 =<  -85,
            +90*X0  +60*X1  -76*X2  -53*X3  +24*X4 =<  -68,
            -95*X0  -10*X1  +64*X2  +76*X3  -24*X4 =<   33,
            +43*X0  -22*X1  +67*X2  -68*X3  -92*X4 =<  -97,
            +39*X0   +7*X1  +62*X2  +54*X3  -26*X4 =<  -27,
            +48*X0  -13*X1   +7*X2  -61*X3  -59*X4 =<   -2,
            +49*X0  -23*X1  -31*X2  -76*X3  +27*X4 =<    3,
            -50*X0  +58*X1   -1*X2  +57*X3  +20*X4 =<    6,
            -13*X0  -63*X1  +81*X2   -3*X3  +70*X4 =<   64,
            +20*X0  +67*X1  -23*X2  -41*X3  -66*X4 =<   52,
            -81*X0  -44*X1  +19*X2  -22*X3  -73*X4 =<  -17,
            -43*X0   -9*X1  +14*X2  +27*X3  +40*X4 =<   39,
            +16*X0  +83*X1  +89*X2  +25*X3  +55*X4 =<   36,
             +2*X0  +40*X1  +65*X2  +59*X3  -32*X4 =<   13,
            -65*X0  -11*X1  +10*X2  -13*X3  +91*X4 =<   49,
            +93*X0  -73*X1  +91*X2   -1*X3  +23*X4 =<  -87
       }.
Consequently, the answer consists of the system of nine non-redundant
inequalities only:
     clp(q) ?- [library('clpqr/examples/eliminat')].
     clp(q) ?- example(2, [X0,X1,X2,X3,X4]).

     {X0-2/17*X1-35/68*X2-X3-35/68*X4>=5/4},
     {X0-73/93*X1+91/93*X2-1/93*X3+23/93*X4=<-29/31},
     {X0-29/25*X1+1/50*X2-57/50*X3-2/5*X4>=-3/25},
     {X0+7/39*X1+62/39*X2+18/13*X3-2/3*X4=<-9/13},
     {X0+2/19*X1-64/95*X2-4/5*X3+24/95*X4>=-33/95},
     {X0+2/3*X1-38/45*X2-53/90*X3+4/15*X4=<-34/45},
     {X0-23/49*X1-31/49*X2-76/49*X3+27/49*X4=<3/49},
     {X0+44/81*X1-19/81*X2+22/81*X3+73/81*X4>=17/81},
     {X0+9/43*X1-14/43*X2-27/43*X3-40/43*X4>=-39/43}

   The projection (the shadow) of this polyhedral set into the `X0,X1'
space can be computed via the implicit elimination of non-query
variables:
     clp(q) ?- example(2, [X0,X1|_]).

     {X0+2619277/17854273*X1>=-851123/17854273},
     {X0+6429953/16575801*X1=<-12749681/16575801},
     {X0+19130/1213083*X1>=795400/404361},
     {X0-1251619/3956679*X1>=21101146/3956679},
     {X0+601502/4257189*X1>=220850/473021}

   Projection is quite a powerful concept that leads to surprisingly
terse executable specifications of nontrivial problems like the
computation of the convex hull from a set of points in an n-dimensional
space: Given the program
                              _% library('clpqr/examples/elimination')_
     conv_hull(Points, Xs) :-
       lin_comb(Points, Lambdas, Zero, Xs),
       zero(Zero),
       polytope(Lambdas).

     polytope(Xs) :-
       positive_sum(Xs, 1).

       positive_sum([], Z) :- {Z=0}.
       positive_sum([X|Xs], SumX) :-
         { X >= 0, SumX = X+Sum },
         positive_sum(Xs, Sum).

     zero([]).
     zero([Z|Zs]) :- {Z=0}, zero(Zs).

     lin_comb([],        [],     S1, S1).
     lin_comb([Ps|Rest], [K|Ks], S1, S3) :-
       lin_comb_r(Ps, K, S1, S2),
       lin_comb(Rest, Ks, S2, S3).

       lin_comb_r([],     _, [],     []).
       lin_comb_r([P|Ps], K, [S|Ss], [Kps|Ss1]) :-
         { Kps = K*P+S },
         lin_comb_r(Ps, K, Ss, Ss1).
we can post the following query:
     clp(q) ?- conv_hull([ [1,1], [2,0], [3,0], [1,2], [2,2] ], [X,Y]).

     {Y=<2},
     {X+1/2*Y=<3},
     {X>=1},
     {Y>=0},
     {X+Y>=2}
This answer is easily verified graphically:
            |
          2 -    *    *
            |
            |
          1 -    *
            |
            |
          0 -----|----*----*----
                 1    2    3
The convex hull program directly corresponds to the mathematical
definition of the convex hull.  What does the trick in operational terms
is the implicit elimination of the LAMBDAS from the program
formulation. Please note that this program does not limit the number of
points or the dimension of the space they are from. Please note further
that quantifier elimination is a computationally expensive operation
and therefore this program is only useful as a benchmark for the
projector and not so for the intended purpose.


File: sicstus.info,  Node: CLPQR Why Disequations,  Next: CLPQR Monash Examples,  Prev: CLPQR Projection,  Up: lib-clpqr

10.37.6 Why Disequations
------------------------

A beautiful example of disequations at work is due to [Colmerauer 90].
It addresses the task of tiling a rectangle with squares of
all-different, a priori unknown sizes. Here is a translation of the
original `Prolog-III' program to clp(Q,R):
                                  _% library('clpqr/examples/squares')_
     filled_rectangle(A, C) :-
       { A >= 1 },
       distinct_squares(C),
       filled_zone([-1,A,1], _, C, []).

     distinct_squares([]).
     distinct_squares([B|C]) :-
       { B > 0 },
       outof(C, B),
       distinct_squares(C).

     outof([],     _).
     outof([B1|C], B) :-
       { B =\= B1 },       % *** note disequation ***
       outof(C, B).

     filled_zone([V|L], [W|L], C0, C0) :-
       { V=W,V >= 0 }.
     filled_zone([V|L], L3, [B|C], C2) :-
       { V < 0 },
       placed_square(B, L, L1),
       filled_zone(L1, L2, C, C1),
       { Vb=V+B },
       filled_zone([Vb,B|L2], L3, C1, C2).

     placed_square(B, [H,H0,H1|L], L1) :-
       { B > H, H0=0, H2=H+H1 },
       placed_square(B, [H2|L], L1).
     placed_square(B, [B,V|L], [X|L]) :-
       { X=V-B }.
     placed_square(B, [H|L], [X,Y|L]) :-
       { B < H, X= -B, Y=H-B }.
There are no tilings with less than nine squares except the trivial one
where the rectangle equals the only square. There are eight solutions
for nine squares. Six further solutions are rotations of the first two.
     clp(q) ?- [library('clpqr/examples/squares')].
     clp(q) ?- filled_rectangle(A, Squares).

     A = 1,
     Squares = [1] ? ;

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>
Depending on your hardware, the above query may take a few minutes.
Supplying the knowledge about the minimal number of squares beforehand
cuts the computation time by a factor of roughly four:
     clp(q) ?- length(Squares, 9), filled_rectangle(A, Squares).

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>


File: sicstus.info,  Node: CLPQR Monash Examples,  Next: CLPQR MIP,  Prev: CLPQR Why Disequations,  Up: lib-clpqr

10.37.7 Monash Examples
-----------------------

This collection of examples has been distributed with the Monash
University Version of clp(R) [Heintze et al. 87], and its inclusion
into this distribution was kindly permitted by Roland Yap.

   Assuming you are using clp(R):
     clp(r) ?- [library('clpqr/examples/monash/rkf45')].

     clp(r) ?- go.
     Point    0.00000 :    0.75000    0.00000
     Point    0.50000 :    0.61969    0.47793
     Point    1.00000 :    0.29417    0.81233
     Point    1.50000 :   -0.10556    0.95809
     Point    2.00000 :   -0.49076    0.93977
     Point    2.50000 :   -0.81440    0.79929
     Point    3.00000 :   -1.05440    0.57522

     Iteration finished
     ------------------
      439  derivative evaluations


File: sicstus.info,  Node: CLPQR MIP,  Next: CLPQR Implementation Architecture,  Prev: CLPQR Monash Examples,  Up: lib-clpqr

10.37.8 A Mixed Integer Linear Optimization Example
---------------------------------------------------

The predicates `bb_inf/[3,5]' implement a simple Branch and Bound
search algorithm for Mixed Integer Linear (MIP) Optimization examples.
Serious MIP is not trivial. The implementation `library('clpqr/bb.pl')'
is to be understood as a starting point for more ambitious users who
need control over branching, or who want to add cutting planes, for
example.

   Anyway, here is a small problem from miplib, a collection of MIP
models, housed at Rice University:
     NAME:         flugpl
     ROWS:         18
     COLUMNS:      18
     INTEGER:      11
     NONZERO:      46
     BEST SOLN:    1201500 (opt)
     LP SOLN:      1167185.73
     SOURCE:       Harvey M. Wagner
                   John W. Gregory (Cray Research)
                   E. Andrew Boyd (Rice University)
     APPLICATION:  airline model
     COMMENTS:     no integer variables are binary

                                      _% library('clpqr/examples/mip')_
     example(flugpl, Obj, Vs, Ints, []) :-
       Vs = [ Anm1,Anm2,Anm3,Anm4,Anm5,Anm6,
              Stm1,Stm2,Stm3,Stm4,Stm5,Stm6,
              UE1,UE2,UE3,UE4,UE5,UE6],
       Ints = [Stm6, Stm5, Stm4, Stm3, Stm2,
               Anm6, Anm5, Anm4, Anm3, Anm2, Anm1],

       Obj =    2700*Stm1 + 1500*Anm1 + 30*UE1
              + 2700*Stm2 + 1500*Anm2 + 30*UE2
              + 2700*Stm3 + 1500*Anm3 + 30*UE3
              + 2700*Stm4 + 1500*Anm4 + 30*UE4
              + 2700*Stm5 + 1500*Anm5 + 30*UE5
              + 2700*Stm6 + 1500*Anm6 + 30*UE6,

       allpos(Vs),
       {  Stm1 = 60, 0.9*Stm1 +1*Anm1 -1*Stm2 = 0,
          0.9*Stm2 +1*Anm2 -1*Stm3 = 0, 0.9*Stm3 +1*Anm3 -1*Stm4 = 0,
          0.9*Stm4 +1*Anm4 -1*Stm5 = 0, 0.9*Stm5 +1*Anm5 -1*Stm6 = 0,
          150*Stm1 -100*Anm1 +1*UE1 >= 8000,
          150*Stm2 -100*Anm2 +1*UE2 >= 9000,
          150*Stm3 -100*Anm3 +1*UE3 >= 8000,
          150*Stm4 -100*Anm4 +1*UE4 >= 10000,
          150*Stm5 -100*Anm5 +1*UE5 >= 9000,
          150*Stm6 -100*Anm6 +1*UE6 >= 12000,
          -20*Stm1 +1*UE1 =< 0, -20*Stm2 +1*UE2 =< 0, -20*Stm3 +1*UE3 =< 0,
          -20*Stm4 +1*UE4 =< 0, -20*Stm5 +1*UE5 =< 0, -20*Stm6 +1*UE6 =< 0,
          Anm1 =< 18, 57 =< Stm2, Stm2 =< 75, Anm2 =< 18,
          57 =< Stm3, Stm3 =< 75, Anm3 =< 18, 57 =< Stm4,
          Stm4 =< 75, Anm4 =< 18, 57 =< Stm5, Stm5 =< 75,
          Anm5 =< 18, 57 =< Stm6, Stm6 =< 75, Anm6 =< 18
        }.

       allpos([]).
       allpos([X|Xs]) :- {X >= 0}, allpos(Xs).

   We can first check whether the relaxed problem has indeed the quoted
infimum:
     clp(r) ?- example(flugpl, Obj, _, _, _), inf(Obj, Inf).

     Inf = 1167185.7255923203

   Computing the infimum under the additional constraints that `Stm6',
`Stm5', `Stm4', `Stm3', `Stm2', `Anm6', `Anm5', `Anm4', `Anm3', `Anm2',
`Anm1' assume integer values at the infimum is computationally harder,
but the query does not change much:
     clp(r) ?- example(flugpl, Obj, _, Ints, _),
               bb_inf(Ints, Obj, Inf, Vertex, 0.001).

     Inf = 1201500.0000000005,
     Vertex = [75.0,70.0,70.0,60.0,60.0,0.0,12.0,7.0,16.0,6.0,6.0]


File: sicstus.info,  Node: CLPQR Implementation Architecture,  Prev: CLPQR MIP,  Up: lib-clpqr

10.37.9 Implementation Architecture
-----------------------------------

The system consists roughly of the following components:
   * A polynomial normal form expression simplification mechanism.

   * A solver for linear equations [Holzbaur 92a].

   * A simplex algorithm to decide linear inequalities [Holzbaur 94].

* Menu:

* CLPQR Fragments and Bits:: Fragments and Bits
* CLPQR Bugs:: Bugs


File: sicstus.info,  Node: CLPQR Fragments and Bits,  Next: CLPQR Bugs,  Up: CLPQR Implementation Architecture

10.37.9.1 Fragments and Bits
............................

_Rationals._ The internal data structure for rational numbers is
`rat(NUM,DEN)'.  DEN is always positive, i.e.  the sign of the rational
number is the sign of NUM. Further, NUM and DEN are relative prime.
Note that integer N looks like `rat(N,1)' in this representation.  You
can control printing of terms with `user:portray/1'.  

   _Partial Evaluation, Compilation._ Once one has a working solver, it
is obvious and attractive to run the constraints in a clause definition
at read time or compile time and proceed with the answer constraints in
place of the original constraints. This gets you constant folding and
in fact the full algebraic power of the solver applied to the avoidance
of computations at runtime.  The mechanism to realize this idea is to
use `dump/3' for the expansion of `{}/1', via the goal and term
expansion hook predicates.

   _Asserting with Constraints._ If you use the database, the clauses
you assert might have constraints associated with their variables. You
should use `projecting_assert/1' instead of `assert/1' in order to
ensure that only the relevant and projected constraints get stored in
the database.

     | ?- {A+B=<33}, projecting_assert(test(A,B)).

     {A+B=<33}

     | ?- listing(test).
     test(A, B) :-
             {A+B=<rat(33,1)}

     | ?- test(A,B).

     {A+B=<33}


File: sicstus.info,  Node: CLPQR Bugs,  Prev: CLPQR Fragments and Bits,  Up: CLPQR Implementation Architecture

10.37.9.2 Bugs
..............

   * The fuzzy comparison of floats is the source for all sorts of
     weirdness. If a result in R surprises you, try to run the program
     in Q before you send me a bug report.

   * The projector for floundered nonlinear relations keeps too many
     variables. Its output is rather unreadable.

   * Disequations are not projected properly.

   * This list is probably incomplete.


File: sicstus.info,  Node: lib-fdbg,  Next: lib-zinc,  Prev: lib-clpqr,  Up: The Prolog Library

10.38 Finite Domain Constraint Debugger--`library(fdbg)'
========================================================

* Menu:

* FDBG Introduction:: Introduction
* FDBG Concepts:: Concepts
* FDBG Basics:: Basics
* FDBG Advanced Usage:: Advanced Usage


File: sicstus.info,  Node: FDBG Introduction,  Next: FDBG Concepts,  Up: lib-fdbg

10.38.1 Introduction
--------------------

FDBG is a CLP(FD) debugger for SICStus Prolog.  Its main purpose is to
enable the CLP programmer to trace the changes of domains of variables.
See [Hanak et al. 04].

   FDBG defines the following prefix operator:

     :- op(400, fy, #).

   The presence of FDBG affects the translation and execution, but not
the semantics, of subsequently loaded arithmetic constraints.


File: sicstus.info,  Node: FDBG Concepts,  Next: FDBG Basics,  Prev: FDBG Introduction,  Up: lib-fdbg

10.38.2 Concepts
----------------

In this section, several concepts and terms are defined.  These terms
will later be heavily used in the documentation; therefore, it is
important that you understand them well.

* Menu:

* FDBG Events:: Events
* FDBG Labeling Levels:: Labeling Levels
* FDBG Visualizers:: Visualizers
* FDBG Names of Terms:: Names of Terms
* FDBG Selectors:: Selectors
* FDBG Name Auto-Generation:: Name Auto-Generation
* FDBG Legend:: Legend
* FDBG The fdbg_output Stream:: The `fdbg_output' Stream


File: sicstus.info,  Node: FDBG Events,  Next: FDBG Labeling Levels,  Up: FDBG Concepts

10.38.2.1 Events
................

An FDBG event can (currently) belong to one of the two following major
classes:

"constraint event"
     A global constraint is woken.

"labeling event"
     Three events belong to this class, namely:

        * the labeling of an FD variable is started

        * an FD variable gets constrained

        * the labeling of an FD variable fails, i.e. all elements of its
          domain have been tried and caused failure

   These events are intercepted by the FDBG core.  When any of them
occurs, the appropriate visualizer (*note FDBG Visualizers::) gets
called with a representation of the event (a Prolog term) as extra
arguments.

   Note that it is _not possible_ to debug indexicals with FDBG. What's
more, any domain narrowings done by indexicals happen unnoticed, making
FDBG output harder to follow.  On the other hand, arithmetical
constraints (like `X #> 0') are translated to global constraints
instead of indexicals after consulting `library(fdbg)', and therefore
don't lead to any misunderstandings.  For this latter reason it is
advisable to load `library(fdbg)' _before_ any user programs.


File: sicstus.info,  Node: FDBG Labeling Levels,  Next: FDBG Visualizers,  Prev: FDBG Events,  Up: FDBG Concepts

10.38.2.2 Labeling Levels
.........................

In this subsection we give three definitions regarding the labeling
procedure.

"labeling session"
     This term denotes the whole labeling procedure that starts with
     the call of `labeling/2' or an equivalent predicate and finishes by
     exiting this predicate.  Normally, there is at most one labeling
     session per run.

"labeling attempt"
     One choicepoint of a labeling session.  Exactly one variable is
     associated with a labeling attempt, although this is not
     necessarily true vice versa.  For example in `enum' mode labeling,
     a single labeling attempt tries every possible value, but in
     `step' mode labeling, several binary choicepoints are created.

"labeling step"
     The event of somehow constraining the domain of a variable.  This
     usually means either setting the variable to a specific value or
     limiting it with a lower or an upper bound.

   As you can see there is a hierarchical relation among these
definitions: a labeling session consists of several labeling attempts,
which, in turn, might consist of several labeling steps.

   A "labeling event", on the other hand, can either be a labeling
step, or the start of a labeling attempt, or the failure of the same.
*Note FDBG Events::.


File: sicstus.info,  Node: FDBG Visualizers,  Next: FDBG Names of Terms,  Prev: FDBG Labeling Levels,  Up: FDBG Concepts

10.38.2.3 Visualizers
.....................

A visualizer is a Prolog predicate reacting to FDBG events (*note FDBG
Events::).  It is called directly by the FDBG core when any FDBG event
occurs.  It is called "visualizer", because usually it should present
the events to the user, but in general it can do any kind of
processing, like checking invariants, etc.

   For all major event classes, a different visualizer type is used.
The set of visualizers you would like to use for a session is specified
in the option list of `fdbg_on/1' (*note FDBG Options::), when FDBG is
switched on.

   A specific visualizer can have several arguments, some are supplied
by the FDBG core, the rest (if any) should be specified when FDBG is
switched on.  Note that the obligatory arguments will be appended to
the _end_ of the user defined argument list.

   The set of built-in visualizers installed by default (*note FDBG
Options::) is the following:

   * for global constraint awakenings: `fdbg_show'

   * for labeling events: `fdbg_label_show'

   For details on built-in visualizers, *note FDBG Built-In
Visualizers::.


File: sicstus.info,  Node: FDBG Names of Terms,  Next: FDBG Selectors,  Prev: FDBG Visualizers,  Up: FDBG Concepts

10.38.2.4 Names of Terms
........................

FDBG provides a service to assign names to Prolog terms for later
reference.  A name is an atom and it is usually associated with a
compound term containing constraint variables, or with a single
variable.  In the former case, each variable appearing in the compound
term is also assigned a name automatically by FDBG.  This auto-assigned
name is derived from the name of the term; *note FDBG Name
Auto-Generation::.

   Perhaps the most useful utilization of names is "annotation",
another service of FDBG.  Here, each variable appearing in a Prolog
term is replaced with a compound term describing it (i.e. containing
its name, the variable itself, and some data regarding its domain).
During annotation, unnamed constraint variables are also given a unique
"anonymous" name automatically, these names begin with a `fdvar'
prefix.  *Note FDBG Writing Visualizers::.

   The names will be used by the built-in visualizers when referring to
constraint variables, and they can also be used to retrieve the terms
assigned to them in user defined visualizers.  *Note FDBG Visualizers::.


File: sicstus.info,  Node: FDBG Selectors,  Next: FDBG Name Auto-Generation,  Prev: FDBG Names of Terms,  Up: FDBG Concepts

10.38.2.5 Selectors
...................

A "selector" is a Prolog term denoting a (path to a) subterm of a given
term T.  Let SUBTERM(T,S) denote the subterm of T wrt. a selector S,
and let N denote an integer.  A selector then takes one of the following
forms:

S            SUBTERM(T,S)
`[]'         T
`[...,N]'    Nth argument of the compound term SUBTERM(T,`[...]')
`[...,#N]'   Nth element of the list SUBTERM(T,`[...]')


File: sicstus.info,  Node: FDBG Name Auto-Generation,  Next: FDBG Legend,  Prev: FDBG Selectors,  Up: FDBG Concepts

10.38.2.6 Name Auto-Generation
..............................

There are two cases when a name is automatically generated.

  1. When a name is assigned to a compound term by the user, each
     variable appearing in it is assigned a so called "derived" name,
     which is created by appending a variant of the selector of the
     variable to the original name.  For example, the call:
          fdbg_assign_name(bar(A, [B, C], foobar(D, E)), foo)
     will create the following name/term entries:

     NAME        TERM/VARIABLE                    SELECTOR
     `foo'       `bar(A, [B, C], foobar(D, E))'   `[]'
     `foo_1'     `A'                              `[1]'
     `foo_2_1'   `B'                              `[2,#1]'
     `foo_2_2'   `C'                              `[2,#2]'
     `foo_3_1'   `D'                              `[3,1]'
     `foo_3_2'   `E'                              `[3,2]'

     *Note FDBG Naming Terms::.

  2. If, during the annotation of a term (*note FDBG Annotation::) an
     unnamed constraint variable is found, it is assigned a unique
     "anonymous" name.  This name consists of the prefix `fdvar', an
     underscore character, and an integer.  The integer is automatically
     incremented when necessary.



File: sicstus.info,  Node: FDBG Legend,  Next: FDBG The fdbg_output Stream,  Prev: FDBG Name Auto-Generation,  Up: FDBG Concepts

10.38.2.7 Legend
................

The "legend" is a list of variables and their domains, usually
appearing after a description of the current constraint.  This is
necessary because the usual visual representation of a constraint
contains only the _names_ of the variables in it (*note FDBG
Annotation::), and doesn't show anything about their domain.  The legend
links these names to the corresponding domains.  The legend also shows
the changes of the domains made by the constraint.  Finally, the legend
may contain some conclusions regarding the behavior of the constraint,
like failure or side-effects.

   The format of the legend is somewhat customizable by defining a hook
function; *note FDBG Customizing Output::.  The default format of the
legend is the following:

     list_2 = 0..3
     list_3 = 0..3
     list_4 = 0..3
     fdvar_2 = 0..3 -> 1..3

   Here, we see four variables, with initial domains 0..3, but the
domain of the (previously unnamed) variable `fdvar_2' is narrowed by
the constraint (not shown here) to 1..3.

   A legend is automatically printed by the built-in visualizer
`fdbg_show', but it can be easily printed from user defined visualizers
too.


File: sicstus.info,  Node: FDBG The fdbg_output Stream,  Prev: FDBG Legend,  Up: FDBG Concepts

10.38.2.8 The `fdbg_output' Stream
..................................

The `fdbg_output' is a stream alias created when FDBG is switched on
and removed when it is switched off.  All built-in visualizers write to
this stream, and the user defined visualizers should do the same.


File: sicstus.info,  Node: FDBG Basics,  Next: FDBG Advanced Usage,  Prev: FDBG Concepts,  Up: lib-fdbg

10.38.3 Basics
--------------

Here, we describe the set of FDBG services and commands necessary to do
a simple debugging session.  No major modification of your CLP(FD)
program is necessary to use FDBG this way.  Debugging more complicated
programs, on the other hand, might also require user written extensions
to FDBG, since the wallpaper trace produced by the built-in visualizer
`fdbg_show' could be too detailed and therefore hard to analyze.  *Note
FDBG Advanced Usage::.

* Menu:

* FDBG Options:: FDBG Options
* FDBG Naming Terms:: Naming Terms
* FDBG Built-In Visualizers:: Built-In Visualizers
* FDBG Debugger Commands:: New Debugger Commands
* FDBG Annotation:: Annotating Programs
* FDBG An Example Session:: An Example Session


File: sicstus.info,  Node: FDBG Options,  Next: FDBG Naming Terms,  Up: FDBG Basics

10.38.3.1 FDBG Options
......................

FDBG is switched on and off with the predicates:

`fdbg_on'
`fdbg_on(:OPTIONS)'
     Turns on FDBG by putting advice-points on several predicates of
     the CLP(FD) module.  OPTIONS is a single option or a list of
     options; *note FDBG Options::.  The empty list is the default
     value.

     `fdbg_on/[0,1]' can be called safely several times consecutively;
     only the first call will have an effect.

`fdbg_off'
     Turns the debugger off by removing the previously installed
     advice-points.

   `fdbg_on/1' accepts the following options:

`file(FILENAME, MODE)'
     Tells FDBG to attach the stream alias `fdbg_output' to the file
     called FILENAME opened in mode MODE.  MODE can either be `write'
     or `append'.  The file specified is opened on a call to
     `fdbg_on/1' and is closed on a call to `fdbg_off/0'.

`socket(HOST, PORT)'
     Tells FDBG to attach the stream alias `fdbg_output' to the socket
     connected to HOST on port PORT.  The specified socket is created
     on a call to `fdbg_on/1' and is closed on a call to `fdbg_off/0'.

`stream(STREAM)'
     Tells FDBG to attach the stream alias `fdbg_output' to the stream
     STREAM.  The specified stream remains open after calling
     `fdbg_off/0'.

     If none of the above three options is used, the stream alias
     `fdbg_output' is attached to the current output stream.
`constraint_hook(GOAL)'
     Tells FDBG to extend GOAL with two (further) arguments and call it
     on the exit port of the global constraint dispatcher
     (`dispatch_global_fast/4').

`no_constraint_hook'
     Tells FDBG not to use any constraint hook.

     If none of the above two options is used, the default is
     `constraint_hook(fdbg:fdbg_show)'.
`labeling_hook(GOAL)'
     Tells FDBG to extend GOAL with three (further) arguments and call
     it on any of the three labeling events.

`no_labeling_hook'
     Tells FDBG not to use any labeling hook.

     If none of the above two options is used, the default is
     `labeling_hook(fdbg:fdbg_label_show)'.


   For both `constraint_hook' and `labeling_hook', GOAL should be a
visualizer, either built-in (*note FDBG Built-In Visualizers::) or user
defined.  More of these two options may appear in the option list, in
which case they will be called in their order of occurrence.

   *Note FDBG Writing Visualizers:: for more details on these two
options.


File: sicstus.info,  Node: FDBG Naming Terms,  Next: FDBG Built-In Visualizers,  Prev: FDBG Options,  Up: FDBG Basics

10.38.3.2 Naming Terms
......................

Naming is a procedure of associating names with terms and variables;
*note FDBG Names of Terms::.  Three predicates are provided to assign
and retrieve names, these are the following:

`fdbg_assign_name(+TERM, ?NAME)'
     Assigns the atom NAME to TERM, and a derived name to each variable
     appearing in TERM.  If NAME is a variable, use a default
     (generated) name, and return it in NAME.  *Note FDBG Name
     Auto-Generation::.

`fdbg_current_name(?TERM, ?NAME)'
     Retrieves TERM associated with NAME, or enumerates all term-name
     pairs.

`fdbg_get_name(+TERM, -NAME)'
     Returns the name associated to TERM in NAME, if it exists.
     Otherwise, silently fails.


File: sicstus.info,  Node: FDBG Built-In Visualizers,  Next: FDBG Debugger Commands,  Prev: FDBG Naming Terms,  Up: FDBG Basics

10.38.3.3 Built-In Visualizers
..............................

The default visualizers are generic predicates to display FDBG events
(*note FDBG Events::) in a well readable form.  These visualizers
naturally don't exploit any problem specific information--to have more
"fancy" output, you have to write your own visualizers; *note FDBG
Writing Visualizers::.  To use these visualizers, pass them in the
appropriate argument to `fdbg_on/1'; *note FDBG Options::, or call them
directly from user defined visualizers.

`fdbg_show(+CONSTRAINT, +ACTIONS)'
     This visualizer produces a trace output of all woken global
     constraints, in which a line showing the constraint is followed by
     a legend (*note FDBG Legend::) of all the variables appearing in
     it, and finally an empty line to separate events from each other.
     The usual output will look like this:

          <fdvar_1>#=0
              fdvar_1 = {0}
              Constraint exited.

     Here, we can see an arithmetical constraint being woken.  It
     narrows `fdvar_1' to a domain consisting of the singleton value 0,
     and since this is the narrowest domain possible, the constraint
     doesn't have anything more to do: it exits.

     Note that when you pass `fdbg_show/2' as an option, you should omit
     the two arguments, like in

          fdbg_on([..., constraint_hook(fdbg_show), ...]).

`fdbg_label_show(+EVENT, +LABELID, +VARIABLE)'
     This visualizer produces a wallpaper trace output of all labeling
     events.  It is best used together with `fdbg_show/2'.  Each
     labeling event produces a single line of output, some of them are
     followed by an empty line, some others are always followed by
     another labeling action and therefore the empty line is omitted.
     Here is a sample output of `fdbg_label_show/3':

          Labeling [9, <list_1>]: starting in range 0..3.
          Labeling [9, <list_1>]: step: <list_1> = 0

     What we see here is the following:

        * The prefix `Labeling' identifies the event.

        * The number in the brackets (9) is a unique identification
          number belonging to a labeling attempt.  Only _one_ labeling
          step with this number can be in effect at a time.  This
          number in fact is the invocation number of the predicate
          doing the labeling for that variable.

        * The name in the brackets (`<list_1>') identifies the variable
          currently being labeled.  Note that several identification
          numbers might belong to the same variable, depending on the
          mode of labeling.

        * The text after the colon specifies the actual labeling event.
          This string can be:

             - "starting in range RANGE." meaning the starting of a
               labeling attempt in range RANGE

             - "MODE: NARROWING." meaning a labeling step in mode MODE.
               NARROWING is the actual narrowing done in the labeling
               step.  MODE is one of the following:

              `step'
                    meaning `step' mode labeling

              `indomain_up'
                    meaning `enum' mode labeling or a direct call to
                    `indomain/1'

              `indomain_down'
                    meaning `enum,down' mode labeling

              `bisect'
                    meaning `bisect' mode labeling

              `dual'
                    when the domain contains exactly two values and the
                    labeling attempt is nothing more than a selection
                    between them

             - "failed." meaning the labeling attempt failed.

     Note that when you pass `fdbg_label_show/3' as an option, you
     should omit the three arguments, like in

          fdbg_on([..., labeling_hook(fdbg_label_show), ...]).



File: sicstus.info,  Node: FDBG Debugger Commands,  Next: FDBG Annotation,  Prev: FDBG Built-In Visualizers,  Up: FDBG Basics

10.38.3.4 New Debugger Commands
...............................

The Prolog debugger is extended by FDBG.  The `&' debugger is modified,
and two new commands are added:

`&'
`& N'
     This debugger command is extended so that the annotated form of
     domain variables is also printed when listing the variables with
     blocked goals.

`A'
`A SELECTOR'
     Annotates and prints the current goal and a legend of the
     variables appearing in it.  If a selector is specified, the
     subterm specified by it is assumed to be an action list, and is
     taken into account when displaying the legend.  For example:

          23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                      [exit,_1001 in_set[[3|3]]]) ? A [2,4]

          clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                     [exit,<board_2> in_set[[3|3]]])
              board_2 = 1..4 -> {3}
              Constraint exited.

`W NAME=SELECTOR'
     Assigns the atom NAME to the variable specified by the SELECTOR.
     For example:

          7      15 Call: bar(4, [_101,_102,_103]) ? W foo=[2,#2]

     This would assign the name `foo' to `_102', being the second
     element of the second argument of the current goal.


File: sicstus.info,  Node: FDBG Annotation,  Next: FDBG An Example Session,  Prev: FDBG Debugger Commands,  Up: FDBG Basics

10.38.3.5 Annotating Programs
.............................

In order to use FDBG efficiently, you have to make some changes to your
CLP(FD) program.  Fortunately the calls you have to add are not
numerous, and when FDBG is turned off they don't decrease efficiency
significantly or modify the behavior of your program.  On the other
hand, they are necessary to make FDBG output easier to understand.

   Assign names to the more important and more frequently occurring
variables by inserting `fdbg_assign_name/2' calls at the beginning of
your program.  It is advisable to assign names to variables in larger
batches (i.e. as lists or compound terms) with a single call.

   Use pre-defined labeling predicates if possible.  If you define your
own labeling predicates and you want to use them even in the debugging
session, you should follow these guidelines:

  1. Add a call to `clpfd:fdbg_start_labeling(+VAR)' at the beginning
     of the predicate doing a labeling attempt, and pass the currently
     labeled variable as an argument to the call.  

  2. Call `clpfd:fdbg_labeling_step(+VAR, +STEP)' before each labeling
     step.  STEP should be a compound term describing the labeling
     step, this will be

       a. printed "as is" by the built-in visualizer as the mode of the
          labeling step (*note FDBG Built-In Visualizers::)--you can use
          `portray/1' to determine how it should be printed;

       b. passed as `step(STEP)' to the user defined labeling
          visualizers in their EVENT argument; *note FDBG Writing
          Visualizers::.

   This way FDBG can inform you about the labeling events created by
your labeling predicates exactly like it would do in the case of
internal labeling.  If you ignore these rules FDBG won't be able to
distinguish labeling events from other FDBG events any more.


File: sicstus.info,  Node: FDBG An Example Session,  Prev: FDBG Annotation,  Up: FDBG Basics

10.38.3.6 An Example Session
............................

The problem of magic sequences is a well known constraint problem. A
magic sequence is a list, where the I-th item of the list is equal to
the number of occurrences of the number I in the list, starting from
zero.  For example, the following is a magic sequence:

     [1,2,1,0]

   The CLP(FD) solution can be found in
`library('clpfd/examples/magicseq')', which provides a couple of
different solutions, one of which uses the `global_cardinality/2'
constraint.  We'll use this solution to demonstrate a simple session
with FDBG.

   First, the debugger is imported into the user module:

     | ?- use_module(fdbg).
     % loading /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po...
     % module fdbg imported into user

     [...]

     % loaded /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po in module fdbg, 220 msec 453936 bytes

   Then, the magic sequence solver is loaded:

     | ?- consult(library('clpfd/examples/magicseq')).
     % consulting /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl...
     %  module magic imported into user
     %  module clpfd imported into magic
     % consulted /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl in module magic, 30 msec 9440 bytes

   Now we turn on the debugger, telling it to save the trace in
`fdbg.log'.

     | ?- fdbg_on([file('fdbg.log',write)]).
     % The clp(fd) debugger is switched on

   To produce a well readable trace output, a name has to be assigned to
the list representing the magic sequence.  To avoid any modifications
to the source code, the name is assigned by a separate call before
calling the magic sequence finder predicate:

     | ?- length(L,4), fdbg_assign_name(L,list), magic_gcc(4,L,[enum]).
     L = [1,2,1,0] ? ;
     L = [2,0,2,0] ? ;

     no

     *Please note*: the call to `length/2' is necessary; otherwise, `L'
     would be a single variable instead of a list of four variables
     when the name is assigned.

   Finally we turn the debugger off:

     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   The output of the sample run can be found in `fdbg.log'.  Here, we
show selected parts of the trace.  In each block, the woken constraint
appears on the first line, followed by the corresponding legend.

   In the first displayed block, `scalar_product/4' removes infeasible
domain values from `list_3' and `list_4', thus adjusting their upper
bounds.  The legend shows the domains before and after pruning.  Note
also that the constraint is rewritten to a more readable form:

     <list_2>+2*<list_3>+3*<list_4>#=4
         list_2 = 0..3
         list_3 = 0..3 -> 0..2
         list_4 = 0..3 -> 0..1

   The following block shows the initial labeling events, trying the
value 0 for `list_1':

     Labeling [22, <list_1>]: starting in range 0..3.
     Labeling [22, <list_1>]: indomain_up: <list_1> = 0

   This immediately leads to a dead end:

     global_cardinality([0,<list_2>,<list_3>,<list_4>],
                        [0-0,1-<list_2>,2-<list_3>,3-<list_4>])
         list_2 = 0..3
         list_3 = 0..2
         list_4 = 0..1
         Constraint failed.

   We backtrack on `list_1', trying instead the value 1.  This leads to
the following propagation steps:

     Labeling [22, <list_1>]: indomain_up: <list_1> = 1

     global_cardinality([1,<list_2>,<list_3>,<list_4>],
                        [0-1,1-<list_2>,2-<list_3>,3-<list_4>])
         list_2 = 0..3 -> 1..3
         list_3 = 0..2
         list_4 = 0..1

     <list_2>+2*<list_3>+3*<list_4>#=4
         list_2 = 1..3
         list_3 = 0..2 -> 0..1
         list_4 = 0..1

   However, we don't yet have a solution, so we try the first feasible
value for `list_2', which is 2.  This is in fact enough to solve the
goal.  In the last two propagation steps, the constraint exits, which
means that it holds no matter what value any remaining variable takes
(in this example, there are none):

     Labeling [29, <list_2>]: indomain_up: <list_2> = 2

     global_cardinality([1,2,<list_3>,<list_4>],[0-1,1-2,2-<list_3>,3-<list_4>])
         list_3 = 0..1 -> {1}
         list_4 = 0..1 -> {0}

     global_cardinality([1,2,1,0],[0-1,1-2,2-1,3-0])
         Constraint exited.

     0#=0
         Constraint exited.


File: sicstus.info,  Node: FDBG Advanced Usage,  Prev: FDBG Basics,  Up: lib-fdbg

10.38.4 Advanced Usage
----------------------

Sometimes the output of the built-in visualizer is inadequate.  There
might be cases when only minor changes are necessary to produce a more
readable output; in other cases, the trace output should be completely
reorganized.  FDBG provides two ways of changing the appearance of the
output by defining hook predicates.  In this section, these predicates
will be described in detail.

* Menu:

* FDBG Customizing Output:: Customizing Output
* FDBG Writing Visualizers:: Writing Visualizers
* FDBG Writing Legend Printers:: Writing Legend Printers
* FDBG Showing Selected Constraints (simple version):: Showing Selected Constraints (simple version)
* FDBG Showing Selected Constraints (advanced version):: Showing Selected Constraints (advanced version)
* FDBG Debugging Global Constraints:: Debugging Global Constraints
* FDBG Code of the Built-In Visualizers:: Code of the Built-In Visualizers


File: sicstus.info,  Node: FDBG Customizing Output,  Next: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.38.4.1 Customizing Output
............................

The printing of variable names is customized by defining the following
hook predicate.

`fdbg:fdvar_portray(NAME, VAR, FDSET)    "hook"'
     This hook predicate is called whenever an annotated constraint
     variable (*note FDBG Annotation::) is printed.  NAME is the
     assigned name of the variable VAR, whose domain _will be_ FDSET as
     soon as the narrowings of the current constraint take effect.  The
     _current_ domain is not stored in this compoun, but it can be
     easily determined with a call to `fd_set/2'.  (Although these two
     sets may be the same if the constraint didn't narrow it.)

     If `fdbg:fdvar_portray/3' is undefined or fails the default
     representation is printed, which is NAME between angle brackets.

   The printing of legend lines is customized by defining the following
hook predicate.

`fdbg:legend_portray(NAME, VAR, FDSET)    "hook"'
     This hook is called for each line of the legend by the built-in
     legend printer.  The arguments are the same as in the case of
     `fdbg:fdvar_portray/3'.  Note that a prefix of four spaces and a
     closing newline character is always printed by FDBG.

     If `fdbg:fdvar_portray/3' is undefined or fails the default
     representation is printed, which is

          NAME = RANGENOW [ -> RANGEAFTER ]

     The arrow and RANGEAFTER are only printed if the constraint
     narrowed the domain of VAR.

   The following example will print a list of all possible values
instead of the range for each variable in the legend:

     :- multifile fdbg:legend_portray/3.
     fdbg:legend_portray(Name, Var, Set) :-
             fd_set(Var, Set0),
             fdset_to_list(Set0, L0),
             fdset_to_list(Set, L),
             (   L0 == L
             ->  format('~p = ~p', [Name, L])
             ;   format('~p = ~p -> ~p', [Name, L0, L])
             ).


File: sicstus.info,  Node: FDBG Writing Visualizers,  Next: FDBG Writing Legend Printers,  Prev: FDBG Customizing Output,  Up: FDBG Advanced Usage

10.38.4.2 Writing Visualizers
.............................

For more complicated problems you might want to change the output more
drastically.  In this case you have to write and use your own
visualizers, which could naturally be problem specific, not like
`fdbg_show/2' and `fdbg_label_show/3'.  As we described earlier,
currently there are two types of visualizers:

"constraint visualizer"
          MYGLOBALVISUALIZER([+ARG1, +ARG2, ...] +CONSTRAINT, +ACTIONS)

     This visualizer is passed in the `constraint_hook' option.  It must
     have at least two arguments, these are the following:

    CONSTRAINT
          the constraint that was handled by the dispatcher

    ACTIONS
          the action list returned by the dispatcher

     Other arguments can be used for any purpose, for example to select
     the verbosity level of the visualizer.  This way you don't have to
     modify your code if you would like to see less or more information.
     Note however, that the two obligatory arguments must appear at the
     _end_ of the argument list.

     When passing as an option to `fdbg_on/1', only the optional
     arguments have to be specified; the two mandatory arguments should
     be omitted.  *Note FDBG Debugging Global Constraints:: for an
     example.

"labeling visualizer"
          MYLABELINGVISUALIZER([+ARG1, +ARG2, ...] +EVENT, +ID, +VAR)

     This visualizer is passed in the `labeling_hook' option.  It must
     have at least three arguments, these are the following:

    EVENT
          a term representing the labeling event, can be one of the
          following:

         start
               labeling has just started for a variable

         fail
               labeling has just failed for a variable

         step(STEP)
               variable has been constrained in a labeling step
               described by the compound term STEP, which is either
               created by `library(clpfd)''s labeling predicates (in
               this case, simply print it--FDBG will know how to handle
               it) or by you; *note FDBG Annotation::.

    ID
          identifies the labeling session, i.e. binds step and fail
          events to the corresponding start event

    VAR
          the variable being the subject of labeling


   The failure of a visualizer is ignored and multiple choices are cut
by FDBG.  Exceptions, on the other hand, are not caught.

   FDBG provides several predicates to ease the work of the visualizer
writers.  These predicates are the following:

`fdbg_annotate(+TERM0, -TERM, -VARIABLES)'

`fdbg_annotate(+TERM0, +ACTIONS, -TERM, -VARIABLES)'
     Replaces each constraint variable in TERM0 by a compound term
     describing it and returns the result in TERM.  Also, collects
     these compound terms into the list VARIABLES.  These compound
     terms have the following form:

          fdvar(NAME, VAR, FDSET)

    NAME
          is the name of the variable (auto-generated, if necessary;
          *note FDBG Name Auto-Generation::)

    VAR
          is the variable itself

    FDSET
          is the domain of the variable _after_ narrowing with ACTIONS,
          if specified; otherwise, it is the _current_ domain of the
          variable

`fdbg_legend(+VARS)'
     Prints a legend of VARS, which is a list of `fdvar/3' compound
     terms returned by `fdbg_annotate/[3,4]'.

`fdbg_legend(+VARS, +ACTIONS)'
     Prints a legend of VARS followed by some conclusions regarding the
     constraint (exiting, failing, etc.) based on ACTIONS.


File: sicstus.info,  Node: FDBG Writing Legend Printers,  Next: FDBG Showing Selected Constraints (simple version),  Prev: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.38.4.3 Writing Legend Printers
.................................

When you write your own visualizers, you might not be satisfied with the
default format of the legend.  Therefore you might want to write your
own legend printer, replacing `fdbg_legend/[1,2]'.  This should be
quite straightforward based on the variable list returned by
`fdbg_annotate/[3,4]'.  Processing the rest of the action list and
writing conclusions about the constraint behavior is not that easy
though.  To help your work, FDBG provides a predicate to transform the
raw action list to a more readable form:

`fdbg_transform_actions(+ACTIONS, +VARS, -TRANSFORMEDACTIONS)'
     This will do the following transformations to ACTIONS, returning
     the result in TRANSFORMEDACTIONS:

       1. remove all actions concerning variables in VARS (the list
          returned by `fdbg_annotate/[3,4]');

       2. remove multiple `exit' and/or `fail' commands;

       3. remove all ground actions, translating those that will cause
          failure into `fail(ACTION)';

       4. substitute all other narrowings with an `fdvar/3' compound
          term per variable.

     The transformed action list may contain the following terms:

    `exit'
          the constraint exits

    `fail'
          the constraint fails due to a `fail' action

    `fail(ACTION)'
          the constraint fails because of ACTION

    `call(GOAL)'
          ACTIONS originally contained this action.  FDBG can't do
          anything with that but to inform the user about it.

    `fdvar(NAME, VAR, FDSET)'
          ACTIONS also narrowed some variables that didn't appear in
          the VARS list, this is one of them.  The meaning of the
          arguments is the usual, described in *note FDBG Writing
          Visualizers::.  This should normally not happen.

    `ANYTHINGELSE'
          ACTIONS contained unrecognized actions too, these are copied
          unmodified.  This shouldn't happen!



File: sicstus.info,  Node: FDBG Showing Selected Constraints (simple version),  Next: FDBG Showing Selected Constraints (advanced version),  Prev: FDBG Writing Legend Printers,  Up: FDBG Advanced Usage

10.38.4.4 Showing Selected Constraints (simple version)
.......................................................

Sometimes the programmer is not interested in every global constraint,
only some selected ones.  Such a filter can be easily implemented with a
user-defined visualizer.  Suppose that you are interested in the
constraints `all_different/1' and `all_distinct/1' only:

     %% spec_filter(+Constraint, +Actions):  Call fdbg_show for all constraints
     %%   for which intresting_event(Constraint) succeeds.
     %%
     %%   Use this filter by giving the constraint_hook(spec_filter) option to
     %%   fdbg_on.
     spec_filter(Constraint, Actions) :-
             interesting_event(Constraint),
             fdbg_show(Constraint, Actions).

     interesting_event(all_different(_)).
     interesting_event(all_distinct(_)).

   Here is a session using the visualizer.  Note that the initialization
part (`domain/3' events), are filtered out, leaving only the
`all_different/1' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(spec_filter)).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     all_different([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_different([7,6,2,5,8,4,1,3,9])
         Constraint exited.

     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   Note that the failure of `spec_filter/2' doesn't cause any unwanted
output.


File: sicstus.info,  Node: FDBG Showing Selected Constraints (advanced version),  Next: FDBG Debugging Global Constraints,  Prev: FDBG Showing Selected Constraints (simple version),  Up: FDBG Advanced Usage

10.38.4.5 Showing Selected Constraints (advanced version)
.........................................................

Suppose that you want to give the constraints that you are interested in
as an argument to the visualizer, instead of defining them in a table.
The following visualizer implements this.

     :- use_module(library(lists), [append/3]).

     %% filter_events(+CtrSpecs, +Constraint, +Actions):  This predicate will
     %%   only show constraint events if they match an element in the list CtrSpecs,
     %%   or if CtrSpecs is wrapped in -/1, all the non-matching events will
     %%   be shown.
     %%   CtrSpecs can contain the following types of elements:
     %%     ctr_name             - matches all constraints of the given name
     %%     ctr_name/arity       - matches constraints with the given name and arity
     %%     ctr_name(...args...) - matches constraints unifyable with the given term
     %%
     %%   For the selected events fdbg_show(Constraint, Actions) is called.
     %%   This visualizer can be specified when turning fdbg on, e.g.:
     %%     fdbg_on([constraint_hook(filter_events([count/4]))]), or
     %%     fdbg_on([constraint_hook(filter_events(-[in_set]))]).
     filter_events(CtrSpecs, Constraint, Actions) :-
             filter_events(CtrSpecs, fdbg_show, Constraint, Actions).

     %% filter_events(+CtrSpecs, +Visualizer, +Constraint, +Actions):  Same as
     %%   the above predicate, but the extra argument Visualizer specifies the
     %%   predicate to be called for the selected events (in the same form as
     %%   in the constraint_hook option, i.e. without the last two arguments). E.g.
     %%     fdbg_on([constraint_hook(filter_events([count/4],my_show))]).
     filter_events(-CtrSpecs, Visualizer, Constraint, Actions) :- !,
             \+ show_constraint(CtrSpecs, Constraint),
             add_args(Visualizer, [Constraint, Actions], Goal),
             call(Goal).
     filter_events(CtrSpecs, Visualizer, Constraint, Actions) :-
             show_constraint(CtrSpecs, Constraint),
             add_args(Visualizer, [Constraint, Actions], Goal),
             call(Goal).

     show_constraint([C|_], Constraint) :-
             matches(C, Constraint), !.
     show_constraint([_|Cs], Constraint) :-
             show_constraint(Cs, Constraint).

     matches(Name/Arity, Constraint) :- !,
             functor(Constraint, Name, Arity).
     matches(Name, Constraint) :-
             atom(Name), !,
             functor(Constraint, Name, _).
     matches(C, Constraint) :-
             C = Constraint.

     add_args(Goal0, NewArgs, Goal) :-
             Goal0 =.. [F|Args0],
             append(Args0, NewArgs, Args),
             Goal =.. [F|Args].

   Here is a session using the visualizer, filtering out everything but
`all_different/1' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(filter_events([all_different/1]))).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     all_different([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_different([7,6,2,5,8,4,1,3,9])
         Constraint exited.

     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the next session, all constraints named `all_different' are
ignored, irrespective of arity.  Also, we explicitly specified the
visualizer to be called for the events that are kept (here, we have
written the default, `fdbg_show', so the actual behavior is not
changed).

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(filter_events(-[all_different],fdbg_show))).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     domain([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
             4,<fdvar_4>,<fdvar_5>,<fdvar_6>],1,9)
         fdvar_1 = inf..sup -> 1..9
         fdvar_2 = inf..sup -> 1..9
         fdvar_3 = inf..sup -> 1..9
         fdvar_4 = inf..sup -> 1..9
         fdvar_5 = inf..sup -> 1..9
         fdvar_6 = inf..sup -> 1..9
         Constraint exited.
         Constraint exited.

     [...]

     domain([2,<fdvar_46>,5,<fdvar_47>,<fdvar_48>,
            <fdvar_49>,<fdvar_50>,<fdvar_51>,9],1,9)
         fdvar_46 = inf..sup -> 1..9
         fdvar_47 = inf..sup -> 1..9
         fdvar_48 = inf..sup -> 1..9
         fdvar_49 = inf..sup -> 1..9
         fdvar_50 = inf..sup -> 1..9
         fdvar_51 = inf..sup -> 1..9
         Constraint exited.

     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the last session, we specify a list of constraints to ignore,
using a pattern to select the appropriate constraints.  Since all
constraints in the example match one of the items in the given list, no
events are printed.

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(filter_events(-[domain(_,1,9),all_different(_)]))).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: FDBG Debugging Global Constraints,  Next: FDBG Code of the Built-In Visualizers,  Prev: FDBG Showing Selected Constraints (advanced version),  Up: FDBG Advanced Usage

10.38.4.6 Debugging Global Constraints
......................................

Missing pruning and excessive pruning are the two major classes of bugs
in the implementation of global constraints.  Since CLP(FD) is an
incomplete constraint solver, missing pruning is mainly an efficiency
concern (but _ground_ instances for which the constraint does not hold
should be rejected).  Excessive pruning, however, means that some valid
combinations of values are pruned away, leading to missing solutions.
The following exported predicate helps spotting excessive pruning in
user-defined global constraints:

`fdbg_guard(:GOAL, +CONSTRAINT, +ACTIONS)'
     A constraint visualizer that does no output, but notifies the user
     by calling GOAL if a solution is lost through domain narrowings.
     Naturally you have to inform `fdbg_guard/3' about the solution in
     question--stating which variables should have which values.  To
     use `fdbg_guard/3', first:

       1. Set it up as a visualizer by calling:

               fdbg_on([..., constraint_hook(fdbg_guard(GOAL)), ...])

          As usual, the two other arguments will be supplied by the FDBG
          core when calling `fdbg_guard/3'.

       2. At the beginning of your program, form a pair of lists
          `XS-VS' where XS is the list of variables and VS is the list
          of values in question.  This pair should then be assigned the
          name `fdbg_guard' using:
               | ?- fdbg_assign_name(XS-VS, fdbg_guard).

     When these steps have been taken, `fdbg_guard/3' will watch the
     domain changes of XS done by each global constraint C.  Whenever
     VS is in the domains of XS at entry to C, but not at exit from C,
     GOAL is called with three more arguments:

    VARIABLE LIST
          a list of `VARIABLE-VALUE' terms for which VALUE was removed
          from the domain of VARIABLE

    CONSTRAINT
          the constraint that was handled by the dispatcher

    ACTIONS
          the action list returned by the dispatcher

   We will now show an example using `fdbg_guard/3'.  First, we will
need a few extra lines of code:

     %% print_and_trace(MissValues, Constraint, Actions):  To be used as a Goal for
     %%   fdbg_guard to call when the given solution was removed from the domains
     %%   of the variables.
     %%
     %%   MissValues is a list of Var-Value pairs, where Value is the value that
     %%   should appear in the domain of Var, but has been removed.  Constraint is
     %%   the current constraint and Actions is the list of actions returned by it.
     %%
     %%   This predicate prints MissValues in a textual form, then shows the current
     %%   (culprit) constraint (as done by fdbg_show/2), then turns on the Prolog
     %%   tracer.
     print_and_trace(MissValues, Constraint, Actions) :-
             print(fdbg_output, '\nFDBG Guard:\n'),
             display_missing_values(MissValues),
             print(fdbg_output, '\nCulprit constraint:\n\n'),
             fdbg_show(Constraint, Actions),
             trace.

     display_missing_values([]).
     display_missing_values([Var-Val|MissVals]) :-
             fdbg_annotate(Var,AVar,_),
             format(fdbg_output, '  ~d was removed from ~p~n', [Val,AVar]),
             display_missing_values(MissVals).

   Suppose that we have written the following N Queens program, using a
global constraint `no_threat/3' with a bug in it:

     :- use_module(library(clpfd)).
     :- use_module(library(fdbg)).

     queens(L, N) :-
             length(L, N),
             domain(L, 1, N),
             constrain_all(L),
             labeling([ff,enum], L).

     constrain_all([]).
     constrain_all([X|Xs]):-
             constrain_between(X,Xs,1),
             constrain_all(Xs).

     constrain_between(_X,[],_N).
     constrain_between(X,[Y|Ys],N) :-
             no_threat(X,Y,N),
             N1 is N+1,
             constrain_between(X,Ys,N1).

     no_threat(X,Y,I) :-
             fd_global(no_threat(X,Y,I), 0, [val(X),val(Y)]).

     :- multifile clpfd:dispatch_global/4.
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(X), !,
             remove_threat(Y, X, I, NewYSet),
             Actions = [exit, Y in_set NewYSet].
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(Y), !,
             remove_threat(X, Y, I, NewXSet),
             Actions = [exit, X in_set NewXSet].
     clpfd:dispatch_global(no_threat(_,_,_), S, S, []).

     remove_threat(X, V, I, Set) :-
             Vp is V+I+1,   % Bug introduced here
     %       Vp is V+I,     % Good code
             Vn is V-I,
             fd_set(X, Set0),
             list_to_fdset([Vn, V, Vp], VSet),
             fdset_subtract(Set0, VSet, Set).

     missing(L, Tuple) :-
          length(Tuple, N),
          length(L, N),
          fdbg_assign_name(L-Tuple, fdbg_guard),
          fdbg_assign_name(L, board),
          fdbg_on(constraint_hook(fdbg_guard(print_and_trace))),
          queens(L, N).

   We will now use `print_and_trace/3' as an argument to the
`fdbg_guard' visualizer to handle the case when a solution has been
removed by a constraint.  The bug shown above causes three invalid
solutions to be found instead of the two correct solutions.  FDBG is
told to watch for the disappearance of the first correct solution,
`[2,4,1,3]'.  First, we get two incorrect solutions before FDBG wakes
up, because in these cases the given good solution was made impossible
by a labeling event.  The second branch of labeling does not by itself
remove the solution, but at some point on that branch the bad
constraint does remove it, so `fdbg_guard/3' calls the given predicate.
This prints the cause of waking (the value that should not have been
removed by the constraint), prints the constraint itself, then switches
the Prolog debugger to trace mode.  At this point, we use the `A'
debugger command (*note FDBG Debugger Commands::) to print the
annotated form of the goal containing the culprit constraint.

   For clarity, the labeling events were not turned off in the session
below.

   This information can be used to track down why the buggy
`no_threat/3' performed the invalid pruning.

     | ?- missing(L, [2,4,1,3]).
     % The clp(fd) debugger is switched on
     Labeling [8, <board_1>]: starting in range 1..4.
     Labeling [8, <board_1>]: indomain_up: <board_1> = 1

     Labeling [13, <board_2>]: starting in range {2}\/{4}.
     Labeling [13, <board_2>]: dual: <board_2> = 2

     L = [1,2,3,4] ? ;
     Labeling [13, <board_2>]: dual: <board_2> = 4

     L = [1,4,2,3] ? ;
     Labeling [13, <board_2>]: failed.

     Labeling [8, <board_1>]: indomain_up: <board_1> = 2


     FDBG Guard:
       4 was removed from <board_2>

     Culprit constraint:

     no_threat(2,<board_2>,1)
         board_2 = 1..4 -> {3}
         Constraint exited.

     % The debugger will first creep -- showing everything (trace)
     23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                 [exit,_1001 in_set[[3|3]]]) ? A

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                [exit,<board_2> in_set[[3|3]]])
         board_2 = 1..4

     23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                 [exit,_1001 in_set[[3|3]]]) ? A [2,4]

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                [exit,<board_2> in_set[[3|3]]])
         board_2 = 1..4 -> {3}
         Constraint exited.

     23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                 [exit,_1001 in_set[[3|3]]]) ? a
     % Execution aborted
     % advice,source_info
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: FDBG Code of the Built-In Visualizers,  Prev: FDBG Debugging Global Constraints,  Up: FDBG Advanced Usage

10.38.4.7 Code of the Built-In Visualizers
..........................................

Now that you know everything about writing visualizers, it might be
worth having a look at the code of the built-in visualizers,
`fdbg_show/2' and `fdbg_label_show/3'.

     fdbg_show(Constraint, Actions) :-
             fdbg_annotate(Constraint, Actions, AnnotC, CVars),
             print(fdbg_output, AnnotC),
             nl(fdbg_output),
             fdbg_legend(CVars, Actions),
             nl(fdbg_output).

     fdbg_label_show(start, I, Var) :-
             fdbg_annotate(Var, AVar, _),
             (   AVar = fdvar(Name, _, Set)
             ->  fdset_to_range(Set, Range),
                 format(fdbg_output,
                        'Labeling [~p, <~p>]: starting in range ~p.~n',
                        [I,Name,Range])
             ;   format(fdbg_output,
                        'Labeling [~p, <>]: starting.~n',
                        [I])
             ).
     fdbg_label_show(fail, I, Var) :-
             (   var(Var)
             ->  lookup_or_set_name(Var, Name),
                 format(fdbg_output,
                        'Labeling [~p, <~p>]: failed.~n~n',
                        [I,Name])
             ;   format(fdbg_output,
                        'Labeling [~p, <>]: failed.~n~n',
                        [I])
             ).
     fdbg_label_show(step(Step), I, Var) :-
             (   var(Var)
             ->  lookup_or_set_name(Var, Name),
                 format(fdbg_output,
                        'Labeling [~p, <~p>]: ~p~n~n',
                        [I,Name,Step])
             ;   format(fdbg_output,
                        'Labeling [~p, <>]: ~p~n~n',
                        [I,Step])
             ).

     lookup_or_set_name(Term, Name) :-
             fdbg_get_name(Term, Name), !.
     lookup_or_set_name(Term, Name) :-
             fdbg_assign_name(Term, Name).

   As you can see, they are quite simple, thanks to the extensive set of
support predicates also available to the user.


File: sicstus.info,  Node: lib-zinc,  Next: lib-pillow,  Prev: lib-fdbg,  Up: The Prolog Library

10.39 Zinc Interface--`library(zinc)'
=====================================

* Menu:

* Zinc Notes:: Notes
* FlatZinc:: FlatZinc
* MiniZinc:: MiniZinc
* Zinc Errors:: Zinc Errors

   The G12 project develops three languages for specifying combinatorial
(optimization) problems: a high-level modeling language called "Zinc",
a medium-level modeling language called "MiniZinc", and a low-level
solver input language called "FlatZinc". See the G12 project at
`http://www.g12.csse.unimelb.edu.au' for more information about Zinc,
MiniZinc, and FlatZinc.

   This library provides an interpreter for FlatZinc programs (*note
FlatZinc::), and, via an external MiniZinc-to-FlatZinc translator, an
interpreter also for MiniZinc programs (*note MiniZinc::). The library
interface was inspired by the MiniZinc and FlatZinc libraries of "The
ECLiPSe Constraint Programming System". It is compatible with Version
1.6 of the G12 MiniZinc distribution.


File: sicstus.info,  Node: Zinc Notes,  Next: FlatZinc,  Up: lib-zinc

10.39.1 Notes
-------------

_Domain variables_
     Only variables with finite integer domains are supported. This
     includes boolean variables which are considered finite integer
     domain variables with the domain `0..1'. Domain variables declared
     to be of type `var int' are initially given the finite integer
     domain `inf..sup', and are given maximally wide bounded domains
     before any search is performed on them, as well as before certain
     constraints that demand bounded domains are posted on them.

_Ground set values_
     Although set "variables" are not supported, ground set "values"
     are. For example, the MiniZinc global constraint `sum_pred/4'
     takes as second argument an array of such ground set values.

_Solve annotations_
        * The solve annotations currently recognized are `bool_search',
          `int_search', `labelling_ff', and `seq_search'.

        * The FlatZinc specification describes several _exploration
          strategies_. Currently, the only recognized exploration
          strategies are `complete' and `fail'.

        * Variables not included in any solve or `var_is_introduced'
          annotation are labeled with a default first-fail domain
          splitting heuristic.  This corresponds to `labeling/2' of
          `library(clpfd)' with the option list `[ff,bisect]'.

        * The choice method `indomain_random' as described in the
          FlatZinc specification uses `random_member/2' of
          `library(random)'. The random generator of SICStus is
          initialized using the same seed on each start up, meaning
          that the same sequence will be tried for `indomain_random' on
          each start up. This behavior can be changed by setting a
          different random seed using `setrand/1' of `library(random)'.


_Constraint annotations_
     Constraint annotations of the form `domain', `bounds', and `value'
     are recognized in relevant FlatZinc-to-`library(clpfd)' constraint
     translations. Any other constraint annotation is ignored.

_Variable annotations_
     The following variable annotations are recognized.  Any other
     variable annotation is ignored:

    `output_var   "since release 4.2"'
          the variable may be written on the current output stream.

    `output_array   "since release 4.2"'
          the variable array may be written on the current output
          stream.

    `var_is_introduced'
          the variable will not be considered in any default labeling
          (such as when the search annotations don't include all
          variables)



File: sicstus.info,  Node: FlatZinc,  Next: MiniZinc,  Prev: Zinc Notes,  Up: lib-zinc

10.39.2 FlatZinc
----------------

* Menu:

* FlatZinc Exported Predicates:: Exported Predicates

   The FlatZinc interpreter described here is based on _"Specification
of FlatZinc, version 1.6"_, available at
`http://www.g12.csse.unimelb.edu.au/minizinc/specifications.html'.

   A FlatZinc program can be run directly using `fzn_run_file/[1,2]'
and `fzn_run_stream/[1,2]', as well as with `spfz', a simple
command-line tool interface to `fzn_run_file/[1,2]' (for details, see
*note too-spfz::).  For example, a program for solving the 4 Queens
problem, located in `library('zinc/examples/queen4.fzn')', can be run
by the following goal:

     | ?- fzn_run_file(library('zinc/examples/queen4')).

or command:

     % spfz $SP_LIBRARY_DIR/zinc/examples/queen4

   The following solution is then written on the current output stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
Note the ten consecutive dashes after the solution.

   The following goal can be used to find all solutions:
     | ?- fzn_run_file(library('zinc/examples/queen4'), [solutions(all)]).

or command:

     % spfz $SP_LIBRARY_DIR/zinc/examples/queen4 -a

   The following solutions are then written on the current output
stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
     q = array1d(1..4, [3, 1, 4, 2]);
     ----------
     ==========
Note the ten consecutive equal signs after all solutions have been
found.

   FlatZinc programs are not intended to be written (or read) by humans,
but rather to be automatically generated. One way to generate a FlatZinc
program is by using a MiniZinc-to-FlatZinc translator, such as
`mzn2fzn', provided by the G12 project. One use of this translator is
to first generate a FlatZinc program from a MiniZinc program, e.g. by
the following command line (`queen.mzn' and `queen4.dat' can be found
in `library('zinc/examples')'):
     mzn2fzn -G sicstus --data queen4.dat --output-to-file queen4.fzn queen.mzn
The resulting FlatZinc program `queen4.fzn' can then be run as
described above. If a generated FlatZinc program is not desired, another
use of `mzn2fzn' is to pipe its result directly to a SICStus process,
e.g. by the following command:

     mzn2fzn -G sicstus --data queen4.dat --output-to-stdout queen.mzn | sicstus --goal 'use_module(library(zinc)), fzn_run_stream(user_input), halt.'

or, simpler:

     minizinc -G sicstus --data queen4.dat queen.mzn -f spfz

or, even simpler:

     minizinc -G sicstus -D n=4 queen.mzn -f spfz

or, simpler still:

     mzn-sicstus -D n=4 queen.mzn

   *Please note*: The translator `mzn2fzn' needs to be made aware of
the SICStus specific global constraint definitions, located in
`library('zinc/globals')'. This is necessary in order for the
MiniZinc-to-FlatZinc translation to be SICStus specific. If this is not
done, the SICStus interpreter may run the resulting FlatZinc program
significantly slower.  In the commands given above, this is done by the
option `-G sicstus', which requires that there be a symbolic link
`/opt/minizinc-1.6/lib/minizinc/sicstus' pointing at
`library('zinc/globals')'.  If you are unable to add such a link, an
alternative to `-G sicstus' is to pass the path to
`library('zinc/globals')' in the `--search-dir' option of `mzn2fzn'.

   It is also possible to just load a FlatZinc program into SICStus by
`fzn_load_file/2' and `fzn_load_stream/2'. The loaded FlatZinc program
can then be processed further from within SICStus, e.g. by retrieving
some FlatZinc variables using `fzn_identifier/3' and posting additional
`library(clpfd)' constraints or applying a Prolog labeling predicate on
those variables.

   Finally, it is also possible to load and run MiniZinc programs
directly from within SICStus by using the predicates described in *note
MiniZinc::. These predicates all rely on the availability of an
external MiniZinc-to-FlatZinc translator such as `mzn2fzn', as well as
an external solution printer such as `solns2out' (*note MiniZinc::).


File: sicstus.info,  Node: FlatZinc Exported Predicates,  Up: FlatZinc

10.39.2.1 Exported Predicates
.............................

The predicates described here operate on a data structure FZNSTATE
representing a FlatZinc program and consisting of the following members:

   * A table that maps identifiers of the FlatZinc program to Prolog
     terms.

   * A list containing all domain variables of the FlatZinc program,
     except those with a `var_is_introduced' annotation.

   * A list containing all domain variables of the FlatZinc program that
     may be written on the current output stream.

   * A goal representing the constraint part of the FlatZinc program.

   * A goal representing the solve part of the FlatZinc program.

   * A counter denoting the number of solutions found by the FlatZinc
     program.


   This data structure can be constructed from a FlatZinc program by the
predicates `fzn_load_stream/2' and `fzn_load_file/2' described next, or
directly from a MiniZinc program (*note MiniZinc::).

`fzn_load_stream(+FZNSTREAM, -FZNSTATE)'
     FZNSTREAM is a FlatZinc input stream. FZNSTATE is a FlatZinc state
     which is initialized with respect to FZNSTREAM.

     _Exceptions:_ Exceptions regarding errors in FZNSTREAM (*note Zinc
     Errors::).

`fzn_load_file(+FZNFILE, -FZNSTATE)'
     FZNFILE is a FlatZinc file (extension defaults to `.fzn').
     FZNSTATE is a FlatZinc state which is initialized with respect to
     FZNFILE. This predicate is just a wrapper around
     `fzn_load_stream/2' handling stream opening and closing.

     _Exceptions:_
        * Exceptions related to the opening of FZNFILE for reading.

        * Exceptions regarding errors in FZNFILE (*note Zinc Errors::).



   Consider the following FlatZinc program for solving the 4 Queens
problem located in `library('zinc/examples/queen4.fzn')'. _(Note that
FlatZinc programs are not intended to be written (or read) by humans,
but rather to be automatically generated. One method to generate
FlatZinc programs is described in *note MiniZinc::.)_

                                                         _% queen4.fzn_
     int: n = 4;

     array[1 .. 4] of var 1 .. 4: q::output_array([ 1 .. 4 ]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[2] ], 1);

     constraint int_ne(q[1], q[2]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[2] ], -1);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[3] ], 2);

     constraint int_ne(q[1], q[3]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[3] ], -2);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[4] ], 3);

     constraint int_ne(q[1], q[4]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[4] ], -3);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[3] ], 1);

     constraint int_ne(q[2], q[3]);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[3] ], -1);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[4] ], 2);

     constraint int_ne(q[2], q[4]);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[4] ], -2);

     constraint int_lin_ne([ 1, -1 ], [ q[3], q[4] ], 1);

     constraint int_ne(q[3], q[4]);

     constraint int_lin_ne([ 1, -1 ], [ q[3], q[4] ], -1);

     solve satisfy;

   A FlatZinc state `Queen4State' representing the program above can be
constructed by typing:

     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State).

   The predicates presented next are used to query an already
initialized FlatZinc state.

`fzn_post(+FZNSTATE)'
     Posts the constraints of the FlatZinc program represented by
     FZNSTATE. May fail if the constraints are inconsistent.

`fzn_solve(+FZNSTATE)'
     Runs the solve part of the FlatZinc program represented by
     FZNSTATE to find an (optimal) solution. Fails if the constraints
     of the FlatZinc program are inconsistent. Generates the next
     solution upon backtracking.

`fzn_output(+FZNSTATE)'
     Outputs the values of the variables in FZNSTATE that have been
     annotated with `output_var/0' or `output_array/1'.

     _Exceptions:_ An _instatiation error_ if the output variables  are
     not instantiated.


   Consider again the FlatZinc program `queen4.fzn' described above and
the following goal at the Prolog top level:

     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_post(Queen4State),
          fzn_solve(Queen4State),
          fzn_output(Queen4State).

   The first line initializes `Queen4State' with respect to
`queen4.fzn'. The second and third line posts the constraints of
`queen4.fzn' and runs the solve part of `queen4.fzn', respectively.
Finally, the fourth line runs the output part of `queen4.fzn' which
means that the following is written on the current output stream:

     q = array1d(1..4, [2, 4, 1, 3]);
     ----------

   Upon backtracking the solve and output parts of `Queen4State' are
rerun, which means that the following is written on the current output
stream:

     q = array1d(1..4, [3, 1, 4, 2]);
     ----------

`fzn_identifier(+FZNSTATE, +ID, -VALUE)'
     FZNSTATE is a FlatZinc state initialized with respect to some
     FlatZinc program and ID is an identifier of the FlatZinc program.
     Unifies the FlatZinc value of ID with VALUE according to the
     following translation scheme:

        * A `bool' is translated into a Prolog integer: `false' is
          translated into `0' and `true' is translated into `1'.

        * An `int' is translated into a Prolog integer.

        * A `float' is translated into a Prolog float.

        * An integer range or an integer set is translated into a
          `library(clpfd)' FD set term (*note FD Set Operations::).

        * A non-integer set is translated into a sorted Prolog list
          containing the (translated) elements of the set.

        * An array is translated into a Prolog list containing the
          (translated) elements of the array. Ordering is preserved
          such that the _n_th element of the array is the _n_th element
          of the list.

        * A `var int' is translated into a `library(clpfd)' domain
          variable (*note CLPFD Interface::).

        * A `var bool' is translated into a `library(clpfd)' domain
          variable with the domain `0..1' (*note CLPFD Interface::).

     _Exceptions:_ An _existence error_ if ID is not an identifier of
     FZNSTATE.

`fzn_objective(+FZNSTATE, -OBJECTIVE)'
     FZNSTATE is a FlatZinc state initialized with respect to some
     FlatZinc program. Unifies OBJECTIVE with a domain variable
     representing the FlatZinc objective.

     _Exceptions:_ An _existence error_ if there is no objective in
     FZNSTATE.


   A possible use of `fzn_identifier/3' is to post additional
`library(clpfd)' constraints or to apply a Prolog labeling predicate on
the FlatZinc variables. For example, given the 4 Queens problem in
`queen4.fzn' described above, the following goal labels the variables
to find all solutions:
     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_post(Queen4State),
          fzn_identifier(Queen4State, q, Q),
          findall(_, (labeling([], Q), fzn_output(Queen4State)), _).
Given this goal, the following is written on the current output stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
     q = array1d(1..4, [3, 1, 4, 2]);
     ----------
To avoid symmetric solutions where the chess board is rotated 180
degrees, the following goal posts an additional symmetry breaking
constraint on the first two queens:
     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_post(Queen4State),
          fzn_identifier(Queen4State, q, Q),
          Q = [Q1, Q2|_], Q1 #< Q2,
          findall(_, (labeling([], Q), fzn_output(Queen4State)), _).
Given this goal, the following is written on the current output stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
Note that, now, only the first one of the previous two solutions is
displayed.

   The following two predicates can be used to run a FlatZinc program in
one go. They both take as optional argument a list OPTIONS which can be
used to change the default behavior of the execution. This list may
contain zero or more of the following:

`search(METHOD)   "since release 4.3"'
     where METHOD must be one of the atoms `bab' and `restart'. Tells
     the solver which optimization algorithm to use: branch-and-bound
     (the default), or to restart the search each time a new solution
     is found.  The corresponding `spfz' option is `-search METHOD'.

`solutions(NUMBEROFSOLUTIONS)'
     where NUMBEROFSOLUTIONS must be an integer greater than zero or
     the atom `all'. Describes the number of solutions to search for;
     the default is 1.  The corresponding `spfz' options are `-n N' and
     `-a'.

`output(FILE)'
     where FILE must be the name of a writable file. Causes any output
     written on the current output stream to be directed to FILE.  The
     corresponding `spfz' option is `-o FILE'.

`ozn_file(FILE)   "since release 4.2.3"'
     where FILE must be the name of an existing file, containing the
     MiniZinc output commands that the solution printer `solns2out'
     should use.  If not given, the solution printer will not be used,
     and the solutions will be printed unformatted.

`statistics(BOOLEAN)'
     where BOOLEAN must be `true' or `false' (default).  The
     corresponding `spfz' option is `-s'.  If `true', the following
     statistics are written on the current output stream (see the
     built-in `statistics/[0,2]' and `fd_statistics/[0,2]' of
     `library(clpfd)' for more detailed information on their meaning):

    `runtime'
          Total running time (milliseconds), including parsing the
          FlatZinc program.

    `solvetime'
          Running time (milliseconds) for posting the constraints and
          performing the search.

    `solutions'
          The number of solutions found.

    `constraints'
          The number of constraints created.

    `backtracks'
          The number of times a contradiction was found by a domain
          being wiped out, or by a global constraint signalling failure.

    `prunings'
          The number of times a domain was pruned.

`timeout(TIME)'
     where TIME must be an integer between (not including) 0 and
     2147483647. Stops the computation if it has not finished before
     TIME milliseconds has elapsed.  The corresponding `spfz' option is
     `-time TIME'.

`fzn_run_stream(+FZNSTREAM)'
`fzn_run_stream(+FZNSTREAM, +OPTIONS)'
     FZNSTREAM is a FlatZinc input stream and OPTIONS is a list of
     options as described above. Performs the following steps:

       1. Loads the FlatZinc program (`fzn_load_stream/2'),
          initializing a FlatZinc state.

       2. Posts the constraints of the FlatZinc program (`fzn_post/1').

       3. Runs the solve part of the FlatZinc program (`fzn_solve/1').

       4. Outputs the values of the variables that have been annotated
          with `output_var/0' or `output_array/1'.

     The two final steps are repeated until the number of solutions as
     specified in OPTIONS have been found or until no more solutions can
     be found. At this point, if the whole search space have been
     explored ten consecutive equal signs are output on a separate line.

     _Exceptions:_
        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom `all'.

        * Exceptions regarding errors in FZNSTREAM (*note Zinc
          Errors::).


`fzn_run_file(+FZNFILE)'
`fzn_run_file(+FZNFILE, +OPTIONS)'
     FZNFILE is a FlatZinc program file (extension defaults to `.fzn')
     and OPTIONS is a list of options as described above. This
     predicate is just a wrapper around `fzn_run_stream/[1,2]' handling
     stream opening and closing.

     _Exceptions:_
        * Exceptions related to the opening of FZNFILE for reading.

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom `all'.

        * Exceptions regarding errors in FZNFILE (*note Zinc Errors::).



   The next predicate can be used to write the constraints of a FlatZinc
program to a file, in the format of `library(clpfd)'.

`fzn_dump(+FZNSTATE, +FILE)'
`fzn_dump(+FZNSTATE, +OPTIONS, +FILE)'
     FZNSTATE is a FlatZinc state initialized with respect to some
     FlatZinc program and FILE is a writable file (extension defaults
     to `.pl').  Writes the constraints of FZNSTATE to FILE in the
     format of `library(clpfd)'.

     OPTIONS is a list containing zero or more of the following
     (currently, this is the only available option):

    `variables(LISTOFVARDEF)'
          where LISTOFVARDEF is a list of elements of the form ID=VAR
          where ID is a FlatZinc identifier and VAR is a Prolog
          variable. Means that VAR is unified with the value of ID
          after the FlatZinc program is loaded and that ID=VAR is
          included in a list of arguments to `query/1' that is written
          to FILE. Default is LISTOFVARDEF=`[vars=Vars]', with the
          meaning that VARS is a list containing all variables of the
          FlatZinc state, in the order they were introduced.


     _Exceptions:_ Exceptions related to the opening of FILE for
     writing.


   Consider again the FlatZinc program `queen4.fzn' described above and
the following goal at the Prolog top level:

     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_dump(Queen4State, [variables([q=Q])], queen4).

   The file `queen4.pl' then contains the following:

                                                            _queen4.pl_
     :- use_module(library(clpfd)).

     query([q=[A,B,C,D]]) :-
             true,
             domain([A,B,C,D], 1, 4),
             scalar_product([1,-1], [A,B], #\=, -1),
             scalar_product([1,-1], [A,B], #\=, 1),
             scalar_product([1,-1], [A,C], #\=, -2),
             scalar_product([1,-1], [A,C], #\=, 2),
             scalar_product([1,-1], [A,D], #\=, -3),
             scalar_product([1,-1], [A,D], #\=, 3),
             scalar_product([1,-1], [B,C], #\=, -1),
             scalar_product([1,-1], [B,C], #\=, 1),
             scalar_product([1,-1], [B,D], #\=, -2),
             scalar_product([1,-1], [B,D], #\=, 2),
             scalar_product([1,-1], [C,D], #\=, -1),
             scalar_product([1,-1], [C,D], #\=, 1),
             A#\=B,
             A#\=C,
             A#\=D,
             B#\=C,
             B#\=D,
             C#\=D.


File: sicstus.info,  Node: MiniZinc,  Next: Zinc Errors,  Prev: FlatZinc,  Up: lib-zinc

10.39.3 MiniZinc
----------------

* Menu:

* MiniZinc Prerequisites:: Prerequisites
* MiniZinc Exported Predicates:: Exported Predicates

   The predicates described here make it possible to load and run
MiniZinc programs directly from within SICStus and require an external
MiniZinc-to-FlatZinc translator. In this way, the predicates described
here are essentially wrappers to the predicates described in *note
FlatZinc::, handling the MiniZinc-to-FlatZinc translation and providing
a more high-level interface.


File: sicstus.info,  Node: MiniZinc Prerequisites,  Next: MiniZinc Exported Predicates,  Up: MiniZinc

10.39.3.1 Prerequisites
.......................

An external MiniZinc-to-FlatZinc translator must be made available to
SICStus and must accept:
   * a MiniZinc program file `<model>.mzn' as only argument.

   * the option `--no-optimise' with the meaning that the translation
     should be unoptimized.

   * the option `--output-fzn-to-file' FILE with the meaning that the
     translated FlatZinc program is written onto FILE.

   * the option `--output-ozn-to-file' FILE with the meaning that the
     output commands of the FlatZinc program are written onto FILE.

   * (multiple instances of) the option `--data' FILE with the meaning
     that FILE is an included MiniZinc data file.

   * (multiple instances of) the option `--search-dir' DIR with the
     meaning that DIR is searched for MiniZinc data files and solver
     specific global constraint definitions.

   There are two ways to make such a translator available to SICStus:
  1. Set the environment variable `MZN2FZN' to the location of the
     translator executable.

  2. Put a translator executable named `mzn2fzn' in a directory included
     in the `PATH' environment variable.

   An external solution printer, such as `solns2out', should be
available to SICStus.  This can be done in two ways:
  1. Set the environment variable `SOLNS2OUT' to the location of the
     translator executable.

  2. Put a translator executable named `solns2out' in a directory
     included in the `PATH' environment variable.

   The G12 MiniZinc and FlatZinc distribution includes such a
MiniZinc-to-FlatZinc translator and solution printer. See the G12
MiniZinc and FlatZinc web pages at
`http://www.g12.csse.unimelb.edu.au/minizinc' for more information and
download links.


File: sicstus.info,  Node: MiniZinc Exported Predicates,  Prev: MiniZinc Prerequisites,  Up: MiniZinc

10.39.3.2 Exported Predicates
.............................

The following predicates all take as (optional) argument a list OPTIONS
which can be used to change the default behavior of the execution. This
list may contain zero or more of the following:

`data_file(MZNDATFILE)'
     where MZNDATFILE must be a MiniZinc data file. Means that
     MZNDATFILE is passed to the MiniZinc-to-FlatZinc translator
     through the `--data' option.

`parameters(LISTOFPARDEF)'
     where LISTOFPARDEF is a list of elements of the form ID=VALUE
     where ID is a MiniZinc identifier and VALUE is a MiniZinc value.
     Means that all elements are written to a temporary file which is
     passed to the MiniZinc-to-FlatZinc translator through the `--data'
     option.

`post(BOOLEAN)'
     where BOOLEAN must be `true' or `false'. If `true' (the default),
     the constraints of the MiniZinc program are posted directly and a
     separate call to `fzn_post/1' (*note FlatZinc Exported
     Predicates::) is not necessary. (Only usable with
     `mzn_load_file/3' and `mzn_load_model/3'.)

`search(METHOD)   "since release 4.3"'
     where METHOD must be one of the atoms `bab' and `restart'. Tells
     the solver which optimization algorithm to use: branch-and-bound
     (the default), or to restart the search each time a new solution
     is found.  (Only usable with `mzn_run_file/2' and
     `mzn_run_model/2'.)

`solutions(NUMBEROFSOLUTIONS)'
     where NUMBEROFSOLUTIONS must be an integer greater than zero or
     the atom `all'. Describes the number of solutions to search for,
     default is 1. (Only usable with `mzn_run_file/2' and
     `mzn_run_model/2'.)

`output(FILE)'
     where FILE must be the name of a writable file. Causes any output
     written on the current output stream to be directed to FILE. (Only
     usable with `mzn_run_file/2' and `mzn_run_model/2'.)

`fzn_file(FILE)   "since release 4.2.3"'
     where FILE must be the name of a writable file.  The translated
     FlatZinc program will be written to the given file.  Otherwise, a
     temporary file will be used and erased afterwards.

`ozn_file(FILE)   "since release 4.2.3"'
     where FILE must be the name of a writable file.  The MiniZinc
     output commands will be written to the given file.  Otherwise, a
     temporary file will be used and erased afterwards.

`optimise(BOOLEAN)   "since release 4.2.3"'
`optimize(BOOLEAN)   "since release 4.2.3"'
     where BOOLEAN must be `true' (the default) or `false'. If `false',
     `--no-optimise' is passed to `mzn2fzn'.

`statistics(BOOLEAN)'
     where BOOLEAN must be `true' or `false' (default). If `true', the
     following statistics are written on the current output stream (see
     the built-in `statistics/[0,2]' and `fd_statistics/[0,2]' of
     `library(clpfd)' for more detailed information on their meaning):
    `runtime'
          Total running time (milliseconds), including parsing the
          FlatZinc program.

    `solvetime'
          Running time (milliseconds) for posting the constraints and
          performing the search.

    `solutions'
          The number of solutions found.

    `constraints'
          The number of constraints created.

    `backtracks'
          The number of times a contradiction was found by a domain
          being wiped out, or by a global constraint signalling failure.

    `prunings'
          The number of times a domain was pruned.
     (Only usable with `mzn_run_file/2' and `mzn_run_model/2'.)

`timeout(TIME)'
     where TIME must be an integer between (not including) 0 and
     2147483647. Stops the computation if it has not finished before
     TIME milliseconds has elapsed. Measuring starts after the call to
     the MiniZinc-to-FlatZinc translator has finished. (Only usable
     with `mzn_run_file/2' and `mzn_run_model/2'.)

`variables(LISTOFVARDEF)'
     where LISTOFVARDEF is a list of elements of the form ID=VAR where
     ID is a MiniZinc identifier and VAR is a Prolog variable. Means
     that VAR is unified with the value of ID after the MiniZinc
     program is loaded. (Only usable with `mzn_load_file/3' and
     `mzn_load_model/3').


   The first two predicates can be used to run a MiniZinc program in one
go.

`mzn_run_file(+MZNFILE)'
`mzn_run_file(+MZNFILE, +OPTIONS)'
     MZNFILE is a MiniZinc program file and OPTIONS is a list of
     options as described above.  Runs the MiniZinc program on MZNFILE,
     and writes the result onto the file given in the `option/1' option
     if given, or onto the current output stream otherwise. This is
     done by first calling the external MiniZinc-to-FlatZinc
     translator, and then interpreting the output of that program with
     `fzn_run_stream/[1,2]' (*note FlatZinc Exported Predicates::).
     Fails if the constraints of the MiniZinc program are inconsistent.

     _Exceptions:_
        * Exceptions related to the opening of MZNFILE for reading.

        * A _system error_ if the external MiniZinc-to-FlatZinc
          translator is not successful. This error will include any
          information produced by the MiniZinc-to-FlatZinc translator
          on its standard error stream.

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom `all'.

        * Exceptions regarding errors in MZNFILE (*note Zinc Errors::)
          although these are most probably already handled by the
          external MiniZinc-to-FlatZinc translator.


`mzn_run_model(+MZNMODEL)'
`mzn_run_model(+MZNMODEL, +OPTIONS)'
     MZNMODEL is a MiniZinc program specified by a list of strings as
     explained below and OPTIONS is a list of options as described
     above.  Runs the MiniZinc program MZNMODEL, and writes the result
     onto the file given in the `option/1' option if given, or onto the
     current output stream otherwise.  This is done by first calling
     the external MiniZinc-to-FlatZinc translator and interpreting the
     output of that program with `fzn_run_stream/[1,2]' (*note FlatZinc
     Exported Predicates::).  The MiniZinc program specification
     MZNMODEL must be a list of strings (list of character codes) where
     each element must specify one line of the MiniZinc program. For
     example, a MiniZinc program for the N Queens problem can be
     specified as follows:
          NQueens = ["int: n;",
                     "array [1..n] of var 1..n: q;",
                     "constraint forall (i in 1..n, j in i+1..n)",
                         "(q[i] != q[j] /\\",
                          "q[i] + i != q[j] + j /\\",
                          "q[i] - i != q[j] - j);",
                     "solve satisfy;",
                     "output [\"A solution to the \", show(n),",
                     "\" Queens problem: \", show(q), \"\\n\"];"]
     *Note_that* backslashes and double quotes must be escaped with an
     additional backslash.

     _Exceptions:_
        * A _system error_ if the external MiniZinc-to-FlatZinc
          translator is not successful. This error will include any
          information produced by the MiniZinc-to-FlatZinc translator
          on its standard error stream.

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom `all'.

        * Exceptions regarding errors in MZNMODEL (*note Zinc Errors::)
          although these are most probably already handled by the
          external MiniZinc-to-FlatZinc translator.



   Consider the following MiniZinc program for solving the N Queens
problem located in `library('zinc/examples/queen.mzn')':
                                                            _queen.mzn_
     int: n;

     array [1..n] of var 1..n: q;

     constraint
         forall (i in 1..n, j in i+1..n) (
             q[i] != q[j] /\
             q[i] + i != q[j] + j /\
             q[i] - i != q[j] - j
         );

     solve satisfy;

     output ["A solution to the ", show(n), " Queens problem: ", show(q), "\n"];

   Consider now the following goal at the Prolog top level:

     | ?- mzn_run_file(library('zinc/examples/queen'),
                       [data_file(library('zinc/examples/queen4.dat'))]).

   Since `library('zinc/examples/queen4.dat')' contains the single line
     n = 4;
the following is written on the current output stream:
     A solution to the 4 Queens problem: [2, 4, 1, 3]
     ----------

   The initialization `n = 4' can also be passed using the
`parameter/1' option. So the following goal is equivalent to the one
above:
     | ?- mzn_run_file(library('zinc/examples/queen'), [parameters([n=4])]).

   Finally, the following goal finds all solutions to the 4 Queens
problem:
     | ?- mzn_run_file(library('zinc/examples/queen'),
                       [parameters([n=4]), solutions(all)]).
Given this goal, the following is written on the current output stream:
     A solution to the 4 Queens problem: [2, 4, 1, 3]
     ----------
     A solution to the 4 Queens problem: [3, 1, 4, 2]
     ----------
     ==========

   The next two predicates can be used to construct a FlatZinc state
(*note FlatZinc Exported Predicates::).

`mzn_load_file(+MZNFILE, -FZNSTATE)'
`mzn_load_file(+MZNFILE, +OPTIONS, -FZNSTATE)'
     MZNFILE is a MiniZinc program file and OPTIONS is a list of
     options as described above. Initializes a FlatZinc state FZNSTATE
     with respect to MZNFILE. May fail if `post(true)' and the
     constraints are inconsistent.

     _Exceptions:_
        * Exceptions related to the opening of MZNFILE for reading.

        * A _system error_ if the external MiniZinc-to-FlatZinc
          translator is not successful. This error will include any
          information produced by the MiniZinc-to-FlatZinc translator
          on its standard error stream.

        * An _existence error_ if an ID of the `variables/1' option is
          not an identifier of FZNSTATE.

        * Exceptions regarding errors in MZNFILE (*note Zinc Errors::)
          although these are most probably already handled by the
          external MiniZinc-to-FlatZinc translator.


`mzn_load_model(+MZNMODEL, -FZNSTATE)'
`mzn_load_model(+MZNMODEL, +OPTIONS, -FZNSTATE)'
     MZNMODEL is a MiniZinc program specified by a list of strings as
     explained for `mzn_run_model/[1,2]' above and OPTIONS is a list of
     options as described above.  Initializes a FlatZinc state FZNSTATE
     with respect to MZNMODEL. May fail if `post(true)' and the
     constraints are inconsistent.

     _Exceptions:_
        * A _system error_ if the external MiniZinc-to-FlatZinc
          translator is not successful. This error will include any
          information produced by the MiniZinc-to-FlatZinc translator
          on its standard error stream.

        * An _existence error_ if an ID of the `variables/1' option is
          not an identifier of FZNSTATE.

        * Exceptions regarding errors in MZNMODEL (*note Zinc Errors::)
          although these are most probably already handled by the
          external MiniZinc-to-FlatZinc translator.



   The following Prolog goal constructs a FlatZinc state representing
the 4 Queens problem:
     | ?- mzn_load_file(library('zinc/examples/queen'),
                        [parameters([n=4])], Queen4State).

   See *note FlatZinc Exported Predicates:: for more information on
FlatZinc states and how they can be queried. A very useful option to
`mzn_load_file/3' and `mzn_load_model/3' is the `variables/1' option,
which can be used to unify values of MiniZinc identifiers with Prolog
variables (this option can be used in place of several calls to
`fzn_identifier/3'). For example, the following goal posts an
additional symmetry breaking constraint and labels the variables using
a Prolog goal that finds all remaining solutions to the 4 Queens
problem:
     | ?- mzn_load_file(library('zinc/examples/queen'),
                        [parameters([n=4]), variables([q=Q])],
                        Queen4State),
          Q = [Q1, Q2|_], Q1 #< Q2,
          findall(_, (labeling([], Q), fzn_output(Queen4State)), _).
Given this goal, the following is written on the current output stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------

   The final predicate can be used to translate a MiniZinc file to a
FlatZinc by a direct call to the MiniZinc-to-FlatZinc translator.

`mzn_to_fzn(+MZNFILE, +FZNFILE)'
`mzn_to_fzn(+MZNFILE, +OPTIONS, +FZNFILE)'
     MZNFILE is a MiniZinc program file and OPTIONS is a list of
     options as described above. Calls the external
     MiniZinc-to-FlatZinc translator which result is written to FZNFILE.

     _Exceptions:_
        * Exceptions related to the opening of MZNFILE for reading as
          well as the opening of FZNFILE for writing.

        * A _system error_ if the external MiniZinc-to-FlatZinc
          translator is not successful. This error will include any
          information produced by the MiniZinc-to-FlatZinc translator
          on its standard error stream.

        * Exceptions regarding errors in MZNFILE (*note Zinc Errors::)
          although these are most probably already handled by the
          external MiniZinc-to-FlatZinc translator.



* Menu:

* Zinc Errors:: Zinc Errors


File: sicstus.info,  Node: Zinc Errors,  Prev: MiniZinc,  Up: lib-zinc

10.39.4 Zinc Errors
-------------------

The following is a list of exceptions that may be generated by the
predicates described in *note FlatZinc Exported Predicates:: and in
*note MiniZinc Exported Predicates:: when there is an error in the
FlatZinc or MiniZinc input.

   * A _syntax error_ occurs when the parser cannot continue. For
     example, the FlatZinc code:
          array[1..2] of int a = [1, 2];
     generates the following error (since there must be a colon between
     `int' and `a'):
          ! Item ending on line 1:
          ! Syntax error
          ! expected `:' but found `ident(a)'
     The line number indicates the ending line of the item containing
     the error. *Note_that* this means that the error may be on a
     preceding line, if the item occupies several lines.

   * A _consistency error_ occurs when the same identifier is used
     multiple times. For example, the FlatZinc code:
          bool : b = false;
          bool : b = true;
     generates the following error:
          ! Item ending on line 2:
          ! Consistency error: `b' is already defined
          ! previous definition of b was `bool : b = false'
          ! cannot redefine b to `bool : b = true'

   * An _existence error_ occurs when an identifier or a constraint is
     used without being previously defined. For example, the FlatZinc
     code:
          bool : b = a;
     may generate the following error:
          ! Item ending on line 2:
          ! Existence error
          ! `a' is not defined
     Another example, the FlatZinc code:
          var int : a;
          var int : b;
          constraint distance(a, b, 1);
     may generate the following error:
          ! Item ending on line 4:
          ! Existence error
          ! `distance/3' is not defined

   * A _type error_ occurs when a value is of the wrong type. For
     example, the FlatZinc code:
          var float : f;
     generates the following error (since only finite domain integer
     variables are supported):
          ! Item ending on line 2:
          ! Type error
          ! `f' must be a member of `int'

     Another example, the FlatZinc code:
          array[1..2] of float : a = [2.1, 3];
     generates the following error (since an array of floats cannot
     contain integers):
          ! Item ending on line 2:
          ! Type error
          ! `3' must be a member of `float'

     A type error also occurs when an array index is out of bounds. For
     example, the FlatZinc code:
          array[1..2] of int : a = [1, 2];
          int : i = a[3];
     generates the following error:
          ! Item ending on line 3:
          ! Type error in array index
          ! index evaluates to 3 but must be in 1..2



File: sicstus.info,  Node: lib-pillow,  Next: lib-tcltk,  Prev: lib-zinc,  Up: The Prolog Library

10.40 The PiLLoW Web Programming Library--`library(pillow)'
===========================================================

The PiLLoW library ("Programming in Logic Languages on the Web") is a
free Internet/WWW programming library for Logic Programming Systems that
simplifies the process of writing applications for such environment.
The library provides facilities for generating HTML or XML structured
documents by handling them as Prolog terms, producing HTML forms,
writing form handlers, processing HTML templates, accessing and parsing
WWW documents (either HTML or XML), accessing code posted at HTTP
addresses, etc.

   PiLLoW is documented in its own reference manual, located in
`http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc_html/pillow_doc_toc.html'
(HTML) or `http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc.ps'
(Postscript). The following points are worth noting wrt. the PiLLoW
reference manual:

   * PiLLoW is automatically installed with the SICStus Prolog
     distribution.  No extra action needs to be taken.

   * PilloW comes as a single library module, `library(pillow)'.

     This subsumes the various `load_package/1' and `use_module/1'
     queries mentioned in the PiLLoW reference manual.

   Further information can be found at the PiLLoW home page,
`http://clip.dia.fi.upm.es/Software/pillow/pillow.html'.


File: sicstus.info,  Node: lib-tcltk,  Next: lib-gauge,  Prev: lib-pillow,  Up: The Prolog Library

10.41 Tcl/Tk Interface--`library(tcltk)'
========================================

* Menu:

* Introduction (Tcl):: Introduction
* Tcl:: Tcl
* Tk:: Tk
* The Tcl/Tk Prolog Library:: The Tcl/Tk Prolog Library
* Putting It All Together:: Putting It All Together
* Quick Reference:: Quick Reference
* Resources:: Resources


File: sicstus.info,  Node: Introduction (Tcl),  Next: Tcl,  Up: lib-tcltk

10.41.1 Introduction
--------------------

This is a basic tutorial for those SICStus Prolog users who would like
to add Tcl/Tk user interfaces to their Prolog applications.  The
tutorial assumes no prior knowledge of Tcl/Tk but, of course, does
assume the reader is proficient in Prolog.

   Aware that the reader may not have heard of Tcl/Tk, we will start by
answering three questions: what is Tcl/Tk? what is it good for? what
relationship does it have to Prolog?

* Menu:

* What Is Tcl/Tk?:: What Is Tcl/Tk?
* What Is Tcl/Tk Good For?:: What Is Tcl/Tk Good For?
* What Is Tcl/Tks Relationship to SICStus Prolog?:: What Is Tcl/Tks Relationship to SICStus Prolog?
* A Quick Example of Tcl/Tk in Action:: A Quick Example of Tcl/Tk in Action
* Outline of This Tutorial:: Outline of This Tutorial


File: sicstus.info,  Node: What Is Tcl/Tk?,  Next: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.41.1.1 What Is Tcl/Tk?
.........................

Tcl/Tk, as its title suggests, is actually two software packages: Tcl
and Tk.  Tcl, pronounced _tickle_, stands for _tool command language_
and is a scripting language that provides a programming environment and
programming facilities such as variables, loops, and procedures. It is
designed to be easily extensible.

   Tk, pronounced _tee-kay_, is just such an extension to Tcl, which is
a "toolkit" for windowing systems. In other words, Tk adds facilities to
Tcl for creating and manipulating user interfaces based on windows and
widgets within those windows.


File: sicstus.info,  Node: What Is Tcl/Tk Good For?,  Next: What Is Tcl/Tks Relationship to SICStus Prolog?,  Prev: What Is Tcl/Tk?,  Up: Introduction (Tcl)

10.41.1.2 What Is Tcl/Tk Good For?
..................................

In combination the Tcl and Tk packages (we will call the combination
simply Tcl/Tk) are useful for creating graphical user interfaces (GUIs)
to applications. The GUI is described in terms of instances of Tk
widgets, created through calls in Tcl, and Tcl scripts that form the
glue that binds together the GUI and the application.  (If you are a
little lost at this point, all will be clear in a moment with  a simple
example.)

   There are lots of systems out there for adding GUIs to applications
so why choose Tcl/Tk? Tcl/Tk has several advantages that make it
attractive for this kind of work.  Firstly, it is good for rapid
prototyping of GUIs. Tcl is an interpreted scripting language. The
scripts can be modified and executed quickly, with no compilation
phase, so speeding up the development loop.

   Secondly, it is easier to use a system based on a scripting language,
such as Tcl/Tk, than many of the conventional packages available.  For
example, getting to grips with the X windows suite of C libraries is not
an easy task. Tcl/Tk can produce the same thing using simple scripting
with much less to learn.  The penalty for this is that programs written
in an interpreted scripting language will execute more slowly than
those written using compiled C library calls, but for many interfaces
that don't need great speed Tcl/Tk is fast enough and its ease of use
more than outweighs the loss of speed.  In any case, Tcl/Tk can easily
handle hundreds of events per mouse movement without the user noticing.

   Thirdly, Tcl/Tk is good for making cross-platform GUIs.  The Tk
toolkit has been ported to native look-and-feel widgets on Mac, PC
(Windows), and UNIX (X windows) platforms. You can write your scripts
once and they will execute on any of these platforms.

   Lastly, the software is distributed under a free software license
and so is available in both binary and source formats free of charge.


File: sicstus.info,  Node: What Is Tcl/Tks Relationship to SICStus Prolog?,  Next: A Quick Example of Tcl/Tk in Action,  Prev: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.41.1.3 What Is Tcl/Tks Relationship to SICStus Prolog?
.........................................................

SICStus Prolog comes with a Prolog library for interfacing to Tcl/Tk.
The purpose of the library is to enable Prolog application developers to
add GUIs to their applications rapidly and easily.


File: sicstus.info,  Node: A Quick Example of Tcl/Tk in Action,  Next: Outline of This Tutorial,  Prev: What Is Tcl/Tks Relationship to SICStus Prolog?,  Up: Introduction (Tcl)

10.41.1.4 A Quick Example of Tcl/Tk in Action
.............................................

As a taster, we will show you two simple examples programs that use
SICStus Prolog with the Tcl/Tk extensions: the ubiquitous "hello world"
example; and a very simple telephone book look up example.

   You are not expected to understand how these examples work at this
stage.  They are something for you to quickly type in to see how easy it
is to add GUIs to Prolog programs through Tcl/Tk.  After reading
through the rest of this tutorial you will fully understand these
examples and be able to write your own GUIs.

   Here is the "Hello World" program; also in
`library('tcltk/examples/ex1.pl')':

     :- use_module(library(tcltk)).

     go :-
         tk_new([name('Example 1')], Interp),
         tcl_eval(Interp, 'button .fred -text "hello world"
                           -command { puts "hello world"}', _),
         tcl_eval(Interp, 'pack .fred', _),
         tk_main_loop.


 [image src="images/tcltkex1.png" text="" ]                   SICStus+Tcl/Tk hello world program.

To run it just start up SICStus (under Windows use `sicstus', not
`spwin'), load the program, and evaluate the Prolog goal `go'. The
first line of the `go' clause calls `tk_new/2', which creates a Tcl/Tk
interpreter and returns a handle `Interp' through which Prolog will
interact with the interpreter.  Next a call to `tcl_eval/3' is made,
which creates a button displaying the `hello world' text. Next a call
is made to `tcl_eval/3' that causes the button to be displayed in the
main application window. Finally, a call is make to `tk_main_loop/0'
that passes control to Tcl/Tk, making sure that window events are
serviced.

   See how simple it is with just a three line Prolog program to create
an application window and display a button in it.  Click on the button
and see what it does.

   The reason you should use `sicstus' under Windows instead of `spwin'
is that the latter does not have the C standard streams
(`stdin',`stdout',`stderr') and the Tcl command `puts' will give an
error if there is no `stdout'.

   The previous example showed us how to create a button and display
some text in it. It was basically pure Tcl/Tk generated from within
Prolog but did not have any interaction with Prolog.  The following
example demonstrates a simple callback mechanism. A name is typed into
a text entry box, a button is pressed, which looks up the telephone
number corresponding to the name in a Prolog database, and the telephone
number is then displayed.

   Here is the code; also in `library('tcltk/examples/ex2.pl')':

     :- use_module(library(tcltk)).

     telephone(fred, '123-456').
     telephone(wilbert, '222-2222').
     telephone(taxi, '200-0000').
     telephone(mary, '00-36-1-666-6666').

     go :-
          tk_new([name('Example 2')], T),
          tcl_eval(T, 'entry .name -textvariable name',_),
          tcl_eval(T, 'button .search -text search -command {
                           prolog telephone($name,X);
                           set result $prolog_variables(X) }', _),
          tcl_eval(T, 'label .result -relief raised -textvariable result', _),
          tcl_eval(T, 'pack .name .search .result -side top -fill x', _),
          tk_main_loop.


 [image src="images/tcltkex2.png" text="" ]                 SICStus+Tcl/Tk telephone number lookup

Again, to run the example, start up SICStus Prolog, load the code, and
run the goal `go'.

   You will notice that three widgets will appear in a window: one is
for entering the name of the person or thing that you want to find the
telephone number for, the button is for initiating the search, and the
text box at the bottom is for displaying the result.

   Type `fred' into the entry box, hit the search button and you should
see the phone number displayed. You can then try the same thing but
with `wilbert', `taxi' or `mary' typed into the text entry box.

   What is happening is that when the button is pressed, the value in
the entry box is retrieved, then the `telephone/2' predicate is called
in Prolog with the entry box value as first argument, then the second
argument of telephone is retrieved (by this time bound to the number)
and is displayed below the button.

   This is a very crude example of what can be done with the Tcl/Tk
module in Prolog. For example, this program does not handle cases where
there is no corresponding phone number or where there is more than one
corresponding phone number.  The example is just supposed to wet your
appetite, but all these problems can be handled by Prolog + Tcl/Tk,
although with a more sophisticated program. You will learn how to do
this in the subsequent chapters.


File: sicstus.info,  Node: Outline of This Tutorial,  Prev: A Quick Example of Tcl/Tk in Action,  Up: Introduction (Tcl)

10.41.1.5 Outline of This Tutorial
..................................

Now we have motivated using Tcl/Tk as a means of creating GUIs for
Prolog programs, this document goes into the details of using Tcl/Tk as
a means of building GUIs for SICStus Prolog applications.

   Firstly, Tcl is introduced and its syntax and core commands
described.  Then the Tk extensions to Tcl are introduced. We show how
with Tcl and Tk together the user can build sophisticated GUIs easily
and quickly.  At the end of this Tcl/Tk part of the tutorial an example
of a pure Tcl/Tk program will be presented together with some tips on
how to design and code Tcl/Tk GUIs.

   The second phase of this document describes the SICStus Prolog
`tcltk' library. It provides extensions to Prolog that allow Prolog
applications to interact with Tcl/Tk: Prolog can make calls to Tcl/Tk
code and vice versa.

   Having reached this point in the tutorial the user will know how to
write a Tcl/Tk GUI interface and how to get a Prolog program to
interact with it, but arranging which process (the Prolog process or the
Tcl/Tk process) is the dominant partner is non-trivial and so is
described in a separate chapter on event handling. This will help the
user choose the most appropriate method of cooperation between Tcl/Tk
and Prolog to suit their particular application.

   This section, the Tcl/Tk+Prolog section, will be rounded off with
the presentation of some example applications that make use of Tcl/Tk
and Prolog.

   Then there is a short discussion section on how to use other Tcl
extension packages with Tcl/Tk and Prolog. Many such extension packages
have been written and when added to Prolog enhanced with Tcl/Tk can
offer further functionality to a Prolog application.

   The appendices provide a full listing with description of the
predicates available in the `tcltk' SICStus Prolog library, and the
extensions made to Tcl/Tk for interacting with Prolog.

   Lastly, a section on resources gives pointers to where the reader can
find more information on Tcl/Tk.


File: sicstus.info,  Node: Tcl,  Next: Tk,  Prev: Introduction (Tcl),  Up: lib-tcltk

10.41.2 Tcl
-----------

Tcl is an interpreted scripting language. In this chapter, first the
syntax of Tcl is described and then the core commands are described.
It is not intended to give a comprehensive description of the Tcl
language here but an overview of the core commands, enough to get the
user motivated to start writing their own scripts.

   For pointers to more information on Tcl; *note Resources::.

* Menu:

* Syntax (Tcl):: Syntax
* Variables (Tcl):: Variables
* Commands:: Commands
* What We Have Left Out (Tcl):: What We Have Left Out


File: sicstus.info,  Node: Syntax (Tcl),  Next: Variables (Tcl),  Up: Tcl

10.41.2.1 Syntax
................

A Tcl script consists of a series of strings separated from each other
by a newline character. Each string contains a command or series of
semi-colon separated commands.  A command is a series of words separated
by spaces. The first word in a command is the name of the command and
subsequent words are its arguments.

   An example is:

     set a 1
     set b 2

which is a Tcl script of two commands: the first command sets the value
of variable `a' to `1', and the second command sets the value of
variable `b' to `2'.

   An example of two commands on the same line separated by a semi-colon
is:

     set a 1; set b 2

which is equivalent to the previous example but written entirely on one
line.

   A command is executed in two phases.  In the first phase, the
command is broken down into its constituent words and various textual
substitutions are performed on those words.  In the second phase, the
procedure to call is identified from the first word in the command, and
the procedure is called with the remaining words as arguments.

   There are special syntactic characters that control how the first
phase, the substitution phase, is carried out. The three major
substitution types are variable substitution, command substitution, and
backslash substitution.

   _Variable substitution_ happens when a `$' prefixed word is found in
a command.  There are three types of variable substitution:

   - `$NAME'
        - where NAME is a scalar variable. NAME is simply substituted
          in the word for its value. NAME can contain only letters,
          digits, or underscores.

   - `$NAME(INDEX)'
        - where NAME is the name of an array variable and INDEX is the
          index into it. This is substituted by the value of the array
          element.  NAME must contain only letters, digits, or
          underscores.  INDEX has variable, command, and backslash
          substitution performed on it too.

   - `${NAME}'
        - where NAME can have any characters in it except closing curly
          bracket.  This is more or less the same as `$NAME'
          substitution except it is used to get around the restrictions
          in the characters that can form NAME.

   An example of variable substitution is:

     set a 1
     set b $a

which sets the value of variable `a' to `1', and then sets the value of
variable `b' to the value of variable `a'.

   _Command substitution_ happens when a word contains an open square
bracket, `['. The string between the open bracket and matching closing
bracket are treated as a Tcl script. The script is evaluated and its
result is substituted in place of the original command substitution
word.

   A simple example of command substitution is:

     set a 1
     set b [set a]

which does the same as the previous example but using command
substitution.  The result of a `set a' command is to return the value
of `a', which is then passed as an argument to `set b' and so variable
`b' acquires the value of variable `a'.

   _Backslash substitution_ is performed whenever the interpreter comes
across a backslash.  The backslash is an escape character and when it is
encountered is causes the interpreter to handle the next characters
specially.  Commonly escaped characters are `\a' for audible bell, `\b'
for backspace, `\f' for form feed, `\n' for newline, `\r' for carriage
return, `\t' for horizontal tab, and `\v' for vertical tab.
Double-backslash, `\\', is substituted with a single backslash.  Other
special backslash substitutions have the following forms:

   * `\ooo'
        - the digits `ooo' give the octal value of the escaped character

   * `\xHH'
        - the `x' denotes that the following hexadecimal digits are the
          value of the escaped character

   Any other character that is backslash escaped is simply substituted
by the character itself. For example, `\W' is replaced by `W'.

   A further syntactic construction is used to _delay substitution_.
When the beginning of a word starts with a curly bracket, `{', it does
not do any of the above substitutions between the opening curly bracket
and its matching closing curly bracket.  The word ends with the
matching closing curly bracket.  This construct is used to make the
bodies of procedures in which substitutions happen when the procedure is
called, not when it is constructed.  Or it is used anywhere when the
programmer does not want the normal substitutions to happen. For
example:

     puts {I have $20}

will print the string `I have $20' and will not try variable
substitution on the `$20' part.

   A word delineated by curly brackets is replaced with the characters
within the brackets without performing the usual substitutions.

   A word can begin with a _double-quote_ and end with the matching
closing double-quote. Substitutions as detailed above are done on the
characters between the quotes, and the result is then substituted for
the original word. Typically double-quotes are used to group sequences
of characters that contain spaces into a single command word.

   For example:

     set name "Fred the Great"
     puts "Hello my name is $name"

outputs `Hello my name is Fred the Great'. The first command sets the
value of variable `name' to the following double-quoted string `"Fred
the Great"'. The the next command prints its argument, a single
argument because it is a word delineated by double-quotes, that has had
variable substitution performed on it.

   Here is the same example but using curly brackets instead of
double-quotes:

     set name {Fred the Great}
     puts {Hello my name is $name}

gives the output `Hello my name is $name' because substitutions are
suppressed by the curly bracket notation.

   And again the same example but without either curly brackets or
double-quotes:

     set name Fred the Great
     puts Hello my name is $name

simply fails because both `set' and `puts' expect a single argument but
without the word grouping effects of double-quotes or curly brackets
they find that they have more than one argument and throw an exception.

   Being a simple scripting language, Tcl does not have any real idea of
data types. The interpreter simply manipulates strings.  The Tcl
interpreter is not concerned with whether those strings contain
representations of numbers or names or lists.  It is up to the commands
themselves to interpret the strings that are passed to them as
arguments in any manner those choose.


File: sicstus.info,  Node: Variables (Tcl),  Next: Commands,  Prev: Syntax (Tcl),  Up: Tcl

10.41.2.2 Variables
...................

This has been dealt with implicitly above.  A variable has a name and a
value.  A name can be any string whatsoever, as can its value.

   For example,

     set "Old King Cole" "merry soul"

sets the value of the variable named `Old King Cole' to the value
`merry soul'. Variable names can also be numbers:

     set 123 "one two three"

sets the variable with name `123' to the value `one two three'.  In
general, it is better to use the usual conventions -- start with a
letter then follow with a combination of letters, digits, and
underscores -- when giving variables names to avoid confusion.

   Array variables are also available in Tcl. These are denoted by an
array name followed by an array index enclosed in round brackets.  As
an example:

     set fred(one) 1
     set fred(two) 2

will set the variable `fred(one)' to the value `1' and `fred(two)' to
the value `2'.

   Tcl arrays are associative arrays in that both the array name and the
array index can be arbitrary strings. This also makes multidimensional
arrays possible if the index contains a comma:

     set fred(one,two) 12

   It is cheating in that the array is not stored as a multidimensional
array with a pair of indices, but as a linear array with a single index
that happens to contain a comma.


File: sicstus.info,  Node: Commands,  Next: What We Have Left Out (Tcl),  Prev: Variables (Tcl),  Up: Tcl

10.41.2.3 Commands
..................

Now that the Tcl syntax and variables have been been dealt with, we
will now look at some of the commands that are available.

   Each command when executed returns a value. The return value will be
described along with the command.

   A quick word about the _notation_ used to describe Tcl commands.  In
general, a description of a command is the name of the command followed
by its arguments separated by spaces.  An example is:

     set VARNAME ?VALUE?

which is a description of the Tcl set command, which takes a variable
name VARNAME and an optional argument, a VALUE.

   Optional arguments are enclosed in question mark, ?, pairs, as in
the example.

   A series of three dots ... represents repeated arguments. An example
is a description of the `unset' command:

     unset VARNAME ?VARNAME VARNAME ...?

which shows that the `unset' command has at least one compulsory
argument VARNAME but has any number of subsequent optional arguments.

   The most used _command over variables_ is the `set' command.  It has
the form

     set VARNAME ?VALUE?

   The value of VALUE is determined, the variable VARNAME is set to it,
and the value is returned. If there is no VALUE argument, the value of
the variable is simply returned. It is thus used to set and/or get the
value of a variable.

   The `unset' command is used to remove variables completely from the
system:

     unset VARNAME ?VARNAME VARNAME ...?

which given a series of variable names deletes them.  The empty string
is always returned.

   There is a special command for incrementing the value of a variable:

     incr VARNAME ?INCREMENT?

which, given the name of a variable thats value is an integer string,
increments it by the amount INCREMENT. If the INCREMENT part is left
out, it defaults to `1'. The return value is the new value of the
variable.

   _Expressions_ are constructed from operands and operators and can
then be evaluated.  The most general expression evaluator in Tcl is the
`expr' command:

     expr ARG ?ARG ARG ... ARG?

which evaluates its arguments as an expression and returns the value of
the evaluation.

   A simple example expression is

     expr 2 * 2

which when executed returns the value `4'.

   There are different classes of operators: arithmetic, relational,
logical, bitwise, and choice.  Here are some example expressions
involving various operators:

arithmetic     `$x * 2'
relational     `$x > 2'
logical        `($x == $y) || ($x == $z)'
bitwise        `8 & 2'
choice         `($a == 1) ? $x : $y'

   Basically the operators follow the syntax and meaning of their ANSI
C counterparts.

   Expressions to the `expr' command can be contained in curly brackets
in which case the usual substitutions are not done before the `expr'
command is evaluated, but the command does its own round of
substitutions. So evaluating a script such as:

     set a 1
     expr { ($a==1) : "yes" ? "no" }

will evaluate to `yes'.

   Tcl also has a whole host of math functions that can be used in
expressions.  Their evaluation is again the same as that for their ANSI
C counterparts.  For example:

     expr { 2*log($x) }

will return 2 times the natural log of the value of variable `x'.

   Tcl has a notion of _lists_, but as with everything it is implemented
through strings. A list is a string that contains words.

   A simple list is just a space separated series of strings:

     set a {one two three four five}

will set the variable `a' to the list containing the five strings
shown. The empty list is denoted by an open and close curly bracket
pair with nothing in between: `{}'.

   For the Prolog programmer, there is much confusion between a Prolog
implementation of lists and the Tcl implementation of lists.  In Prolog
we have a definite notion of the printed representation of a list: a
list is a sequence of terms enclosed in square brackets (we ignore dot
notation for now); a nested list is just another term.

   In Tcl, however, a list is really just a string that conforms to a
certain syntax: a string of space separated words.  But in Tcl there is
more than one way of generating such a string.  For example,

     set fred {a b c d}

sets `fred' to

     "a b c d"

as does

     set fred "a b c d"

because `{a b c d}' evaluates to the string `a b c d', which has the
correct syntax for a list.  But what about nested lists?  Those are
represented in the final list-string as being contained in curly
brackets.  For example:

     set fred {a b c {1 2 3} e f}

results in `fred' having the value

     "a b c {1 2 3} e f"

   The outer curly brackets from the `set' command have disappeared,
which causes confusion. The curly brackets within a list denote a nested
list, but there are no curly brackets at the top-level of the list.  (We
can't help thinking that life would have been easier if the creators of
Tcl would have chosen a consistent representation for lists, as Prolog
and LISP do.)

   So remember: a list is really a string with a certain syntax, space
separated items or words; a nested list is surrounded by curly brackets.

   There are a dozen commands that operate on lists.

     concat ?LIST LIST ...?

   This makes a list out of a series of lists by concatenating its
argument lists together. The return result is the list resulting from
the concatenation.

     lindex LIST INDEX

returns the INDEX-th element of the LIST.  The first element of a list
has an index of 0.

     linsert LIST INDEX VALUE ?VALUE ...?

returns a new list in which the VALUE arguments have been inserted in
turn before the INDEX-th element of LIST.

     list ?VALUE VALUE ...?

returns a list where each element is one of the VALUE arguments.

     llength LIST

returns the number of elements in list LIST.

     lrange LIST FIRST LAST

returns a slice of a list consisting of the elements of the list LIST
from index FIRST until index LAST.

     lreplace LIST FIRST LAST ?VALUE ... VALUE?

returns a copy of list LIST but with the elements between indices FIRST
and LAST replaced with a list formed from the VALUE arguments.

     lsearch ?-exact? ?-glob? ?-regexp? LIST PATTERN

returns the index of the first element in the list that matches the
given pattern. The type of matching done depends on which of the switch
is present `-exact', `-glob', `-regexp', is present. Default is `-glob'.

     lsort ?-ascii? ?-integer? ?-real? ?-command COMMAND? ?-increasing? ?-decreasing{? LIST

returns a list, which is the original list LIST sorted by the chosen
technique. If none of the switches supplies the intended sorting
technique, the user can provide one through the `-command COMMAND'
switch.

   There are also two useful commands for converting between lists and
strings:

     join LIST ?JOINSTRING?

which concatenates the elements of the list together, with the separator
JOINSTRING between them, and returns the resulting string.  This can be
used to construct filenames; for example:

     set a {{} usr local bin}
     set filename [join $a /]

results in the variable `filename' having the value `/usr/local/bin'.

   The reverse of the `join' command is the `split' command:

     split STRING ?SPLITCHARS?

which takes the string STRING and splits it into string on SPLITCHARS
boundaries and returns a list with the strings as elements.  An example
is splitting a filename into its constituent parts:

     set a [split /usr/local/src /]

gives `a' the value `{{} usr local src}', a list.

   Tcl has the four usual classes of _control flow_ found in most other
programming languages:

     if...elseif...else, while, for, foreach, switch, and eval.

   We go through each in turn.

   The general form of an `if' command is the following:

     if TEST1 BODY1 ?ELSEIF TEST2 BODY2 ELSEIF ...? ?ELSE BODYN?

which when evaluated, evaluates expression TEST1, which if true causes
BODY1 to be evaluated, but if false, causes TEST2 to be evaluated, and
so on.  If there is a final `else' clause, its BODYN part is evaluated
if all of the preceding tests failed.  The return result of an `if'
statement is the result of the last BODY command evaluated, or the
empty list if none of the bodies are evaluated.

   Conditional looping is done through the `while' command:

     while TEST BODY

which evaluates expression TEST, which if true then evaluates BODY.  It
continues to do that until TEST evaluates to 0, and returns the empty
string.

   A simple example is:

     set a 10
     while {$a > 0} { puts $a; incr a -1 }

which initializes variable `a' with value ten and then loops printing
out the value of `a' and decrementing it until its value is 0, when the
loop terminates.

   The `for' loop has the following form:

     for INIT TEST REINIT BODY

which initializes the loop by executing INIT, then each time around the
loop the expression TEST is evaluated, which if true causes BODY to be
executed and then executes REINIT. The loop spins around until TEST
evaluates to 0.  The return result of a `for' loop is the empty string.

   An example of a `for' loop:

     for {set a 10} ($a>0) {incr a -1} {puts $a}

which initializes the variable `a' with value `10', then goes around
the loop printing the value of `a' and decrementing it as long as its
value is greater than `0'.  Once it reaches `0' the loop terminates.

   The `foreach' command has the following form:

     foreach VARNAME LIST BODY

where VARNAME is the name of a variable, LIST is an instance of a list,
and BODY is a series of commands to evaluate.  A `foreach' then
iterates over the elements of a list, setting the variable VARNAME to
the current element, and executes BODY.  The result of a `foreach' loop
is always the empty string.

   An example of a `foreach' loop:

     foreach friend {joe mary john wilbert} {puts "I like $friend"}

will produce the output:

     I like joe
     I like mary
     I like john
     I like wilbert

   There are also a couple of commands for controlling the flow of
loops: `continue' and `break'.

   `continue' stops the current evaluation of the body of a loop and
goes on to the next one.

   `break' terminates the loop altogether.

   Tcl has a general switch statement, which has two forms:

     switch ?OPTIONS? STRING PATTERN BODY ?PATTERN BODY ... ?
     switch ?OPTIONS? STRING { PATTERN BODY ?PATTERN BODY ...? }

   When executed, the switch command matches its STRING argument
against each of the PATTERN arguments, and the BODY of the first
matching pattern is evaluated.  The matching algorithm depends on the
options chosen, which can be one of

`-exact'      use exact matching
`-glob'       use glob-style matching
`-regexp'     use regular expression matchinig

   An example is:

     set a rob
     switch -glob $a {
         a*z { puts "A to Z"}
         r*b { puts "rob or rab"}
     }

which will produce the output:

     rob or rab

   There are two forms of the `switch' command. The second form has the
command arguments surrounded in curly brackets. This is primarily so
that multi-line switch commands can be formed, but it also means that
the arguments in brackets are not evaluated (curly brackets suppress
evaluation), whereas in the first type of switch statement the
arguments are first evaluated before the switch is evaluated.  These
effects should be borne in mind when choosing which kind of switch
statement to use.

   The final form of control statement is `eval':

     eval ARG ?ARG ...?

which takes one or more arguments, concatenates them into a string, and
executes the string as a command. The return result is the normal
return result of the execution of the string as a command.

   An example is

     set a b
     set b 0
     eval set $a 10

which results in the variable `b' being set to `10'.  In this case, the
return result of the `eval' is `10', the result of executing the string
`"set b 10"' as a command.

   Tcl has several _commands over strings_. There are commands for
searching for patterns in strings, formatting and parsing strings (much
the same as `printf' and `scanf' in the C language), and general string
manipulation commands.

   Firstly we will deal with formatting and parsing of strings.  The
commands for this are `format' and `scan' respectively.

     format FORMATSTRING ?VALUE VALUE ...?

which works in a similar to C's `printf'; given a format string with
placeholders for values and a series of values, return the appropriate
string.

   Here is an example of printing out a table for base 10 logarithms
for the numbers 1 to 10:

     for {set n 1} {$n <= 10} {incr n} {
         puts [format "log10(%d) = %.4f" $n [expr log10($n)]]
     }

which produces the output

     ln(1) = 0.0000
     ln(2) = 0.3010
     ln(3) = 0.4771
     ln(4) = 0.6021
     ln(5) = 0.6990
     ln(6) = 0.7782
     ln(7) = 0.8451
     ln(8) = 0.9031
     ln(9) = 0.9542
     ln(10) = 1.0000

   The reverse function of `format' is `scan':

     scan STRING FORMATSTRING VARNAME ?VARNAME ...?

which parses the string according to the format string and assigns the
appropriate values to the variables.  it returns the number of fields
successfully parsed.

   An example,

     scan "qty 10, unit cost 1.5, total 15.0" \
          "qty %d, unit cost %f, total %f"    \
          quantity cost_per_unit total

would assign the value 10 to the variable `quantity', 1.5 to the
variable `cost_per_unit' and the value 15.0 to the variable `total'.

   There are commands for performing two kinds of pattern matching on
strings: one for matching using regular expressions, and one for
matching using UNIX-style wildcard pattern matching (globbing).

   The command for regular expressions matching is as follows:

     regexp ?-indices? ?-nocase? EXP STRING ?MATCHVAR? ?SUBVAR SUBVAR ...?

where EXP is the regular expression and STRING is the string on which
the matching is performed. The regexp command returns 1 if the
expression matches the string, 0 otherwise.  The optional `-nocase'
switch does matching without regard to the case of letters in the
string.  The optional MATCHVAR and SUBVAR variables, if present, are
set to the values of string matches. In the regular expression, a match
that is to be saved into a variable is enclosed in round braces.  An
example is

     regexp {([0-9]+)} "I have 3 oranges" a

will assign the value 3 to the variable `a'.

   If the optional switch `-indices' is present, instead of storing the
matching substrings in the variables, the indices of the substrings are
stored; that is a list with a pair of numbers denoting the start and
end position of the substring in the string.  Using the same example:

     regexp -indices {([0-9]+)} "I have 3 oranges" a

will assign the value `"7 7"', because the matched numeral `3' is in
the eighth position in the string, and indices count from 0.

   String matching using the UNIX-style wildcard pattern matching
technique is done through the `string match' command:

     string match PATTERN STRING

where PATTERN is a wildcard pattern and STRING is the string to match.
If the match succeeds, the command returns 1; otherwise, it returns 0.
An example is

     string match {[a-z]*[0-9]} {a_$%^_3}

which matches because the command says match any string that starts
with a lower case letter and ends with a number, regardless of anything
in between.

   There is a command for performing string substitutions using regular
expressions:

     regsub ?-all? ?-nocase? EXP STRING SUBSPEC VARNAME

where EXP is the regular expression and STRING is the input string on
which the substitution is made, SUBSPEC is the string that is
substituted for the part of the string matched by the regular
expression, and VARNAME is the variable on which the resulting string
is copied into.  With the `-nocase' switch, the matching is done
without regard to the case of letters in the input string.  The `-all'
switch causes repeated matching and substitution to happen on the input
string.  The result of a `regsub' command is the number of
substitutions made.

   An example of string substitution is:

     regsub {#name#} {My name is #name#} Rob result

which sets the variable `result' to the value "My name is Rob".  An
example of using the `-all' switch:

     regsub -all {#name#} {#name#'s name is #name#} Rob result

sets the variable `result' to the value "Rob's name is Rob" and it
returns the value 2 because two substitutions were made.

   The are a host of other ways to manipulate strings through variants
of the `string' command. Here we will go through them.

   To select a character from a string given the character position,
use the `string index' command. An example is:

     string index "Hello world" 6

which returns `w', the 7th character of the string.  (Strings are
indexed from 0).

   To select a substring of a string, given a range of indices use the
`string range' command. An example is:

     string range "Hello world" 3 7

which returns the string "lo wo".  There is a special index marker
named `end', which is used to denote the the end of a string, so the
code

     string range "Hello world" 6 end

will return the string "world".

   There are two ways to do simple search for a substring on a string,
using the `string first' and `string last' commands.  An example of
`string first' is:

     string first "dog" "My dog is a big dog"

find the first position in string "My dog is a big dog" that matches
"dog".  It will return the position in the string in which the
substring was found, in this case 3. If the substring cannot be found,
the value -1 is returned.

   Similarly,

     string last "dog" "My dog is a big dog"

will return the value 16 because it returns the index of the last place
in the string that the substring matches.  Again, if there is no match,
-1 is returned.

   To find the length of a string use `string length', which given a
string simply returns its length.

     string length "123456"

returns the value 6.

   To convert a string completely to upper case use `string toupper':

     string toupper "this is in upper case"

returns the string "THIS IS IN UPPER CASE".

   Similarly,

     string tolower "THIS IS IN LOWER CASE"

returns the string "this is in lower case".

   There are commands for removing characters from strings: `string
trim', `string trimright', and `string trimleft'.

     string trim STRING ?CHARS?

which removes the characters in the string CHARS from the string STRING
and returns the trimmed string.  If CHARS is not present, whitespace
characters are removed.  An example is:

     string string "The dog ate the exercise book" "doe"

which would return the string "Th g at th xrcis bk".

   `string trimleft' is the same as `string trim' except only leading
characters are removed. Similarly `string trimright' removes only
trailing characters.  For example:

     string trimright $my_input

would return a copy of the string contained in `$my_input' but with all
the trailing whitespace characters removed.

   There is a comprehensive set of commands for _file manipulation_.
We will cover only the some of the more important ones here.

   To open a file the `open' command is used:

     open NAME ?ACCESS?

where NAME is a string containing the filename, and the option ACCESS
parameter contains a string of access flags, in the UNIX style.  The
return result is a handle to the open file.

   If ACCESS is not present, the access permissions default to `"r"',
which means open for reading only.  The command returns a file handle
that can be used with other commands.  An example of the use of the
`open' command is

     set fid [open "myfile" "r+"]

which means open the file `myfile' for both reading and writing and set
the variable `fid' to the file handle returned.

   To close a file simply use

     close FILEID

   For example,

     close $fid

will close the file that has the file handle stored in the variable
`fid'.

   To read from a file, the `read' command is used:

     read FILEID NUMBYTES

which reads NUMBYTES bytes from the file attached to file handle
FILEID, and returns the bytes actually read.

   To read a single line from a file use `gets':

     gets FILEID ?VARNAME?

which reads a line from the file attached to file handle FILEID but
chops off the trailing newline. If variable VARNAME is specified, the
string read in is stored there and the number of bytes is returned by
the command. If the variable is not specified, the command returns the
string only.

   To write to a file, use `puts':

     puts ?-nonewline? ?FILEID? STRING

which outputs the string STRING. If the file handle FILEID is present,
the string is output to that file; otherwise, it is printed on
`stdout'.  If the switch `-nonewline' is present, a trailing newline is
not output.

   To check if the end of a file has been reached, use `eof':

     eof FILEID

which, given a file handle FILEID returns 1 if the end has been reached,
and 0 otherwise.

   The are a host of other commands over files and processes, which we
will not go into here.

   (For extra information on file I/O commands, refer to the Tcl manual
pages.)

   Tcl provides a way of _creating new commands_, called procedures,
that can be executed in scripts. The arguments of a procedure can be
call-by-value or call-by-reference, and there is also a facility for
creating new user defined control structures using procedures.

   A procedure is declared using the `proc' command:

     proc NAME ARGLIST BODY

where the name of the procedure is NAME, the arguments are contained in
ARGLIST and the body of the procedure is the script BODY.  An example
of a procedure is:

     proc namePrint { first family } {
         puts "My first name is $first"
         puts "My family name is $family"
     }

which can be called with

     namePrint Tony Blair

to produce the output:

     My first name is Tony
     My family name is Blair

   A procedure with no arguments is specified with an empty argument
list.  An example is a procedure that just prints out a string:

     proc stringThing {} {
         puts "I just print this string"
     }

   Arguments can be given defaults by pairing them with a value in a
list.  An example here is a counter procedure:

     proc counter { value { inc 1 } } {
         eval $value + $inc
     }

which can be called with two arguments like this

     set v 10
     set v [counter $v 5]

which will set variable `v' to the value 15; or it can be called with
one argument:

     set v 10
     set v [counter $v]

in which case `v' will have the value 11, because the default of the
argument `inc' inside the procedure is the value 1.

   There is a special argument for handling procedures with variable
number of arguments, the `args' argument.  An example is a procedure
that sums a list of numbers:

     proc sum { args } {
         set result 0;

         foreach n $args {
          set result [expr $result + $n ]
         }

         return $result;
     }

which can be called like this:

     sum 1 2 3 4 5

which returns the value 15.

   The restriction on using defaulted arguments is that all the
arguments that come after the defaulted ones must also be defaulted.
If `args' are used, it must be the last argument in the argument list.

   A procedure can return a value through the `return' command:

     return ?OPTIONS? ?VALUE?

which terminates the procedure returning value VALUE, if specified, or
just causes the procedure to return, if no value specified.  (The
?OPTIONS? part has to do with raising exceptions, which we will will
not cover here.)

   The return result of a user defined procedure is the return result
of the last command executed by it.

   So far we have seen the arguments of a procedure are passed using
the call-by-value mechanism.  They can be passed call by reference using
the `upvar' command:

     upvar ?LEVEL? OTHERVAR1 MYVAR1 ?OTHERVAR2 MYVAR2 ...?

which makes accessible variables somewhere in a calling context with the
current context. The optional argument LEVEL describes how many calling
levels up to look for the variable.  This is best shown with an example:

     set a 10
     set b 20

     proc add { first second } {
         upvar $first f $second s
         expr $f+$s
     }

which when called with

     add a b

will produce the result 30.  If you use call-by-value instead:

     add $a $b

the program will fail because when executing the procedure `add' it
will take the first argument 10 as the level argument, a bad level.
(Also variable `20' doesn't exist at any level.)

   New control structures can be generated using the `uplevel' command:

     uplevel ?LEVEL? ARG ?ARG ARG ...?

which is like `eval', but it evaluates its arguments in a context
higher up the calling stack. How far up the stack to go is given by the
optional LEVEL argument.

     proc do { loop condition } {
         set nostop 1

         while { $nostop } {
             uplevel $loop
             if {[uplevel "expr $condition"] == 0} {
                 set nostop 0
              }
         }
     }

which when called with this

     set x 5
     do { puts $x; incr x -1 } { $x > 0 }

will print

     5
     4
     3
     2
     1

   (*Please note*: this doesn't quite work for all kinds of calls
because of `break', `continue', and `return'. It is possible to get
around these problem, but that is outside the scope of this tutorial.)

   A word about the _scope of variables_. Variables used within
procedures are normally created only for the duration of that procedure
and have local scope.

   It is possible to declare a variable as having global scope, through
the `global' command:

     global NAME1 ? NAME2 ...?

where NAME1, NAME2, ..., are the names of global variables.  Any
references to those names will be taken to denote global variables for
the duration of the procedure call.

   Global variables are those variables declared at the topmost calling
context. It is possible to run a `global' command at anytime in a
procedure call. After such a command, the variable name will refer to a
global variable until the procedure exits.

   An example:

     set x 10

     proc fred { } {
         set y 20
         global x
         puts [expr $x + $y]
     }

     fred

will print the result `30' where 20 comes from the local variable `y'
and 10 comes from the global variable `x'.

   Without the `global x' line, the call to `fred' will fail with an
error because there is no variable `x' defined locally in the procedure
for the `expr' to evaluate over.

   In common with other scripting languages, there is a command for
_evaluating the contents of a file_ in the Tcl interpreter:

     source FILENAME

where FILENAME is the filename of the file containing the Tcl source to
be evaluated. Control returns to the Tcl interpreter once the file has
been evaluated.


File: sicstus.info,  Node: What We Have Left Out (Tcl),  Prev: Commands,  Up: Tcl

10.41.2.4 What We Have Left Out
...............................

We have left out a number of Tcl commands as they are outside of the
scope of this tutorial. We list some of them here to show some of what
Tcl can do. Please refer to the Tcl manual for more information.

"http"
     implements the HTTP protocol for retrieving web pages

"namespaces"
     a modules systems for Tcl

"trace"
     commands can be attached to variables that are triggered when the
     variable changes value (amongst other things)

"processes"
     start, stop, and manage processes

"sockets"
     UNIX and Internet style socket management

"exception handling"

"3rd party extension packages"
     load extension packages into Tcl and use their facilities as
     native Tcl commands


File: sicstus.info,  Node: Tk,  Next: The Tcl/Tk Prolog Library,  Prev: Tcl,  Up: lib-tcltk

10.41.3 Tk
----------

Tk is an extension to Tcl. It provides Tcl with commands for easily
creating and managing graphical objects, or widgets, so providing a way
to add graphical user interfaces (GUIs) to Tcl applications.

   In this section we will describe the main Tk widgets, the Tcl
commands used to manipulate them, how to give them behaviors, and
generally how to arrange them into groups to create a GUI.

* Menu:

* Widgets:: Widgets
* Types of Widget:: Types of Widget
* Widgets Hierarchies:: Widgets Hierarchies
* Widget Creation:: Widget Creation
* Geometry Managers:: Geometry Managers
* Event Handling:: Event Handling
* Miscellaneous:: Miscellaneous
* What We Have Left Out (Tk):: What We Have Left Out
* Queens Display:: Example pure Tcl/Tk program


File: sicstus.info,  Node: Widgets,  Next: Types of Widget,  Up: Tk

10.41.3.1 Widgets
.................

A widget is a "window object". It is something that is displayed that
has at least two parts: a state and a behavior.  An example of a widget
is a button.  Its state is things like what color is it, what text is
written it in, and how big it is.  Its behavior is things like what it
does when you click on it, or what happens when the cursor is moved
over or away from it.

   In Tcl/Tk there are three parts to creating a useful widget.  The
first is creating an instance of the widget with its initial state.
The second is giving it a behavior by defining how the widget behaves
when certain events happen -- event handling.  The third is actually
displaying the widget possibly in a group of widgets or inside another
widget -- geometry management.  In fact, after creating all the widgets
for a GUI, they are not displayed until handled by a geometry manager,
which has rules about how to calculate the size of the widgets and how
they will appear in relation to each other.


File: sicstus.info,  Node: Types of Widget,  Next: Widgets Hierarchies,  Prev: Widgets,  Up: Tk

10.41.3.2 Types of Widget
.........................

In Tcl/Tk there are currently 15 types of widget.  In alphabetical
order they are (see also `library('tcltk/examples/widgets.tcl')'):

`button'
     a simple press button

`canvas'
     is a container for displaying "drawn" objects such as lines,
     circles, and polygons.

`checkbutton'
     a button that hold a state of either on or off

`entry'
     a text entry field

`frame'
     a widget that is a container for other widgets

`label'
     a simple label

`listbox'
     a box containing a list of options

`menu'
     a widget for creating menu bars

`menubutton'
     a button, which when pressed offers a selection of choices

`message'
     a multi-line text display widget

`radiobutton'
     a button used to form groups of mutually interacting buttons (When
     one button is pressed down, the others pop up.)

`scale'
     is like a slider on a music console. It consists of a trough scale
     and a slider. Moving the slider to a position on the scale sets
     the overall value of the widget to that value.

`scollbar'
     used to add scrollbars to windows or canvases. The scrollbar has a
     slider, which when moved changes the value of the slider widget.

`text'
     a sophisticated multi-line text widget that can also display other
     widgets such as buttons

`toplevel'
     for creating new standalone toplevel windows. (These windows are
     containers for other widgets. They are not terminal windows.)


 [image src="images/tcltkwidgets.png" text="" ]                        Meet The Main Tk Widgets


File: sicstus.info,  Node: Widgets Hierarchies,  Next: Widget Creation,  Prev: Types of Widget,  Up: Tk

10.41.3.3 Widgets Hierarchies
.............................

Before going further it is necessary to understand how instances of
widgets are named.  Widgets are arranged in a hierarchy. The names of
widget instances are formed from dot separated words.  The root window
is simply `.' on its own.  So for, example, a button widget that is
displayed in the root window might have the name `.b1'.  A button that
is displayed inside a frame that is displayed inside the root window
may have the name `.frame1.b1'.  The frame would have the name
`.frame1'.

   Following this notation, it is clear that widgets are both formed in
hierarchies, with the dot notation giving the path to a widget, and in
groups, all widgets with the same leading path are notionaly in the
same group.

   (It is a similar to the way file systems are organized.   A file has
a path that shows where to find it in the hierarchical  file system.
But also files with the same leading path are in the same
directory/folder and so are notionaly grouped together.)

   An instance of a widget is created through the a Tcl command for that
widget.  The widget command my have optional arguments set for
specifying various attributes of the widget that it will have when it is
created.  The result of a successful widget command is the name of the
new widget.

   For example, a command to create a button widget named `.mybutton'
that displays the text "I am a button" would look like this:

     button .mybutton -text "I am a button"

and this will return the name `.mybutton'.

   A widget will only be created if all the windows/widgets in the
leading path of the new widget also exist, and also that the name of
the new widget does not already exist.

   For example, the following

     button .mybutton -text "I am a button"
     button .mybutton -text "and so am I"

will fail at the second command because there is also a widget named
`.mybutton' from the first command.

   The following will also fail

     button .frame.mybutton -text "I am a button"

if there is no existing widget with the name `.frame' to be the parent
of `.mybutton'.

   All this begs the question: why are widgets named and arranged in a
hierarchy? Isn't a GUI just a bunch of widgets displayed in a window?

   This is not generally how GUIs are arranged.  For example, they
often have a menubar over the top of each window.  The menubar contains
pulldown menus. The pulldown menus may have cascading menu items that
may cascade down several levels.  Under the menu bar is the main part
of the window that may also be split into several "frames". A left hand
frame my have a set of buttons in it, for example. And so on.  From
this you can see that the widgets in GUIs are naturally arranged in a
hierarchy. To achieve this in Tcl/Tk instances of widgets are placed in
a hierarchy, which is reflected in their names.

   Now we will go through each of the widget commands in turn.  Each
widget command has many options most of which will not be described
here. Just enough will be touched on for the reader to understand the
basic operation of each widget.  For a complete description of each
widget and its many options refer to the Tk manual.


File: sicstus.info,  Node: Widget Creation,  Next: Geometry Managers,  Prev: Widgets Hierarchies,  Up: Tk

10.41.3.4 Widget Creation
.........................

As has already been said, a widget is a window object that has state and
behavior. In terms of Tcl/Tk a widget is created by calling a widget
creation command. There is a specific widget creation for each type of
widget.

   The widget creation command is supplied with arguments.  The first
argument is always the name you want to give to the resulting widget;
the other arguments set the initial state of the widget.

   The immediate result of calling a widget creation command is that it
returns the name of the new widget. A side-effect is that the instance
of the widget is created and its name is defined as in the Tcl
interpreter as a procedure through which the widget state can be
accessed and manipulated.

   This needs an example. We will use the widget creator command
`button' to make a button widget:

     button .fred -text 'Fred' -background red

which creates an instance of a button widget named `.fred' that will
display the text `Fred' on the button and will have a red background
color. Evaluating this command returns the string `.fred', the name of
the newly created widget.

   As a side-effect, a Tcl procedure named `.fred' is created.  A call
to a widget instance has the following form:

     WIDGETNAME METHOD METHODARGS

where WIDGETNAME is the name of the widget to be manipulated, METHOD is
the action to be performed on the widget, and METHODARGS are the
arguments passed to the method that is performed on the widget.

   The two standard methods for widgets are `configure' and `cget'.
`configure' - is used to change the state of a widget; for example:

     .fred configure -background green -text 'Sid'

will change the background color of the widget `.fred' to green and the
text displayed to `Sid'.

   `cget' is used to get part of the state of a widget; for example:

     .fred cget -text

will return `Sid' if the text on the button `.fred' is `Sid'.

   In addition to these general methods, there are special methods for
each widget type. For example, with button widgets you have the `flash'
and `invoke' methods.

   For example,

     .fred invoke

can be called somewhere in the Tcl code to invoke button `.fred' as
though it had been clicked on.

     .fred flash

can be called somewhere in the Tcl code to cause the button to flash.

   We will come across some of these special method when we discuss the
widgets in detail. For a comprehensive list of widget methods, refer to
entry for the appropriate widget creation command in the Tcl/Tk manual.

   We now discuss the widget creation command for each widget type.

   A _label_ is a simple widget for displaying a single line of text.
An example of creating an instance of a label is

     label .l -text "Hello world!"

which simply creates the label named `.l' with the text `Hello world!'
displayed in it.  Most widgets that display text can have a variable
associated with them through the option `-textvariable'. When the value
of the variable is changed the text changes in the associated label.
For example,

     label .l -text "Hello world!" -textvariable mytext

creates a text label called `.l' displaying the initial text `Hello
world!'  and associated text variable `mytext'; `mytext' will start
with the value `Hello world!'.  However, if the following script is
executed:

     set mytext "Goodbye moon!"

the text in the label will magically change to `Goodbye moon!'.

   A _message widget_ is similar to a label widget but for multi-line
text.  As its name suggests it is mostly used for creating popup message
information boxes.

   An example of a message widget is

     message .msg -text "Your data is incorrect.\n\n \
                   Please correct it and try again." \
         -justify center

which will create a message widget displaying the text shown, center
justified.  The width of the message box can be given through the
`-width' switch.  Any lines that exceed the width of the box are
wrapped at word boundaries.

   Calling the `button' command creates an instance of a _button
widget_.  An example is:

     button .mybutton -text "hello" -command {puts "howdie!"}

which creates a button with name `.mybutton' that will display the text
"hello" and will execute the Tcl script `puts "howdie!"' (that is print
`howdie!' to the terminal) when clicked on.

   _Checkbuttons_ are buttons that have a fixed state that is either on
or off. Clicking on the button toggles the state.  To store the state,
a checkbutton is associated with a variable.  When the state of the
checkbutton changes, so does that of the variable.  An example is:

     checkbutton .on_or_off -text "I like ice cream" -variable ice

which will create a checkbutton with name `.on_or_off' displaying the
text `I like ice cream' and associated with the variable `ice'.  If the
checkbutton is checked, `ice' will have the value 1; if not checked, it
will have the value 0.  The state of the checkbutton can also be
changed by changing the state of the variable. For example, executing

     set ice 0

will set the state of `.on_or_off' to not checked.

   _Radiobuttons_ are buttons that are grouped together to select one
value among many. Each button has a value, but only one in the button
group is active at any one time.  In Tcl/Tk this is achieved by
creating a series of radiobutton that share an associated variable.
Each button has a value. When a radiobutton is clicked on, the variable
has that value and all the other buttons in the group are put into the
off state.  Similarly, setting the value of the variable is reflected
in the state of the button group.  An example is:

     radiobutton .first -value one -text one -variable count
     radiobutton .second -value two -text two -variable count
     radiobutton .third -value three -text three -variable count

which creates three radiobuttons that are linked through the variable
`count'. If button `.second' is active, for example, the other two
buttons are in the inactive state and `count' has the value `two'.  The
following code sets the button group to make the button `.third' active
and the rest inactive regardless of the current state:

     set count three

   If the value of `count' does not match any of the values of the
radiobuttons, they will all be off. For example executing the script

     set count four

will turn all the radiobuttons off.

   An _entry widget_ allows input of a one line string.  An example of
an entry widget:

     label .l -text "Enter your name"
     entry .e -width 40 -textvariable your_name

would display a label widget named `.l' showing the string `Enter your
name' and an entry widget named `.e' of width 40 characters.  The value
of variable `your_name' will reflect the string in the entry widget: as
the entry widget string is updated, so is the value of the variable.
Similarly, changing the value of `your_name' in a Tcl script will
change the string displayed in the entry field.

   A _scale widget_ is for displaying an adjustable slider.  As the
slider is moved its value, which is displayed next to the slider,
changes.  To specify a scale, it must have `-from' and `-to' attributes,
which is the range of the scale. It can have a `-command' option, which
is set to a script to evaluate when the value of the slider changes.

   An example of a scale widget is:

     scale .s -from 0 -to 100

which creates a scale widget with name `.s' that will slide over a
range of integers from 0 to 100.

   There are several other options that scales can have.  For example
it is possible to display tick marks along the length of the scale
through the `-tickinterval' attribute, and it is possible to specify
both vertically and horizontally displayed scales through the `-orient'
attribute.

   A _listbox_ is a widget that displays a list of single line strings.
One or more of the strings may be selected through using the mouse.
Initializing and manipulating the contents of a listbox is done through
invoking methods on the instance of the listbox.  As examples, the
`insert' method is used to insert a string into a listbox, `delete' to
delete one, and `get' to retrieve a particular entry. Also the
currently selected list items can be retrieved through the `selection'
command.

   Here is an example of a listbox that is filled with entries of the
form `entry N':

     listbox .l
     for { set i 0 } { $i<10 } { incr i } {
         .l insert end "entry $i"
     }

   A listbox may be given a height and/or width attribute, in which
case it is likely that not all of the strings in the list are visible
at the same time. There are a number of methods for affecting the
display of such a listbox.

   The `see' method causes the listbox display to change so that a
particular list element is in view.  For example,

     .l see 5

will make sure that the sixth list item is visible. (List elements are
counted from element 0.)

   A _scrollbar_ widget is intended to be used with any widget that is
likely to be able to display only part of its contents at one time.
Examples are listboxes, canvases, text widgets, and frames, amongst
others.

   A scrollbar widget is displayed as a movable slider between two
arrows.  Clicking on either arrow moves the slider in the direction of
the arrow.  The slider can be moved by dragging it with the cursor.

   The scollbar and the widget it scrolls are connected through Tcl
script calls. A scrollable widgets will have a `scrollcommand'
attribute that is set to a Tcl script to call when the widget changes
its view. When the view changes the command is called, and the command
is usually set to change the state of its associated scrollbar.

   Similarly, the scrollbar will have a `command' attribute that is
another script that is called when an action is performed on the
scrollbar, like moving the slider or clicking on one of its arrows.
That action will be to update the display of the associated scrollable
widget (which redraws itself and then invokes its `scrollcommand',
which causes the scrollbar to be redrawn).

   How this is all done is best shown through an example:

     listbox .l -yscrollcommand ".s set" -height 10
     scrollbar .s -command ".l yview"
     for { set i 0 } { $i < 50 } { incr i } {
         .l insert end "entry $i"
     }

creates a listbox named `.l' and a scrollbar named `.s'. Fifty strings
of the form `entry N' are inserted into the listbox.  The clever part
is the way the scrollbar and listbox are linked.  The listbox has its
`-yscrollcommand' attribute set to the script `".s set"'. What happens
is that if the view of `.l' is changed, this script is called with 4
arguments attached: the number of entries in the listbox, the size of
the listbox window, the index of the first entry currently visible, and
the index of the last entry currently visible. This is exactly enough
information for the scrollbar to work out how to redisplay itself.  For
example, changing the display of the above listbox could result in the
following `-yscrollcommand' script being called:

     .s set 50 10 5 15

which says that the listbox contains 50 elements, it can display 10 at
one time, the first element displayed has index 5 and the last one on
display has index 15. This call invokes the `set' method of the
scrollbar widget `.s', which causes it to redraw itself appropriately.

   If, instead, the user interacts with the scrollbar, the scrollbar
will invoke its `-command' script, which in this example is `".l
yview"'. Before invoking the script, the scrollbar widget calculates
which element should the first displayed in its associated widget and
appends its index to the call.  For example, if element with index 20
should be the first to be displayed, the following call will be made:

     .l yview 20

which invokes the `yview' method of the listbox `.l'. This causes `.l'
to be updated (which then causes its `-yscrollcommand' to be called,
which updates the scrollbar).

   A _frame_ widget does not do anything by itself except reserve an
area of the display.  Although this does not seem to have much purpose,
it is a very important widget.  It is a container widget; that is, it
is used to group together collections of other widgets into logical
groups. For example, a row of buttons may be grouped into a frame, then
as the frame is manipulated so will the widgets displayed inside it.  A
frame widget can also be used to create large areas of color inside
another container widget (such as another frame widget or a toplevel
widget).

   An example of the use of a frame widget as a container:

     canvas .c -background red
     frame .f
     button .b1 -text button1
     button .b2 -text button2
     button .b3 -text button3
     button .b4 -text button4
     button .b5 -text button5
     pack .b1 .b2 .b3 .b4 .b5 -in .f -side left
     pack .c -side top -fill both -expand 1
     pack .f -side bottom

which specifies that there are two main widgets a canvas named `.c' and
a frame named `.f'. There are also 5 buttons, `.b1' through `.b5'.  The
buttons are displayed inside the frame. Then the canvas is displayed at
the top of the main window and the frame is displayed at the bottom. As
the frame is displayed at the bottom, then so will the buttons because
they are displayed inside the frame.

   (The `pack' command causes the widgets to be handled for display by
the packer geometry manager.  The `-fill' and `-expand 1' options to
pack for `.c' tell the display manager that if the window is resized,
the canvas is to expand to fill most of the window. You will learn
about geometry managers later in the Geometry Managers section.)

   A _toplevel_ widget is a new toplevel window.  It is a container
widget inside which other widgets are displayed.  The root toplevel
widget has path `.' -- i.e. dot on its own.  Subsequent toplevel widgets
must have a name that is lower down the path tree just like any other
widget.

   An example of creating a toplevel widget is:

     toplevel .t

   All the widgets displayed inside `.t' must also have `.t' as the
root of their path.  For example, to create a button widget for display
inside the `.t' toplevel the following would work:

     button .t.b -text "Inside 't'"

   (Attributes, such as size and title, of toplevel widgets can be
changed through the `wm' command, which we will not cover in this
tutorial. The reader is referred to the Tk manual.)

   Yet another kind of container is a _menu widget_.  It contains a
list of widgets to display inside itself, as a pulldown menu.  A simple
entry in a menu widget is a `command' widget, displayed as an option in
the menu widget, which if chosen executes a Tcl command.  Other types of
widgets allowed inside a menu widget are radiobuttons and checkboxes.  A
special kind of menu item is a `separator' that is used to group
together menu items within a menu.  (It should be noted that the widgets
inside a menu widget are special to that menu widget and don't have an
independent existence, and so don't have their own Tk name.)

   A menu widget is built by first creating an instance of a menu
widget (the container) and then invoking the `add' method to make
entries into the menu.  An example of a menu widget is as follows:

     menu .m
     .m add command -label "Open file" -command "open_file"
     .m add command -label "Open directory" -command "open_directory"
     .m add command -label "Save buffer" -command "save_buffer"
     .m add command -label "Save buffer as..." -command "save_buffer_as"
     .m add separator
     .m add command -label "Make new frame" -command "new_frame"
     .m add command -label "Open new display" -command "new_display"
     .m add command -label "Delete frame" -command "delete_frame"

which creates a menu widget called `.m', which contains eight menu
items, the first four of which are commands, then comes a separator
widget, then the final three command entries.  (Some of you will notice
that this menu is a small part of the `Files' menu from the menubar of
the Emacs text editor.)

   An example of a checkbox and some radiobutton widget entries:

     .m add checkbox -label "Inverse video" -variable inv_vid
     .m add radiobutton -label "black" -variable color
     .m add radiobutton -label "blue" -variable color
     .m add radiobutton -label "red" -variable color

which gives a checkbox displaying `Inverse video', keeping its state in
the variable `inv_vid', and three radiobuttons linked through the
variable `color'.

   Another menu item variant is the `cascade' variant, which is used to
make cascadable menus, i.e. menus that have submenus.  An example of a
cascade entry is the following:

     .m add cascade -label "I cascade" -menu .m.c

which adds a cascade entry to the menu `.m' that displays the text `I
cascade'.  If the `I cascade' option is chosen from the `.m' menu then
the menu `.m.c' will be displayed.

   The cascade option is also used to make menubars at the top of an
application window.  A menu bar is simply a menu each element of which
is a cascade entry, (for example). The menubar menu is attached to the
application window through a special configuration option for toplevel
widgets, the `-menu' option.  Then a menu is defined for each of the
cascade entry in the menubar menu.

   There are a large number of other variants to menu widgets: menu
items can display bitmaps instead of text; menus can be specified as
tear-off menus; accelerator keys can be defined for menu items; and so
on.

   A _menubutton widget_ displays like a button, but when activated a
menu pops up. The menu of the menubutton is defined through the `menu'
command and is attached to the menubutton.  An example of a menu button:

     menubutton .mb -menu .mb.m -text "mymenu"
     menu .mb.m
     .mb.m add command -label hello
     .mb.m add command -label goodbye

which crates a menubutton widget named `.mb' with attached menu `.mb.m'
and displays the text `mymenu'.  Menu `.mb.m' is defined as two command
options, one labelled `hello' and the other labelled `goodbye'.  When
the menubutton `.mb' is clicked on, the menu `.mb.m' will popup and its
options can be chosen.

   A _canvas widget_ is a container widget that is used to manage the
drawing of complex shapes; for example, squares, circles, ovals, and
polygons.  (It can also handle bitmaps, text and most of the Tk widgets
too.)  The shapes may have borders, filled in, be clicked on, moved
around, and manipulated.

   We will not cover the working of the canvas widget here.  It is
enough to know that there is a powerful widget in the Tk toolkit that
can handle all manner of graphical objects.  The interested reader is
referred to the Tk manual.

   A _text widget_ is another powerful container widget that handles
multi-line texts. The textwidget can display texts with varying font
styles, sizes, and colors in the same text, and can also handle other
Tk widgets embedded in the text.

   The text widget is a rich and complicated widget and will not be
covered here.  The interested reader is referred to the Tk manual.


File: sicstus.info,  Node: Geometry Managers,  Next: Event Handling,  Prev: Widget Creation,  Up: Tk

10.41.3.5 Geometry Managers
...........................

So far we have described each of the Tk widgets but have not mentioned
how they are arranged to be displayed.  Tk separates the creating of
widgets from the way they are arranged for display. The "geometry" of
the display is handled by a "geometry manager".  A geometry manager is
handed the set of widgets to display with instructions on their layout.
The layout instructions are particular to each geometry manager.

   Tk comes with three distinct geometry managers: `grid', `place', and
`pack'.  As might be expected the `grid' geometry manager is useful for
creating tables of widgets, for example, a table of buttons.

   The `place' geometry manager simply gives each widget an X and Y
coordinate and places them at that coordinate in their particular parent
window.

   The `pack' geometry manager places widgets according to constraints,
like "these three button widgets should be packed together from the
left in their parent widget, and should resize with the parent".

   (In practice the `grid' and `pack' geometry managers are the most
useful because they can easily handle events such as resizing of the
toplevel window, automatically adjusting the display in a sensible
manner.  `place' is not so useful for this.)

   Each container widget (the master) has a geometry manager associated
with it, which tells the container how to display its sub-widgets
(slaves) inside it. A single master has one and only one kind of
geometry manager associated with it, but each master can have a
different kind.  For example, a frame widget can use the packer to pack
other frames inside it. One of the slave frames could use the grid
manager to display buttons inside it itself, while another slave frame
could use the packer to pack labels inside it itself.

   The problem is how to display widgets. For example, there is an empty
frame widget inside which a bunch of other widgets will be displayed.
The `pack' geometry manager's solution to this problem is to
successively pack widgets into the empty space left in the container
widget.  The container widget is the master widget, and the widgets
packed into it are its slaves.  The slaves are packed in a sequence: the
packing order.

   What the packer does is to take the next slave to be packed.  It
allocates an area for the slave to be packed into from the remaining
space in the master. Which part of the space is allocated depends on
instructions to the packer. When the size of the space has been
determined, this is sliced off the free space, and allocated to the
widget that is displayed in it.  Then the remaining space is available
to subsequent slaves.

   At any one time the space left for packing is a rectangle.  If the
widget is too small to use up a whole slice from the length or breadth
of the free rectangle, still a whole slice is allocated so that the
free space is always rectangular.

   It can be tricky to get the packing instructions right to get the
desired finished effect, but a large number of arrangements of widgets
is possible using the packer.

   Let us take a simple example: three buttons packed into the root
window.  First we create the buttons; see also
`library('tcltk/examples/ex3.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3

then we can pack them thus:

     pack .b1 .b2 .b3

which produces a display of the three buttons, one on top of the other,
button `.b1' on the top, and button `.b3' on the bottom.


 [image src="images/tcltkex3.png" text="" ]                           Three Plain Buttons

If we change the size of the text in button `.b2' through the command:

     .b2 config -text "hello world"

then we see that the window grows to fit the middle button, but the
other two buttons stay their original size.


 [image src="images/tcltkex4.png" text="" ]                          Middle Button Widens

The packer defaults to packing widgets in from the top of the master.
Other directions can be specified.  For example, the command:

     pack .b1 .b2 .b3 -side left

will pack starting at the left hand side of the window.  The result of
this is that the buttons are formed in a horizontal row with the wider
button, `.b2', in the middle.


 [image src="images/tcltkex5.png" text="" ]                          Packing From The Left

It is possible to leave space between widgets through the _padding_
options to the packer: `-padx' and `-pady'.  What these do is to
allocate space to the slave that is padded with the padding distances.
An example would be:

     pack .b1 .b2 .b3 -side left -padx 10


 [image src="images/tcltkex6.png" text="" ]                            External Padding

which adds 10 pixels of space to either side of the button widgets.
This has the effect of leaving 10 pixels at the left side of button
`.b1', 20 pixels between buttons `.b1' and `.b2', 20 pixels between
buttons `.b2' and `.b3', and finally 10 pixels on the right side of
button `.b3'.

   That was external padding for spacing widgets.  There is also
internal padding for increasing the size of widgets in the X and Y
directions by a certain amount, through `-ipadx' and `-ipady' options;
i.e. internal padding.  For example:

     pack .b1 .b2 .b3 -side left -ipadx 10 -ipady 10


 [image src="images/tcltkex7.png" text="" ]                            Internal Padding

instead of spacing out the widgets, will increase their dimensions by
10 pixels in each direction.

   Remember that space is allocated to a widget from the currently
available space left in the master widget by cutting off a complete
slice from that space. It is often the case that the slice is bigger
that the widget to be displayed in it.

   There are further options for allowing a widget to fill the whole
slice allocated to it.  This is done through the `-fill' option, which
can have one of four values: `none' for no filling (default), `x' to
fill horizontally only, `y' to fill vertically only, and `both' to fill
both horizontally and vertically at the same time.

   Filling is useful, for example, for creating buttons that are the
same size even though they display texts of differing lengths.  To take
our button example again, the following code produces three buttons,
one on top of each other, but of the same size:

     button .b1 -text b1
     button .b2 -text "hello world"
     button .b3 -text b3
     pack .b1 .b2 .b3 -fill x


 [image src="images/tcltkex8.png" text="" ]                  Using `fill' For Evenly Sized Widgets

How does this work? The width of the toplevel windows is dictated by
button `.b2' because it has the widest text. Because the three buttons
are packed from top to bottom, the slices of space allocated to them
are cut progressively straight along the top of the remaining space.
i.e. each widget gets a horizontal slice of space the same width cut
from the top-level widget.  Only the wide button `.b2' would normally
fit the whole width of its slice.  But by allowing the other two
widgets to fill horizontally, they will also take up the whole width of
their slices.  The result: 3 buttons stacked on top of each other, each
with the same width, although the texts they display are not the same
length.

   A further common example is adding a scrollbar to a listbox.  The
trick is to get the scrollbar to size itself to the listbox; see also
`library('tcltk/examples/ex9a.tcl')':

     listbox .l
     scrollbar .s
     pack .l .s -side left


 [image src="images/tcltkex9a.png" text="" ]                    Scrollbar With Listbox, First Try

So far we have a listbox on the left and a tiny scrollbar on the right.
To get the scrollbar to fill up the vertical space around it add the
following command:

     pack .s -fill y

   Now the display looks like a normal listbox with a scrollbar.


 [image src="images/tcltkex9b.png" text="" ]                   Scrollbar With Listbox, Second Try

Why does this work? They are packed from the left, so first a large
vertical slice of the master is given to the listbox, then a thin
vertical slice is given to the scrollbar. The scrollbar has a small
default width and height and so it does not fill the vertical space of
its slice. But filling in the vertical direction (through the `pack .s
-fill y' command) allows it to fill its space, and so it adjusts to the
height of the listbox.

   The `fill' packing option specifies whether the widget should fill
space left over in its slice of space.  A further option to take into
account is what happens when the space allocated to the master widget is
much greater than the that used by its slaves.  This is not usually a
problem initially because the master container widget is sized to
shrink-wrap around the space used by its slaves.  If the container is
subsequently resized, however, to a much larger size there is a question
as to what should happen to the slave widgets.  A common example of
resizing a container widget is the resizing of a top-level window
widget.

   The default behavior of the packer is not to change the size or
arrangement of the slave widgets. There is an option though through the
`expand' option to cause the slices of space allocated to slaves to
expand to fill the newly available space in the master.  `expand' can
have one of two values: `0' for no expansion, and `1' for expansion.

   Take the listbox-scrollbar example; see also
`library('tcltk/examples/ex10.tcl')':

     listbox .l
     scrollbar .s
     pack .l -side left
     pack .s -side left -fill y

   Initially this looks good, but now resize the window to a much bigger
size.  You will find that the listbox stays the same size and that empty
space appears at the top and bottom of it, and that the scrollbar
resizes in the vertical. It is now not so nice.


 [image src="images/tcltkex10.png" text="" ]              Scrollbar And Listbox, Problems With Resizing

We can fix part of the problem by having the listbox expand to fill the
extra space generated by resizing the window.

     pack .l -side left -expand 1


 [image src="images/tcltkex10a.png" text="" ]                   Scrollbar And Listbox, Almost There

The problem now is that `expand' just expands the space allocated to
the listbox, it doesn't stretch the listbox itself. To achieve that we
need to apply the `fill' option to the listbox too.

     pack .l -side left -expand 1 -fill both


 [image src="images/tcltkex10b.png" text="" ]           Scrollbar And Listbox, Problem Solved Using `fill'

Now whichever way the top-level window is resized, the listbox-scrollbar
combination should look good.

   If more than one widget has the expansion bit set, the space is
allocated equally to those widgets. This can be used, for example, to
make a row of buttons of equal size that resize to fill the widget of
their container.  Try the following code; see also
`library('tcltk/examples/ex11.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1


 [image src="images/tcltkex11.png" text="" ]                      Resizing Evenly Sized Widgets

Now resize the window. You will see that the buttons resize to fill the
width of the window, each taking an equal third of the width.

     *Please note*: the best way to get the hang of the packer is to
     play with it. Often the results are not what you expect,
     especially when it comes to fill and expand options. When you have
     created a display that looks pleasing, always try resizing the
     window to see if it still looks pleasing, or whether some of your
     fill and expand options need revising.

   There is an option to change how a slave is displayed if its
allocated space is larger than itself. Normally it will be displayed
centered. That can be changed by anchoring it with the `-anchor'
option. The option takes a compass direction as its argument: `n', `s',
`e', `w', `nw', `ne', `sw', `se', or `c' (for center).

   For example, the previous example with the resizing buttons displays
the buttons in the center of the window, the default anchoring point.
If we wanted the buttons to be displayed at the top of the window, we
would anchor them there thus; see also
`library('tcltk/examples/ex12.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1 -anchor n


 [image src="images/tcltkex12.png" text="" ]                            Anchoring Widgets

Each button is anchored at the top of its slice and so in this case is
displayed at the top of the window.

   The packing order of widget can also be changed. For example,

     pack .b3 -before .b2

will change the positions of `.b2' and `.b3' in our examples.


 [image src="images/tcltkex13.png" text="" ]                  Changing The Packing Order Of Widgets

The _grid geometry manager_ is useful for arranging widgets in grids or
tables.  A grid has a number of rows and columns and a widget can occupy
one of more adjacent rows and columns.

   A simple example of arranging three buttons; see also
`library('tcltk/examples/ex14.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0
     grid .b2 -row 1 -column 0
     grid .b3 -row 0 -column 1 -rowspan 2

this will display button `.b1' above button `.b2'. Button `.b3' will be
displayed in the next column and it will take up two rows.


 [image src="images/tcltkex14.png" text="" ]                    Using the `grid' Geometry Manager

However, `.b3' will be displayed in the center of the space allocated
to it. It is possible to get it to expand to fill the two rows it has
using the `-sticky' option. The `-sticky' option says to which edges of
its cells a widget "sticks" to, i.e. expands to reach.  (This is like
the fill and expand options in the pack manager.)  So to get `.b3' to
expand to fill its space we could use the following:

     grid .b3 -sticky ns

which says stick in the north and south directions (top and bottom).
This results in `.b3' taking up two rows and filling them.


 [image src="images/tcltkex15.png" text="" ]            `grid' Geometry Manager, Cells With Sticky Edges

There are plenty of other options to the grid geometry manager.  For
example, it is possible to give some rows/columns more "weight" than
others, which gives them more space in the master.  For example, if in
the above example you wanted to allocate 1/3 of the width of the master
to column 0 and 2/3 of the width to column 1, the following commands
would achieve that:

     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

which says that the weight of column 0 for master `.' (the root window)
is 1 and the weight of column 1 is 2. Since column 1 has more weight
than column 0 it gets proportionately more space in the master.

   It may not be apparent that this works until you resize the window.
You can see even more easily how much space is allocated to each button
by making expanding them to fill their space through the sticky option.
The whole example looks like this; see also
`library('tcltk/examples/ex16.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0 -sticky nsew
     grid .b2 -row 1 -column 0 -sticky nsew
     grid .b3 -row 0 -column 1 -rowspan 2 -sticky nsew
     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

   Now resize the window to various sizes and we will see that button
`.b3' has twice the width of buttons `.b1' and `.b2'.


 [image src="images/tcltkex16.png" text="" ]                       Changing Row/Column Ratios

The same kind of thing can be specified for each row too via the `grid
rowconfigure' command.

   For other options and a full explanation of the grid manager see the
manual.

   `place' simply places the slave widgets in the master at the given x
and y coordinates. It displays the widgets with the given width and
height. For example (see also `library('tcltk/examples/ex17.tcl')'):

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     place .b1 -x 0 -y 0
     place .b2 -x 100 -y 100
     place .b3 -x 200 -y 200


 [image src="images/tcltkex17.png" text="" ]                   Using The `place' Geometry Manager

will place the buttons `.b1', `.b2', and `.b3' along a diagonal 100
pixels apart in both the x and y directions.  Heights and widths can be
given in absolute sizes, or relative to the size of the master in which
case they are specified as a floating point proportion of the master;
0.0 being no size and 1.0 being the size of the master.  x and y
coordinates can also be specified in a relative way, also as a floating
point number. For example, a relative y coordinate of 0.0 refers to the
top edge of the master, while 1.0 refers to the bottom edge.  If both
relative and absolute x and y values are specified, they are summed.

   Through this system the placer allows widgets to be placed on a kind
of rubber sheet. If all the coordinates are specified in relative
terms, as the master is resized then so will the slaves move to their
new relative positions.


File: sicstus.info,  Node: Event Handling,  Next: Miscellaneous,  Prev: Geometry Managers,  Up: Tk

10.41.3.6 Event Handling
........................

So far we have covered the widgets types, how instances of them are
created, how their attributes can be set and queried, and how they can
be managed for display using geometry managers.  What we have not
touched on is how to give each widget a behavior.

   This is done through event handlers.  Each widget instance can be
given a window event handler for each kind of window event.  A window
event is something like the cursor moving into or out of the widget, a
key press happening while the widget is active (in focus), or the widget
being destroyed.

   Event handlers are specified through the `bind' command:

     bind WIDGETNAME EVENTSEQUENCE COMMAND

where WIDGETNAME is the name or class of the widget to which the event
handler should be attached, EVENTSQUEUENCE is a description of the
event that this event handler will handle, and COMMAND is a script that
is invoked when the event happens (i.e. it is the event handler).

   Common event types are

`Key'
`KeyPress'
     when a key was pressed

`KeyRelease'
     when a key was released

`Button'
`ButtonPress'
     when a mouse button was pressed

`ButtonRelease'
     when a mouse button was released

`Enter'
     when the cursor moves into a widget

`Leave'
     when the cursor moved our of a widget

`Motion'
     when the cursor moves within a widget

   There are other event types. Please refer to the Tk documentation for
a complete list.

   The EVENTSEQUENCE part of a `bind' command is a list of one or more
of these events, each event surrounded by angled brackets. (Mostly, an
event sequence consists of handling a single event. Later we will show
more complicated event sequences.)

   An example is the following:

     button .b -text "click me"
     pack .b
     bind .b <Enter> { puts "entering .b" }

makes a button `.b' displaying text `click me' and displays it in the
root window using the packing geometry manager. The `bind' command
specifies that when the cursor enters (i.e. goes onto) the widget, then
the text `entering .b' is printed at the terminal.

   We can make the button change color as the cursor enters or leaves
it like this:

     button .b -text "click me" -background red
     pack .b
     bind .b <Enter> { .b config -background blue }
     bind .b <Leave> { .b config -background red }

which causes the background color of the button to change to blue when
the cursor enters it and to change back to red when the cursor leaves.

   An action can be appended to an event handler by prefixing the
action with a `+' sign. An example is:

     bind .b <Enter> {+puts "entering .b"}

which, when added to the example above, would not only change the color
of the button to red when the cursor enters it, but would also print
`entering .b' to the terminal.

   A binding can be revoked simply by binding the empty command to it:

     bind .b <Enter> {}

   A list of events that are bound can be found by querying the widget
thus:

     bind .b

which will return a list of bound events.

   To get the current command(s) bound to an event on a widget, invoke
`bind' with the widget name and the event. An example is:

     bind .b <Enter>

which will return a list of the commands bound to the event <Enter> on
widget `.b'.

   Binding can be generalized to sequences of events.  For example, we
can create an entry widget that prints `spells rob' each time the key
sequence `ESC r o b' happens:

     entry .e
     pack .e
     bind .e <Escape>rob {puts "spells rob"}

   (A letter on its own in an event sequence stands for that key being
pressed when the corresponding widget is in focus.)

   Events can also be bound for entire classes of widgets.  For
example, if we wanted to perform the same trick for ALL entry widgets
we could use the following command:

     bind entry <Escape>rob {puts "spells rob"}

   In fact, we can bind events over all widgets using `all' as the
widget class specifier.

   The event script can have substitutions specified in it.  Certain
textual substitutions are then made at the time the event is processed.
For example, `%x' in a script gets the x coordinate of the mouse
substituted for it. Similarly, `%y' becomes the y coordinate, `%W' the
dot path of the window on which the event happened, `%K' the keysym of
the button that was pressed, and so on.  For a complete list, see the
manual.

   In this way it is possible to execute the event script in the context
of the event.

   A clever example of using the `all' widget specifier and text
substitutions is given in John Ousterhout's book on Tcl/Tk (*note
Resources::):

     bind all <Enter> {puts "Entering %W at (%x, %y)"}
     bind all <Leave> {puts "Leaving %W at (%x, %y)"}
     bind all <Motion> {puts "Pointer at (%x, %y)"}

which implements a mouse tracker for all the widgets in a Tcl/Tk
application.  The widget's name and x and y coordinates are printed at
the terminal when the mouse enters or leaves any widget, and also the x
and y coordinates are printed when the mouse moves within a widget.


File: sicstus.info,  Node: Miscellaneous,  Next: What We Have Left Out (Tk),  Prev: Event Handling,  Up: Tk

10.41.3.7 Miscellaneous
.......................

There are a couple of other Tk commands that we ought to mention:
`destroy' and `update'.

   The `destroy' command is used to destroy a widget, i.e. remove it
from the Tk interpreter entirely and so from the display.  Any children
that the widget may have are also `destroy'-ed.  Anything connected to
the destroyed widget, such as bindings, are also cleaned up
automatically.

   For example, to create a window containing a button that is
destroyed when the button is pressed:

     button .b -text "Die!" -command { destroy . }
     pack .b

creates a button `.b' displaying the text `Die!', which runs the
command `destroy .' when it is pressed. Because the widget `.' is the
main toplevel widget or window, running that command will kill the
entire application associated with that button.

   The command `update' is used to process any pending Tk events.  An
event is not just such things as moving the mouse but also updating the
display for newly created and displayed widgets.  This may be necessary
in that usually Tk draws widgets only when it is idle. Using the
`update' command forces Tk to stop and handle any outstanding events
including updating the display to its actually current state, i.e.
flushing out the pending display of any widgets.  (This is analogous to
the `fflush' command in C that flushes writes on a stream to disk. In
Tk displaying of widgets is "buffered"; calling the `update' command
flushes the buffer.)


File: sicstus.info,  Node: What We Have Left Out (Tk),  Next: Queens Display,  Prev: Miscellaneous,  Up: Tk

10.41.3.8 What We Have Left Out
...............................

There are a number of Tk features that we have not described but we
list some of them here in case the reader is interested.  Refer to the
Tk manual for more explanation.

`photo'
     creating full color images through the  command

`wm'
     setting and getting window attributes

selection and focus commands

modal interaction
     (not recommended)

`send'
     sending messages between Tk applications


File: sicstus.info,  Node: Queens Display,  Prev: What We Have Left Out (Tk),  Up: Tk

10.41.3.9 Example pure Tcl/Tk program
.....................................

To show some of what can be done with Tcl/Tk, we will show an example of
part of a GUI for an 8-queens program.  Most people will be familiar
with the 8-queens problem: how to place 8 queens on a chess board such
that they don't attack each other according to the normal rules of
chess.

   Our example will not be a program to solve the 8-queens problem
(that will come later in the tutorial) but just the Tcl/Tk part for
displaying a solution.  The code can be found in
`library('tcltk/examples/ex18.tcl')'.

   The way an 8-queens solution is normally presented is as a list of
numbers. The position of a number in the list indicates the column the
queens is placed at and the number itself indicates the row. For
example, the Prolog list `[8, 7, 6, 5, 4, 3, 2, 1]' would indicate 8
queens along the diagonal starting a column 1, row 8 and finishing at
column 8 row 1.

   The problem then becomes, given this list of numbers as a solution,
how to display the solution using Tcl/Tk. This can be divided into two
parts: how to display the initial empty chess board, and how to display
a queen in one of the squares.

   Here is our code for setting up the chess board:

                                                            _% ex18.pl_
     #! /usr/bin/wish

     proc setup_board { } {
         # create container for the board
         frame .queens

         # loop of rows and columns
         for {set row 1} {$row <= 8} {incr row} {
             for {set column 1} {$column <= 8} {incr column} {

                 # create label with a queen displayed in it
                 label .queens.$column-$row -bitmap @bitmaps/q64s.bm -relief flat

                 # choose a background color depending on the position of the
                 # square; make the queen invisible by setting the foreground
                 # to the same color as the background
                 if { [expr ($column + $row) % 2] } {
                     .queens.$column-$row config -background #ffff99
                     .queens.$column-$row config -foreground #ffff99
                 } else {
                     .queens.$column-$row config -background #66ff99
                     .queens.$column-$row config -foreground #66ff99
                 }

                 # place the square in a chess board grid
                 grid .queens.$column-$row -row $row -column $column -padx 1 -pady 1
             }
         }
         pack .queens
     }

     setup_board

   The first thing that happens is that a frame widget is created to
contain the board.  Then there are two nested loops that loop over the
rows and columns of the chess board.  Inside the loop, the first thing
that happens is that a label widget is created. It is named using the
row and column variables so that it can be easily referenced later.  The
label will not be used to display text but to display an image, a bitmap
of a queen. The label creation command therefore has the special
argument `-bitmap @q64s.bm', which says that the label will display the
bitmap loaded from the file `q64s.bm'.

   The label with the queen displayed in it has now been created.  The
next thing that happens is that the background color of the label
(square) is chosen. Depending on the position of the square it becomes
either a "black" or a "white" square.  At the same time, the foreground
color is set to the background color.  This is so that the queen
(displayed in the foreground color) will be invisible, at least when
the board is first displayed.

   The final action in the loop is to place the label (square) in
relation to all the other squares for display. A chess board is a
simple grid of squares, and so this is most easily done through the
`grid' geometry manager.

   After the board has been set up square-by-square it still needs to
be displayed, which is done by `pack'-ing the outermost frame widget.

   To create and display a chess board widget, all that is needed is to
call the procedure

     setup_board

which creates the chess board widget.

   Once the chess board has been displayed, we need to be able to take a
solution, a list of rows ordered by column, and place queens in the
positions indicated.

   Taking a topdown approach, our procedure for taking a solution and
displaying is as follows:

     proc show_solution { solution } {
         clear_board
         set column 1
         foreach row $solution {
             place_queen $column $row
             incr column
         }
     }

   This takes a solution in `solution', clears the board of all queens,
and then places each queen from the solution on the board.

   Next we will handle clearing the board:

     proc clear_board { } {
         for { set column 1 } {$column <= 8} {incr column} {
             reset_column $column
         }
     }

     proc reset_column { column } {
         for {set row 1 } { $row <= 8 } {incr row} {
             set_queens $column $row off
         }
     }

     proc set_queens { column row state } {
         if { $state == "on" } {
             .queens.$column-$row config -foreground black
         } else {
             .queens.$column-$row config
             -foreground [.queens.$column-$row cget -background]
         }
     }

   The procedure `clear_board' clears the board of queens by calling
the procedure `reset_column' for each of the 8 columns on a board.
`reset_column' goes through each square of a column and sets the square
to `off' through `set_queens'.  In turn, `set_queens' sets the
foreground color of a square to black if the square is turned `on',
thus revealing the queen bitmap, or sets the foreground color of a
square to its background color, thus making the queens invisible, if it
is called with something other than `on'.

   That handles clearing the board, clearing a column or turning a
queen on or off on a particular square.

   The final part is `place_queen':

     proc place_queen { column row } {
         reset_column $column
         set_queens $column $row on
     }

   This resets a column so that all queens on it are invisible and then
sets the square with coordinates given in `row' and `column' to on.

   A typical call would be:

     show_solution "1 2 3 4 5 6 7 6 8"


 [image src="images/tcltkex18.png" text="" ]                       8-Queens Display In Tcl/Tk

which would display queens along a diagonal.  (This is of course not a
solution to the 8-queens problem. This Tcl/Tk code only displays
possible queens solutions; it doesn't check if the solution is valid.
Later we will combine this Tcl/Tk display code with Prolog code for
generating solutions to the 8-queens problem.)


File: sicstus.info,  Node: The Tcl/Tk Prolog Library,  Next: Putting It All Together,  Prev: Tk,  Up: lib-tcltk

10.41.4 The Tcl/Tk Prolog Library
---------------------------------

Now we have covered the wonders of Tcl/Tk, we come to the real meat of
the tutorial: how to couple the power of Tcl/Tk with the power of
SICStus Prolog.

   Tcl/Tk is included in SICStus Prolog by loading a special library.
The library provides a bidirectional interface between Tcl/Tk and
Prolog.

* Menu:

* How it Works - An Overview:: How it Works - An Overview
* Basic Functions:: Basic Functions
* Evaluation Functions:: Evaluation Functions
* Event Functions:: Event Functions
* Servicing Tk Events:: Servicing Tcl and Tk events
* Passing Control to Tk:: Passing Control to Tk
* Housekeeping:: Housekeeping functions
* Summary:: Summary


File: sicstus.info,  Node: How it Works - An Overview,  Next: Basic Functions,  Up: The Tcl/Tk Prolog Library

10.41.4.1 How it Works - An Overview
....................................

Before describing the details of the Tcl/Tk library we will give an
overview of how it works with the Prolog system.

   The Tcl/Tk library provides a loosely coupled integration of Prolog
and Tcl/Tk. By this we mean that the two systems, Prolog and Tcl/Tk,
although joined through the library, are mostly separate; Prolog
variables have nothing to do with Tcl variables, Prolog and Tcl program
states are separate, and so on.

   The Tcl/Tk library extends Prolog so that Prolog can create a number
of independent Tcl interpreters with which it can interact.  Basically,
there is a predicate, which when executed creates a Tcl interpreter and
returns a handle with which Prolog can interact with the interpreter.

   Prolog and a Tcl interpreter interact, and so communicate and
cooperate, through two ways:

  1. One system evaluates a code fragment in the other system and
     retrieves the result. For example, Prolog evaluates a Tcl code
     fragment in an attached Tcl interpreter and gets the result of the
     evaluation in a Prolog variable. Similarly, a Tcl interpreter can
     evaluate a Prolog goal and get the result back through a Tcl
     variable.

     This is synchronous communication in that the caller waits until
     the callee has finished their evaluation and reads the result.

  2. One system passing a "message" to the other on an "event" queue.

     This is asynchronous communication in that the receiver of the
     message can read the message whenever it likes, and the sender can
     send the message without having to wait for a reply.

   The Tk part of Tcl/Tk comes in because an attached Tcl interpreter
may be extended with the Tk widget set and so be a Tcl/Tk interpreter.
This makes it possible to add GUIs to a Prolog application: the
application loads the Tcl/Tk Prolog library, creates a Tcl/Tk
interpreter, and sends commands to the interpreter to create a Tk GUI.
The user interacts with the GUI and therefore with the underlying
Prolog system.

   There are two main ways to partition the Tcl/Tk library functions:
by function, i.e. the task they perform; or by package, i.e. whether
they are Tcl, Tk, or Prolog functions.  We will describe the library in
terms of the former because it fits in with the tutorial style better,
but at the end is a summary section that summarizes the library
functions both ways.

   Taking the functional approach, the library can be split into six
function groups:

   * basic functions
        - loading the library

        - creating and destroying Tcl and Tcl/Tk interpreters

   * evaluation functions
        - evaluating Tcl expressions from Prolog

        - evaluating Prolog expressions from Tcl

   * Prolog event functions
        - handling the Prolog/Tcl event queue

   * Tk event handling

   * passing control to Tk

   * housekeeping functions

   We go through each group in turn.


File: sicstus.info,  Node: Basic Functions,  Next: Evaluation Functions,  Prev: How it Works - An Overview,  Up: The Tcl/Tk Prolog Library

10.41.4.2 Basic Functions
.........................

The heart of the system is the ability to create an embedded Tcl
interpreter with which the Prolog system can interact.  A Tcl
interpreter is created within Prolog through a call to `tcl_new/1':

     tcl_new(-TCLINTERPRETER)

which creates a new interpreter, initializes it, and returns a reference
to it in the variable TCLINTERPRETER. The reference can then be used in
subsequent calls to manipulate the interpreter. More than one Tcl
interpreter object can be active in the Prolog system at any one time.

   To start a Tcl interpreter extended with Tk, the `tk_new/2'
predicate is called from Prolog. It has the following form:

     tk_new(+OPTIONS, -TCLINTERPRETER)

which returns through the variable TCLINTERPRETER a handle to the
underlying Tcl interpreter. The usual Tcl/Tk window pops up after this
call is made and it is with reference to that window that subsequent
widgets are created.  As with the `tcl_new/1' predicate, many Tcl/Tk
interpreters may be created from Prolog at the same time through calls
to `tk_new/2'.

   The OPTIONS part of the call is a list of some (or none) of the
following elements:

`top_level_events'
     This allows Tk events to be handled while Prolog is waiting for
     terminal input; for example, while the Prolog system is waiting
     for input at the top-level prompt. Without this option, Tk events
     are not serviced while the Prolog system is waiting for terminal
     input. (For information on Tk events; *note Event Handling::).

`name(+APPLICATIONNAME)'
     This gives the main window a title APPLICATIONNAME.  This name is
     also used for communicating between Tcl/Tk applications via the
     Tcl  `send' command.  (`send' is not covered in this document.
     Please refer to the Tcl/Tk documentation.)

`display(+DISPLAY)'
     (This is X windows specific.) Gives the name of the screen on which
     to create the main window. If this is not given, the default
     display is determined by the `DISPLAY' environment variable.

   An example of using `tk_new/2':

     | ?- tk_new([top_level_events, name('My SICStus/Tk App')], Tcl).

which creates a Tcl/Tk interpreter, returns a handle to it in the
variable `Tcl' and Tk events are serviced while Prolog is waiting at
the top-level prompt.  The window that pops up will have the title `My
SICStus/Tk App'.

   The reference to a Tcl interpreter returned by a call to `tk_new/2'
is used in the same way and in the same places as a reference returned
by a call to `tcl_new/1'. They are both references to Tcl interpreters.

   To remove a Tcl interpreter from the system, use the `tcl_delete/1'
predicate:

     tcl_delete(+TCLINTERPRETER)

which given a reference to a Tcl interpreter, closes down the
interpreter and removes it. The reference can be for a plain Tcl
interpreter or for a Tk enhanced one; `tcl_delete/1' removes both kinds.


File: sicstus.info,  Node: Evaluation Functions,  Next: Event Functions,  Prev: Basic Functions,  Up: The Tcl/Tk Prolog Library

10.41.4.3 Evaluation Functions
..............................

There are two functions in this category: Prolog extended to be able to
evaluate Tcl expressions in a Tcl interpreter; Tcl extended to be able
to evaluate a Prolog expression in the Prolog system.

   There is a mechanism for describing Tcl commands in Prolog as Prolog
terms.  This is used in two ways: firstly, to be able to represent Tcl
commands in Prolog so that they can be subsequently passed to Tcl for
evaluation; and secondly for passing terms back from Tcl to Prolog by
doing the reverse transformation.

   Why not represent a Tcl command as a simple atom or string?  This
can indeed be done, but commands are often not static and each time they
are called require slightly different parameters.  This means
constructing different atoms or strings for each command in Prolog,
which are expensive operations.  A better solution is to represent a
Tcl command as a Prolog term, something that can be quickly and
efficiently constructed and stored by a Prolog system. Variable parts
to a Tcl command (for example command arguments) can be passed in
through Prolog variables.

   In the special command format, a Tcl command is specified as follows.

COMMAND        ::= NAME                      
               | `codes("code-list")'        
               | `write("term")'             
               | `writeq("term")'            
               | `write_canonical("term")'   
               | `format(FMT,ARGS)'          
               | `dq(COMMAND)'               
               | `br(COMMAND)'               
               | `sqb(COMMAND)'              
               | `min(COMMAND)'              
               | `dot(LISTOFNAMES)'          
               | `list(LISTOFCOMMANDS)'      
               | LISTOFCOMMANDS              

FMT            ::= "atom"                    

NAME           ::= "atom"                    { other than `[]' }
               | "number"                    

LISTOFCOMMANDS ::= `[]'                      
               | `[ COMMAND |                
               LISTOFCOMMANDS ]'             

LISTOFNAMES    ::= `[]'                      
               | `[ NAME | LISTOFNAMES ]'    

ARGS           ::= `[]'                      
               | `[ "term" | ARGS ]'         

where

ATOM
NUMBER
     denote their printed representations

`codes(PROLOGSTRING)'
     denotes the string represented by PROLOGSTRING (a code-list)

`write(TERM)'
`writeq(TERM)'
`write_canonical(TERM)'
     denotes the string that is printed by the corresponding built-in
     predicate.

          *Please note*: In general it is not possible to reconstruct
          TERM from the string printed by `write/1'. If TERM will be
          passed back into Prolog it therefore safest to use
          `write_canonical(TERM)'.

`format(FMT, ARGS)'
     denotes the string that is printed by the corresponding built-in
     predicate

`dq(COMMAND)'
     denotes the string specified by COMMAND, enclosed in double quotes

`br(COMMAND)'
     denotes the string specified by COMMAND, enclosed in curly brackets

`sqb(COMMAND)'
     denotes the string specified by COMMAND, enclosed in square
     brackets

`min(COMMAND)'
     denotes the string specified by COMMAND, immediately preceded by a
     hyphen

`dot(LISTOFNAME)'
     denotes the widget path specified by LISTOFNAME, preceded by and
     separated by dots

`list(LISTOFCOMMANDS)'
     denotes the TCL list with one element for each element in
     LISTOFCOMMANDS. This differs from just using LISTOFCOMMANDS or
     `br(LISTOFCOMMANDS)' when any of the elements contains spaces,
     braces or other characters treated specially by TCL.

LISTOFCOMMANDS
     denotes the string denoted by each element, separated by spaces.
     In many cases `list(LISTOFCOMMANDS)' is a better choice.

   Examples of command specifications and the resulting Tcl code:

     [set, x, 32]
         => set x 32

     [set, x, br([a, b, c])]
         => set x {a b c}

     [dot([panel,value_info,name]), configure, min(text), br(write('$display'/1))]
          => .panel.value_info.name configure -text {$display/1

     ['foo bar',baz]
          =>foo bar baz

     list(['foo bar',bar])
          => {foo bar} baz

     list(['foo { bar'',bar])
          => foo\ \{ \bar baz

   Prolog calls Tcl through the predicate `tcl_eval/3', which has the
following form:

     tcl_eval(+TCLINTERPRETER, +COMMAND, -RESULT)

which causes the interpreter TCLINTERPRETER to evaluate the Tcl command
COMMAND and return the result RESULT. The result is a string (a
code-list) that is the usual return string from evaluating a Tcl
command.  COMMAND is not just a simple Tcl command string (although
that is a possibility) but a Tcl command represented as a Prolog term
in the special Command Format (*note Evaluation Functions::).

   Through `tcl_eval/3', Prolog has a method of synchronous
communication with an embedded Tcl interpreter and a way of manipulating
the state of the interpreter.

   An example:

     | ?- tcl_new(Interp),
          tcl_eval(Interp, 'set x 1', _),
          tcl_eval(Interp, 'incr x', R).

which creates a Tcl interpreter the handle of which is stored in the
variable `Interp'. Then variable `x' is set to the value `"1"' and then
variable `x' is incremented and the result returned in `R' as a string.
The result will be "2".  By evaluating the Tcl commands in separate
`tcl_eval/3' calls, we show that we are manipulating the state of the
Tcl interpreter and that it remembers its state between manipulations.

   It is worth mentioning here also that because of the possibility of
the Tcl command causing an error to occur in the Tcl interpreter, two
new exceptions are added by the `tcltk' library:

     tcl_error(GOAL, MESSAGE)
     tk_error(GOAL, MESSAGE)

where MESSAGE is a code-list detailing the reason for the exception.
Also two new `user:portray_message/2' rules are provided so that any
such uncaught exceptions are displayed at the Prolog top-level as

     [TCL ERROR: GOAL - MESSAGE]
     [TK ERROR: GOAL - MESSAGE]

respectively.

   These exception conditions can be raised/caught/displayed in the
usual way through the built-in predicates `raise_exception/3',
`on_exception/1', and `portray_message/2'.

   As an example, the following Prolog code will raise such an
exception:

     | ?- tcl_new(X), tcl_eval(X, 'wilbert', R).

which causes a `tcl_error/2' exception and prints the following:

     {TCL ERROR: tcl_eval/3 - invalid command name "wilbert"}

assuming that there is no command or procedure defined in Tcl called
`wilbert'.

   The Tcl interpreters created through the SICStus Prolog Tcl/Tk
library have been extended to allow calls to the underlying Prolog
system.

   To evaluate a Prolog expression in the Prolog system from a Tcl
interpreter, the new `prolog' Tcl command is invoked. It has the
following form:

     prolog PROLOGGOAL

where PROLOGGOAL is the printed form of a Prolog goal.  This causes the
goal to be executed in Prolog.  It will be executed in the `user'
module unless it is prefixed by a module name.  Execution is always
determinate.

   The return value of the command either of the following:

`"1"'
     if execution succeeded,

`"0"'
     if execution failed.

   If succeeded (and "1" was returned), any variable in PROLOGGOAL that
has become bound to a Prolog term will be returned to Tcl in the Tcl
array named `prolog_variables' with the variable name as index. The
term is converted to Tcl using the same conversion as used for Tcl
commands (*note Evaluation Functions::). As a special case the values
of unbound variables and variables with names starting with `_', are
not recorded and need not conform to the special command format, this
is similar to the threatment of such variables by the Prolog top-level.

   An example:

     test_callback(Result) :-
         tcl_new(Interp),
         tcl_eval(Interp,
             'if {[prolog "foo(X,Y,Z)"] == 1} \\
                 {list $prolog_variables(X) \\
                       $prolog_variables(Y) \\
                       $prolog_variables(Z)}',
                 Result),
         tcl_delete(Interp).

     foo(1, bar, [a, b, c]).

   When called with the query:

     | ?- test_callback(Result).

will succeed, binding the variable `Result' to:

     "1 bar {a b c}"

   This is because execution of the `tcl_eval/3' predicate causes the
execution of the `prolog' command in Tcl, which executes `foo(X, Y, Z)'
in Prolog making the following bindings: `X = 1', `Y = bar', `Z = [a,
b, c]'.  The bindings are returned to Tcl in the associative array
`prolog_variables' where `prolog_variables(X)' is "1",
`prolog_variables(Y)' is "bar", and `prolog_variables(Z)' is "a b c".
Then Tcl goes on to execute the `list' command as

     list "1" "bar" "a b c"

which returns the result

     "1 bar {a b c}"

(remember: nested lists magically get represented with curly brackets)
which is the string returned in the RESULT part of the Tcl call, and is
ultimately returned in the `Result' variable of the top-level call to
`test_callback(Result)'.

   If an error occurs during execution of the `prolog' Tcl command, a
`tcl_error/2' exception will be raised.  The message part of the
exception will be formed from the string `Exception during Prolog
execution: ' appended to the Prolog exception message.  An example is
the following:

     | ?- tcl_new(T), tcl_eval(T, 'prolog wilbert', R).

which will print

     {TCL ERROR: tcl_eval/3 - Exception during Prolog execution:
       wilbert  existence_error(wilbert,0,procedure,user:wilbert/0,0)}

at the Prolog top-level, assuming that the predicate `wilbert/0' is not
defined on the Prolog side of the system. (This is a `tcl_error'
exception containing information about the underlying exception, an
`existence_error' exception, which was caused by trying to execute the
non-existent predicate `wilbert'.)


File: sicstus.info,  Node: Event Functions,  Next: Servicing Tk Events,  Prev: Evaluation Functions,  Up: The Tcl/Tk Prolog Library

10.41.4.4 Event Functions
.........................

Another way for Prolog to communicate with Tcl is through the predicate
`tcl_event/3':

     tcl_event(+TCLINTERPRETER, +COMMAND, -EVENTS)

   This is similar to `tcl_eval/3' in that the command COMMAND is
evaluated in the Tcl interpreter TCLINTERPRETER, but the call returns a
list of events in EVENTS rather than the result of the Tcl evaluation.
COMMAND is again a Tcl command represented as a Prolog term in the
special Command Format described previously (*note Evaluation
Functions::).

   This begs the questions what are these events and where does the
event list come from? The Tcl interpreters in the SICStus Prolog Tcl/Tk
library have been extended with the notion of a Prolog event queue.
(This is not available in plain standalone Tcl interpreters.) The Tcl
interpreter can put events on the event queue by executing a
`prolog_event' command. Each event is a Prolog term.  So a Tcl
interpreter has a method of putting Prolog terms onto a queue, which
can later be picked up by Prolog as a list as the result of a call to
`tcl_event/3'.  (It may be helpful to think of this as a way of passing
messages as Prolog terms from Tcl to Prolog.)

   A call to `tcl_event/3' blocks until there is something on the event
queue.

   A second way of getting Prolog events from a Prolog event queue is
through the `tk_next_event/[2,3]' predicates.  These have the form:

     tk_next_event(+TCLINTERPRETER, -EVENT)
     tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)

where TCLINTERPRETER reference to a Tcl interpreter and EVENT is the
Prolog term at the head of the associated Prolog event queue.  (The
OPTIONS feature will be described below in the Housekeeping section
when we talk about Tcl and Tk events; *note Housekeeping::.).

   (We will meet `tk_next_event/[2,3]' again later when we discuss how
it can be used to service Tk events; *note Servicing Tk Events::).

   If the interpreter has been deleted, the empty list `[]' is returned.

   The Tcl interpreters under the SICStus Prolog library are extended
with a command, `prolog_event', for adding events to a Prolog event
queue.

   The `prolog_event' command has the following form:

        prolog_event TERMS ...

where TERMS are strings that contain the printed representation of
Prolog terms. These are stored in a queue and retrieved as Prolog terms
by `tcl_event/3' or `tk_next_event/[2,3]' (described above).

   An example of using the `prolog_event' command:

     test_event(Event) :-
         tcl_new(Interp),
         tcl_event(Interp, [prolog_event, dq(write(zap(42)))], Event),
         tcl_delete(Interp).

with the query:

     | ?- test_event(Event).

will succeed, binding `Event' to the list `[zap(42)]'.

   This is because `tcl_event' converts its argument using the special
Command Format conversion (*note Evaluation Functions::), which yields
the Tcl command `prolog_event "zap(42)"'.  This command is evaluated in
the Tcl interpreter referenced by the variable `Interp'.  The effect of
the command is to take the string given as argument to `prolog_event'
(in this case `"zap(42)"') and to place it on the Tcl to Prolog event
queue.  The final action of a `tcl_event/3' call is to pick up any
strings on the Prolog queue from Tcl, add a trailing full stop and
space to each string, and parse them as Prolog terms, binding `Event'
to the list of values, which in this case is the singleton list
`[zap(42)]'. (The queue is a list the elements of which are terms put
there through calls to `prolog_event').

   If any of the TERM-s in the list of arguments to `prolog_event' is
not a valid representation of a Prolog term, an exception is raised in
Prolog when it is converted from the Tcl string to the Prolog term
using `read'. To ensure that Prolog will be able to read the term
correctly it is better to always use `write_canonical' and to ensure
that Tcl is not confused by special characters in the printed
representation of the Prolog term it is best to wrap the list with
`list'.

   A safer variant that safely passes any term from Prolog via Tcl and
back to Prolog is thus:

     test_event(Term, Event) :-
         tcl_new(Interp),
         tcl_event(Interp, list([prolog_event, write_canonical(Term)]), Event),
         tcl_delete(Interp).

   As an example of using the Prolog event system supplied by the
`tcltk' library, we will return to our 8-queens example but now
approaching from the Prolog side rather than the Tcl/Tk side:

     :- use_module(library(tcltk)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl),
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Qs, Tcl),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).

   This is the top-level fragment of the Prolog side of the 8-queens
example. It has three predicates: `setup/0', `closedown/1', and `go/1'.
`setup/0' simply creates the Tcl interpreter, loads the Tcl code into
the interpreter using a call to `tcl_eval/3' (which also initializes
the display) but then calls `tk_next_event/2' to wait for a message
from the Tk side.

   The Tk part that sends `prolog_event'-s to Prolog looks like this:

     button .next -text next -command {prolog_event  next}
     pack .next

     button .stop -text stop -command {prolog_event stop}
     pack .stop

that is two buttons, one that sends the atom `next', the other that
sends the atom `stop'. They are used to get the next solution and to
stop the program respectively.

   So if the user presses the `next' button in the Tk window, the
Prolog program will receive a `next' atom via a
`prolog_event'/`tk_next_event' pair, and the program can proceed to
execute `go/1'.

   `go/1' is a failure driven loop that generates 8-queens solutions
and displays them. First it generates a solution in Prolog and displays
it through a `tcl_eval/3' call. Then it waits again for a Prolog events
via `tk_next_event/2'. If the term received on the Prolog event queue
is `next', corresponding to the user pressing the "next solution"
button, then fail is executed and the next solution found, thus driving
the loop.

   If the `stop' button is pressed, the program does some tidying up
(clearing the display and so on) and then executes `closedown/1', which
deletes the Tcl interpreter and the corresponding Tk windows
altoegther, and the program terminates.

   This example fragment show how it is possible for a Prolog program
and a Tcl/Tk program to communicate via the Prolog event queue.


File: sicstus.info,  Node: Servicing Tk Events,  Next: Passing Control to Tk,  Prev: Event Functions,  Up: The Tcl/Tk Prolog Library

10.41.4.5 Servicing Tcl and Tk events
.....................................

The notion of an event in the Prolog+Tcl/Tk system is overloaded.  We
have already come across the following kinds of events:

   * Tk widget events captured in Tcl/Tk through the `bind' command

   * Prolog queue events controlled through the `tcl_event/3',
     `tk_next_event(2,3)', and `prolog_event' functions

   It is further about to be overloaded with the notion of Tcl/Tk
events.  It is possible to create event handlers in Tcl/Tk for reacting
to other kinds of events. We will not cover them here but describe them
so that the library functions are understandable and in case the user
needs these features in an advanced application.

   There are the following kinds of Tcl/Tk events:

idle events
     happen when the Tcl/Tk system is idle

file events
     happen when input arrives on a file handle that has a file event
     handler attached to it

timer events
     happen when a Tcl/Tk timer times out

window events
     when something happens to a Tk window, such as being resized or
     destroyed

   The problem is that in advanced Tcl/Tk applications it is possible
to create event handlers for each of these kinds of event, but they are
not normally serviced while in Prolog code.  This can result in
unresponsive behavior in the application; for example, if window events
are not serviced regularly, then if the user tries to resize a Tk
window, it will not resize in a timely fashion.

   The solution to this is to introduce a Prolog predicate that passes
control to Tk for a while so that it can process its events,
`tk_do_one_event/[0,1]'. If an application is unresponsive because it
is spending a lot of time in Prolog and is not servicing Tk events
often enough, critical sections of the Prolog code can be sprinkled
with calls to `tk_do_one_event/[0,1]' to alleviate the problem.

   `tk_do_one_event/[0,1]' has the following forms:

     tk_do_one_event
     tk_do_one_event(+OPTIONS)

which passes control to Tk to handle a single event before passing
control back to Prolog. The type of events handled is passed through the
OPTIONS variable, a list of atoms that are event types.

   The OPTIONS list can contain the following atoms:

`tk_dont_wait'
     don't wait for new events, process only those that are ready

`tk_window_events'
     process window events

`tk_file_events'
     process file events

`tk_timer_events'
     process timer events

`tk_idle_events'
     process `Tcl_DoWhenIdle' events

`tk_all_events'
     process any event

   Calling `tk_do_one_event/0' is equivalent to a call to
`tk_do_one_event/1' with the `tk_all_events' and `tk_dont_wait' flags.

   A call to either of these predicates succeeds only if an event of
the appropriate type happens in the Tcl/Tk interpreter.  If there are no
such events, `tk_do_one_event/1' will fail if the `tk_dont_wait' wait
flag is present, as will `tk_do_one_event/0', which has that flag set
implicitly.

   If the `tk_dont_wait' flag is not set, a call to `tk_do_one_event/1'
will block until an appropriate Tk event happens (in which case it will
succeed).

   It is straight forward to define a predicate that handles all Tk
events and then returns:

     tk_do_all_events :-
         tk_do_one_event, !,
         tk_do_all_events.
     tk_do_all_events.

   The predicate `tk_next_event/[2,3]' is similar to
`tk_do_one_event/[0,1]' except that it processes Tk events until at
least one Prolog event happens. (We came across this predicate before
when discussing Prolog event queue predicates. This shows the
overloading of the notion event where we have a predicate that handles
both Tcl/Tk events and Prolog queue events.)

   It has the following forms:

     tk_next_event(+TCLINTERPRETER, -EVENT)
     tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)

   The Prolog event is returned in the variable EVENT and is the first
term on the Prolog event queue associated with the interpreter
TCLINTERPRETER. (Prolog events are initiated on the Tcl side through
the new Tcl command `prolog_event', covered earlier; *note Event
Functions::).


File: sicstus.info,  Node: Passing Control to Tk,  Next: Housekeeping,  Prev: Servicing Tk Events,  Up: The Tcl/Tk Prolog Library

10.41.4.6 Passing Control to Tk
...............................

There is a predicate for passing control completely over to Tk, the
`tk_main_loop/0' command. This passes control to Tk until all windows
in all the Tcl/Tk interpreters in the Prolog have have been destroyed:

     tk_main_loop


File: sicstus.info,  Node: Housekeeping,  Next: Summary,  Prev: Passing Control to Tk,  Up: The Tcl/Tk Prolog Library

10.41.4.7 Housekeeping functions
................................

Here we will described the functions that don't fit into any of the
above categories and are essentially housekeeping functions.

   There is a predicate that returns a reference to the main window of
a Tcl/Tk interpreter:

     tk_main_window(+TCLINTERPRETER, -TKWINDOW)

which given a reference to a Tcl interpreter TCLNTERPRETER, returns a
reference to its main window in TKWINDOW.

   The window reference can then be used in `tk_destroy_window/1':

     tk_destroy_window(+TKWINDOW)

which destroys the window or widget referenced by TKWINDOW and all of
its sub-widgets.

   The predicate `tk_make_window_exist/1' also takes a window reference:

     tk_make_window_exist(+TKWINDOW)

which causes the window referenced by TKWINDOW in the Tcl interpreter
TCLINTERPRETER to be immediately mapped to the display.  This is useful
because normally Tk delays displaying new information for a long as
possible (waiting until the machine is idle, for example), but using
this call causes Tk to display the window immediately.

   There is a predicate for determining how many main windows, and
hence Tcl/Tk interpreters (excluding simple Tcl interpreters), are
currently in use:

     tk_num_main_windows(-NUMBEROFWINDOWS)

which returns an integer in the variable NUMBEROFWINDOWS.


File: sicstus.info,  Node: Summary,  Prev: Housekeeping,  Up: The Tcl/Tk Prolog Library

10.41.4.8 Summary
.................

The functions provided by the SICStus Prolog Tcl/Tk library can be
grouped in two ways: by function, and by package.

   By function, we can group them like this:

   * basic functions
    `tcl_new/1'
          create a Tcl interpreter

    `tcl_delete/1'
          remove a Tcl interpreter

    `tk_new/2'
          create a Tcl interpreter with Tk extensions

   * evaluation functions
    `tcl_eval/3'
          evaluate a Tcl expression from Prolog

    `prolog'
          evaluate a Prolog expression from Tcl

   * Prolog event queue functions
    `tcl_event/3'
          evaluate a Tcl expression and return a Prolog queue event list

    `tk_next_event/[2,3]'
          pass control to Tk until a Prolog queue event happens and
          return the head of the queue

    `prolog_event'
          place a Prolog term on the Prolog event queue from Tcl

   * servicing Tcl and Tk events
    `tk_do_one_event/[0,1]'
          pass control to Tk until one Tk event is serviced

    `tk_next_event/[2,3]'
          also services Tk events but returns when a Prolog queue event
          happens and returns the head of the queue

   * passing control completely to Tk
    `tk_main_loop/0'
          control passed to Tk until all windows in all Tcl/Tk
          interpreters are gone

   * housekeeping
    `tk_main_window/2'
          return reference to main in of a Tcl/Tk interpreter

    `tk_destroy_window/1'
          destroy a window or widget

    `tk_make_window_exist/1'
          force display of a window or widget

    `tk_num_main_windows/1'
          return a count of the total number of Tk main windows
          existing in the system

   By package, we can group them like this:

   * predicates for Prolog to interact with Tcl interpreters
    `tcl_new/1'
          create a Tcl interpreter

    `tcl_delete/1'
          remove a Tcl interpreter

    `tcl_eval/3'
          evaluate a Tcl expression from Prolog

    `tcl_event/3'
          evaluate a Tcl expression and return a Prolog event list

   * predicates for Prolog to interact with Tcl interpreters with Tk
     extensions
    `tk_new/2'
          create a Tcl interpreter with Tk extensions

    `tk_do_one_event/[0,1]'
          pass control to Tk until one Tk event is serviced

    `tk_next_event/[2,3]'
          also services Tk events but returns when a Prolog queue event
          happens and returns the head of the queue

    `tk_main_loop/0'
          control passed to Tk until all windows in all Tcl/Tk
          interpreters are gone

    `tk_main_window/2'
          return reference to main in of a Tcl/Tk interpreter

    `tk_destroy_window/1'
          destroy a window or widget

    `tk_make_window_exist/1'
          force display of a window or widget

    `tk_num_main_windows/1'
          return a count of the total number of Tk main windows
          existing in the system

   * commands for the Tcl interpreters to interact with the Prolog
     system
    `prolog'
          evaluate a Prolog expression from Tcl

    `prolog_event'
          place a Prolog term on the Prolog event queue from Tcl

   In the next section we will discuss how to use the `tcltk' library
to build graphical user interfaces to Prolog applications.  More
specifically we will discuss the ways in which cooperation between
Prolog and Tcl/Tk can be arranged: how to achieve them, and their
benefits.


File: sicstus.info,  Node: Putting It All Together,  Next: Quick Reference,  Prev: The Tcl/Tk Prolog Library,  Up: lib-tcltk

10.41.5 Putting It All Together
-------------------------------

At this point we now know Tcl, the Tk extensions, and how they can be
integrated into SICStus Prolog through the `tcltk' library module.  The
next problem is how to get all this to work together to produce a
coherent application. Because Tcl can make Prolog calls and Prolog can
make Tcl calls it is easy to create programming spaghetti.  In this
section we will discuss some general principles of organizing the
Prolog and Tcl code to make writing applications easier.

   The first thing to do is to review the tools that we have.  We have
two programming systems: Prolog and Tcl/Tk.  They can interact in the
following ways:

   * Prolog evaluates a Tcl expression in a Tcl interpreter, using
     `tcl_eval'

   * Tcl evaluates a Prolog expression in the Prolog interpreter, using
     `prolog'

   * Prolog evaluates a Tcl expression in a Tcl interpreter and waits
     for a Prolog event, using `tcl_event'

   * Prolog waits for a Prolog event from a Tcl interpreter, using
     `tk_next_event'

   * Tcl sends a Prolog predicate to Prolog on a Prolog event queue
     using `prolog_event'

   With these interaction primitives there are three basic ways in
which Prolog and Tcl/Tk can be organized:

  1. Tcl the master, Prolog the slave: program control is with Tcl,
     which makes occasional calls to Prolog, through the `prolog'
     function.

  2. Prolog the master, Tcl the slave: program control is with Prolog,
     which makes occasional call to Tcl through the `tcl_eval' function

  3. Prolog and Tcl share control: program control is shared with Tcl
     and Prolog interacting via the Prolog event queue, through
     `tcl_event', `tk_next_event', and `prolog_event'.

   These are three ways of organizing cooperation between Tcl/Tk and
Prolog to produce an application. In practice an application my use
only one of these methods throughout, or may use a combination of them
where appropriate. We describe them here so that the developer can see
the different patterns of organization and can pick those relevant to
their application.

* Menu:

* Tcl The Master:: Tcl The Master, Prolog The Slave
* Prolog The Master:: Prolog The Master, Tk The Slave
* Prolog And Tcl Interact through Prolog Event Queue:: Prolog And Tcl Interact through Prolog Event Queue
* The Whole 8-Queens Example:: The Whole 8-Queens Example


File: sicstus.info,  Node: Tcl The Master,  Next: Prolog The Master,  Up: Putting It All Together

10.41.5.1 Tcl The Master, Prolog The Slave
..........................................

This is the classical way that GUIs are bolted onto applications.  The
slave (in this case Prolog) sits mostly idle while the user interacts
with the GUI, for example filling in a form.  When some action happens
in the GUI that requires information from the slave (a form submit, for
example), the slave is called, performs a calculation, and the GUI
retrieves the result and updates its display accordingly.

   In our Prolog+Tcl/Tk setting this involves the following steps:

   * start Prolog and load the Tcl/Tk library

   * load Prolog application code

   * start a Tcl/Tk interpreter through `tk_new/2'

   * set up the Tk GUI through calls to `tcl_eval/3'

   * pass control to Tcl/Tk through `tk_main_loop'

   Some of The Tk widgets in the GUI will have "callbacks" to Prolog,
i.e. they will call the `prolog' Tcl command.  When the Prolog call
returns, the values stored in the `prolog_variables' array in the Tcl
interpreter can then be used by Tcl to update the display.

   Here is a simple example of a callback. The Prolog part is this:

     :- use_module(library(tcltk)).

     hello('world').

     go :-
         tk_new([], Tcl),
         tcl_eval(Tcl, 'source simple.tcl', _),
         tk_main_loop.

which just loads the `library(tcltk)', defines a `hello/1' data clause,
and `go/0', which starts a new Tcl/Tk interpreter, loads the code
`simple.tcl' into it, and passes control to Tcl/Tk.

   The Tcl part, `simple.tcl', is this:

     label .l -textvariable tvar
     button .b -text "push me" -command { call_and_display }
     pack .l .b -side top

     proc call_and_display { } {
         global tvar

         prolog "hello(X)"
         set tvar $prolog_variables(X)
     }

which creates a label, with an associated text variable, and a button,
that has a call back procedure, `call_and_display', attached to it.
When the button is pressed, `call_and_display' is executed, which
simply evaluates the goal `hello(X)' in Prolog and the text variable of
the label `.l' to whatever `X' becomes bound to, which happens to be
`world'.  In short, pressing the button causes the word `world' to be
displayed in the label.

   Having Tcl as the master and Prolog as the slave, although a simple
model to understand and implement, does have disadvantages.  The Tcl
command `prolog' is determinate, i.e. it can return only one result
with no backtracking.  If more than one result is needed it means
either performing some kind of all-solutions search and returning a
list of results for Tcl to process, or asserting a clause into the
Prolog clause store reflecting the state of the computation.

   Here is an example of how an all-solutions search can be done. It is
a program that calculates the outcome of certain ancestor
relationships; i.e. enter the name of a person, click on a button and
it will tell you the mother, father, parents or ancestors of that
person.

   The Prolog portion looks like this (see also
`library('tcltk/examples/ancestors.pl')'):

     :- use_module(library(tcltk)).

     go :- tk_new([name('ancestors')], X),
         tcl_eval(X, 'source ancestors.tcl', _),
         tk_main_loop,
         tcl_delete(X).

     father(ann, fred).
     father(fred, jim).
     mother(ann, lynn).
     mother(fred, lucy).
     father(jim, sam).

     parent(X, Y) :- mother(X, Y).
     parent(X, Y) :- father(X, Y).

     ancestor(X, Y) :- parent(X, Y).
     ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).

     all_ancestors(X, Z) :- findall(Y, ancestor(X, Y), Z).

     all_parents(X, Z) :-   findall(Y, parent(X, Y), Z).

   This program consists of three parts.  The first part is defined by
`go/0', the now familiar way in which a Prolog program can create a
Tcl/Tk interpreter, load a Tcl file into that interpreter, and pass
control over to the interpreter.

   The second part is a small database of mother/father relationships
between certain people through the clauses `mother/2' and `father/2'.

   The third part is a set of "rules" for determining certain
relationships between people: `parent/2', `ancestor/2',
`all_ancestors/2' and `all_parents/2'.

   The Tcl part looks like this (see also
`library('tcltk/examples/ancestors.tcl')'):

                                                       _% ancestors.pl_
     #!/usr/bin/wish

     # set up the tk display

     # construct text filler labels
     label .search_for -text "SEARCHING FOR THE" -anchor w
     label .of         -text "OF"                -anchor w
     label .gives      -text "GIVES"             -anchor w

     # construct frame to hold buttons
     frame .button_frame

     # construct radio button group
     radiobutton .mother    -text mother    -variable type -value mother
     radiobutton .father    -text father    -variable type -value father
     radiobutton .parents   -text parents   -variable type -value parents
     radiobutton .ancestors -text ancestors -variable type -value ancestors

     # add behaviors to radio buttons
     .mother    config -command { one_solution mother $name}
     .father    config -command { one_solution father $name}
     .parents   config -command { all_solutions all_parents $name}
     .ancestors config -command { all_solutions all_ancestors $name}

     # create entry box and result display widgets
     entry .name -textvariable name
     label .result -text ">>> result <<<" -relief sunken -anchor nw -justify left

     # pack buttons into button frame
     pack .mother .father .parents .ancestors -fill x -side left -in .button_frame

     # pack everything together into the main window
     pack .search_for .button_frame .of .name .gives .result -side top -fill x

     # now everything is set up

                                                       _% ancestors.pl_
     # defined the callback procedures

     # called for one solution results
     proc one_solution { type name } {
         if [prolog "${type}('$name', R)"] {
             display_result $prolog_variables(R)
         } else {
             display_result ""
         }
     }

     # called for all solution results
     proc all_solutions { type name } {
         prolog  "${type}('$name', R)"
         display_result $prolog_variables(R)
     }

     # display the result of the search in the results box
     proc display_result { result } {
         if { $result != "" } {
     # create a multiline result
             .result config -text $result
         } else {
             .result config -text "*** no result ***"
         }
     }


 [image src="images/tcltkancestors.png" text="" ]                          Ancestors Calculator

This program is in two parts.  The first part sets up the Tk display,
which consists of four radiobuttons to choose the kind of relationship
we want to calculate, an entry box to put the name of the person we
want to calculate the relationship over, and a label in which to
display the result.

   Each radio buttons has an associated callback. Clicking on the radio
button will invoke the appropriate callback, apply the appropriate
relationship to the name entered in the text entry box, and display the
result in the results label.

   The second part consists of the callback procedures themselves.
There are actually just two of them: one for a single solution
calculation, and one for an all-solutions calculation.  The single
solution callback is used when we want to know the mother or father as
we know that a person can have only one of each. The all-solutions
callback is used when we want to know the parents or ancestors as we
know that these can return more than one results.  (We could have used
the all-solutions callback for the single solutions cases too, but we
would like to illustrate the difference in the two approaches.)  There
is little difference between the two approaches, except that in the
single solution callback, it is possible that the call to Prolog will
fail, so we wrap it in an `if' ... `else' construct to catch this case.
An all-solutions search, however, cannot fail, and so the `if' ...
`else' is not needed.

   But there are some technical problems too with this approach.
During a callback Tk events are not serviced until the callback
returns. For Prolog callbacks that take a very short time to complete
this is not a problem, but in other cases, for example during a long
search call when the callback takes a significant time to complete,
this can cause problems. Imagine that, in our example, we had a vast
database describing the parent relationships of millions of people.
Performing an all-solutions ancestors search could take a long time.
The classic problem is that the GUI no longer reacts to the user until
the callback completes.

   The solution to this is to sprinkle `tk_do_one_event/[0,1]' calls
throughout the critical parts of the Prolog code, to keep various kinds
of Tk events serviced.

   If this method is used in its purest form, it is recommended that
after initialization and passing of control to Tcl, Prolog don't make
calls to Tcl through `tcl_eval/3'. This is to avoid programming
spaghetti. In the pure master/slave relationship it is a general
principle that the master only call the slave, and not the other way
around.


File: sicstus.info,  Node: Prolog The Master,  Next: Prolog And Tcl Interact through Prolog Event Queue,  Prev: Tcl The Master,  Up: Putting It All Together

10.41.5.2 Prolog The Master, Tk The Slave
.........................................

The second approach is to have Prolog be the master and Tk the slave.
This is suitable when heavy processing is done in the Prolog code and
Tk is used mostly to display the state of the computation in some way
rather than as a traditional GUI; i.e. during computation Prolog often
makes calls to Tk to show some state, but the user rarely interacts
with the application.

   In our Prolog+Tcl/Tk setting this involves the following steps:

   * start Prolog and load the Tcl/Tk library

   * load Prolog application code

   * start a Tcl/Tk interpreter through `tk_new/2'

   * set up the Tk GUI through calls to `tcl_eval/3'

   * Prolog calls `tcl_eval' to update the Tk display

   * values are passed to Prolog through the Result string of `tcl_eval'

   Again it its purest form, Prolog makes calls to Tcl, but Tcl does not
make calls to Prolog. The result of a call to Tcl is either passed back
through the `Result' variable of a `tcl_eval/3' call.

   A good example of this is the Tcl/Tk display for our 8-queens
problem, that we saw earlier; *note Queens Display::.

   We will now fill out the example by presenting the Prolog master
part.  The Prolog program calculates a solution to the 8-queens problem
and then makes calls Tcl/Tk to display the solution. In this way Tcl/Tk
is the slave, just being used as a simple display.

   We have already seen the Tcl/Tk part, but here is the Prolog part for
generating a solution and displaying it:

     :- use_module(library(tcltk)).
     :- use_module(library(lists)).

     go :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens.tcl', _),
         tk_next_event(Tcl, Event),
         queens(8, Qs),
         reverse(L, LR),
         tcl_eval(Tcl, [show_solution, br(LR)], _),
         fail.
     go.

     queens(N, Qs) :-
         range(1, N, Ns),
         queens(Ns, [], Qs).

     queens(UnplacedQs, SafeQs, Qs) :-
         select(Q, UnplacedQs, UnplacedQs1),
         \+ attack(Q, SafeQs),
         queens(UnplacedQs1, [Q|SafeQs], Qs).
         queens([], Qs, Qs).

     attack(X, Xs) :- attack(X, 1, Xs).

     attack(X, N, [Y|_Ys]) :- X is Y + N.
     attack(X, N, [Y|_Ys]) :- X is Y - N.
     attack(X, N, [_Y|Ys]) :-
         N1 is N + 1,
     attack(X, N1, Ys).

     range(M, N, [M|Ns]) :-
         M < N,
         M1 is M + 1,
         range(M1, N, Ns).
     range(N, N, [N]).

     :- go.

   All this simply does it to create a Tcl/Tk interpreter, load the Tcl
code for displaying queens into it, generate a solution to the 8-queens
problem as a list of integers, and then calls `show_solution/2' in the
Tcl interpreter to display the solution.  At the end of first clause
for `go/0' is a fail clause that turns `go/0' into a failure driven
loop. The result of this is that the program will calculate all the
solutions to the 8-queens problem, displaying them rapidly one after
the other, until there are none left.


File: sicstus.info,  Node: Prolog And Tcl Interact through Prolog Event Queue,  Next: The Whole 8-Queens Example,  Prev: Prolog The Master,  Up: Putting It All Together

10.41.5.3 Prolog And Tcl Interact through Prolog Event Queue
............................................................

In the previous two methods, one of the language systems was the master
and the other slave, the master called the slave to perform some action
or calculation, the slave sits waiting until the master calls it.  We
have seen that this has disadvantages when Prolog is the slave in that
the state of the Prolog call is lost. Each Prolog call starts from the
beginning unless we save the state using message database manipulation
through calls to `assert' and `retract'.

   Using the Prolog event queue, however, it is possible to get a more
balanced model where the two language systems cooperate without either
really being the master or the slave.

   One way to do this is the following:

   * Prolog is started

   * load Tcl/Tk library

   * load and set up the Tcl side of the program

   * Prolog starts a processing loop

   * it periodically checks for a Prolog event and processes it

   * Prolog updates the Tcl display through `tcl_eval' calls

   What can processing a Prolog event mean? Well, for example, a button
press from Tk could tell the Prolog program to finish or to start
processing something else.  The Tcl program is not making an explicit
call to the Prolog system but sending a message to Prolog. The Prolog
system can pick up the message and process it when it chooses, in the
meantime keeping its run state and variables intact.

   To illustrate this, we return to the 8-queens example.  If Tcl/Tk is
the master and Prolog the slave, we have shown that using a callback to
Prolog, we can imagine that we hit a button, call Prolog to get a
solution and then display it. But how do we get the next solution?  We
could get all the solutions, and then use Tcl/Tk code to step through
them, but that doesn't seem satisfactory.  If we use the Prolog is the
master and Tcl/Tk is the slave model, we have shown how we can use
Tcl/Tk to display the solutions generate from the Prolog side: Prolog
just make a call to the Tcl side when it has a solution. But in this
model Tcl/Tk widgets don't interact with the Prolog side; Tcl/Tk is
mearly an add-on display to Prolog.

   But using the Prolog event queue we can get the best of both worlds:
Prolog can generate each solution in turn as Tcl/Tk asks for it.

   Here is the code on the Prolog side that does this.  (We have left
out parts of the code that haven't changed from our previous example,
*note Queens Display::).

     :- use_module(library(tcltk)).
     :- use_module(library(lists)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens2.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl)
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Qs),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).

     show_solution(Tcl, L) :-
         tcl(Tcl),
         reverse(L, LR),
         tcl_eval(Tcl, [show_solution, br(LR)], _),
         tk_do_all_events.

   Notice here that we have used `tk_next_event/2' in several places.
The code is executed by calling `setup/0'.  As usual, this loads in the
Tcl part of the program, but then Prolog waits for a message from the
Tcl side.  This message can either be `next', indicating that we want
to show the next solution, or `stop', indicating that we want to stop
the program.

   If `next' is received, the program goes on to execute `go/1'.  What
this does it to first calculate a solution to the 8-queens problem,
displays the solution through `show_solution/2', and then waits for
another message from Tcl/Tk.  Again this can be either `next' or
`stop'. If `next', the program goes into the failure part of a failure
driven loop and generates and displays the next solution.

   If at any time `stop' is received, the program terminates
gracefully, cleaning up the Tcl interpreter.

   On the Tcl/Tk side all we need are a couple of buttons: one for
sending the `next' message, and the other for sending the `stop'
message.

     button .next -text next -command {prolog_event next}
     pack .next

     button .stop -text stop -command {prolog_event stop}
     pack .stop

   (We could get more sophisticated. We might want it so that when the
button it is depressed until Prolog has finished processing the last
message, when the button is allowed to pop back up. This would avoid the
problem of the user pressing the button many times while the program is
still processing the last request. We leave this as an exercise for the
reader.)


File: sicstus.info,  Node: The Whole 8-Queens Example,  Prev: Prolog And Tcl Interact through Prolog Event Queue,  Up: Putting It All Together

10.41.5.4 The Whole 8-Queens Example
....................................

To finish off, we our complete 8-queens program.

   Here is the Prolog part, which we have covered in previous sections.
The code is in `library('tcltk/examples/8-queens.pl')':

                                                        _% 8-queens.pl_
     :- use_module(library(tcltk)).
     :- use_module(library(lists)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source 8-queens.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl)
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Tcl,Qs),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).

                                                        _% 8-queens.pl_
     queens(N, Qs) :-
         range(1, N, Ns),
         queens(Ns, [], Qs).

     queens(UnplacedQs, SafeQs, Qs) :-
         select(Q, UnplacedQs, UnplacedQs1),
         \+ attack(Q, SafeQs),
         queens(UnplacedQs1, [Q|SafeQs], Qs).
         queens([], Qs, Qs).

     attack(X, Xs) :- attack(X, 1, Xs).

     attack(X, N, [Y|_Ys]) :- X is Y + N.
     attack(X, N, [Y|_Ys]) :- X is Y - N.
     attack(X, N, [_Y|Ys]) :-
         N1 is N + 1,
         attack(X, N1, Ys).

     range(M, N, [M|Ns]) :-
         M < N,
         M1 is M + 1,
         range(M1, N, Ns).
     range(N, N, [N]).

     show_solution(Tcl, L) :-
         reverse(L, LR),
         tcl_eval(Tcl, [show_solution, br(LR)], _),
         tk_do_all_events.

     tk_do_all_events :-
         tk_do_one_event, !,
         tk_do_all_events.
     tk_do_all_events.

     :- setup.

   And here is the Tcl/Tk part, which we have covered in bits and pieces
but here is the whole thing. We have added an enhancement where when
the mouse is moved over one of the queens, the squares that the queen
attacks are highlighted. Move the mouse away and the board reverts to
normal. This is an illustration of how the Tcl/Tk `bind' feature can be
used.  The code is in `library('tcltk/examples/8-queens.tcl')':

                                                       _# 8-queens.tcl_
     #! /usr/bin/wish
     # create an 8x8 grid of labels
     proc setup_display { } {
         frame .queens -background black
         pack .queens

         for {set y 1} {$y <= 8} {incr y} {
             for {set x 1} {$x <= 8} {incr x} {

                 # create a label and display a queen in it
                 label .queens.$x-$y -bitmap @bitmaps/q64s.bm -relief flat

                 # color alternate squares with different colors
                 # to create the chessboard pattern
                 if { [expr ($x + $y) % 2] } {
                     .queens.$x-$y config -background #ffff99
                 } else {
                     .queens.$x-$y config -background #66ff99
                 }

                 # set foreground to the background color to
                 # make queen image invisible
                 .queens.$x-$y config -foreground [.queens.$x-$y cget -background]

                 # bind the mouse to highlight the squares attacked by a
                 # queen on this square
                 bind .queens.$x-$y <Enter> "highlight_attack on $x $y"
                 bind .queens.$x-$y <Leave> "highlight_attack off $x $y"

                 # arrange the queens in a grid
                 grid .queens.$x-$y -row $y -column $x -padx 1 -pady 1

                 }
            }
     }

                                                       _# 8-queens.tcl_
     # clear a whole column
     proc reset_column { column } {
         for {set y 1 } { $y <= 8 } {incr y} {
             set_queens $column $y ""
         }
     }

     # place or unplace a queen
     proc set_queens { x y v } {
         if { $v == "Q" } {
             .queens.$x-$y config -foreground black
         } else {
             .queens.$x-$y config -foreground [.queens.$x-$y cget -background]
         }
     }

     # place a queen on a column
     proc place_queen { x y } {
         reset_column $x
         set_queens $x $y Q
     }

     # clear the whole board by clearing each column in turn
     proc clear_board { } {
         for { set x 1 } {$x <= 8} {incr x} {
             reset_column $x
         }
     }

     # given a solution as a list of queens in column positions
     # place each queen on the board
     proc show_solution { solution } {
         clear_board
         set x 1
         foreach y $solution {
             place_queen $x $y
             incr x
         }
     }

                                                       _# 8-queens.tcl_
     proc highlight_square { mode x y } {
         # check if the square we want to highlight is on the board
         if { $x < 1 || $y < 1 || $x > 8 || $y > 8 } { return };

         # if turning the square on make it red,
         # otherwise determine what color it should be and set it to that
         if { $mode == "on" } { set color red } else {
             if { [expr ($x + $y) % 2] } { set color "#ffff99" } else {
                 set color "#66ff99" }
             }

             # get the current settings
             set bg [ .queens.$x-$y cget -bg ]
             set fg [ .queens.$x-$y cget -fg ]

             # if the current foreground and background are the same
             # there is no queen there
             if { $bg == $fg } {
                 # no queens
                 .queens.$x-$y config -bg $color -fg $color
              } else {
                  .queens.$x-$y config -bg $color
         }
     }

     proc highlight_attack { mode x y } {
         # get current colors of square at x y
         set bg [ .queens.$x-$y cget -bg ]
         set fg [ .queens.$x-$y cget -fg ]

         # no queen there, give up
         if { $bg == $fg } { return };

         # highlight the sqaure the queen is on
         highlight_square $mode $x $y

         # highlight vertical and horizontal
         for { set i 1 } {$i <= 8} {incr i} {
             highlight_square $mode $x $i
             highlight_square $mode $i $y
         }

         # highlight diagonals
         for { set i 1} { $i <= 8} {incr i} {
             highlight_square $mode [expr $x+$i] [expr $y+$i]
             highlight_square $mode [expr $x-$i] [expr $y-$i]
             highlight_square $mode [expr $x+$i] [expr $y-$i]
             highlight_square $mode [expr $x-$i] [expr $y+$i]
         }
     }

                                                       _# 8-queens.tcl_
     proc disable_next {} {
         .next config -state disabled
     }

     setup_display

     # button for sending a 'next' message
     button .next -text next -command {prolog_event next}
     pack .next

     # button for sending a 'stop' message
     button .stop -text stop -command {prolog_event stop}
     pack .stop


 [image src="images/tcltk8queens.png" text="" ]             8-Queens Solution, Attacked Squares Highlighted


File: sicstus.info,  Node: Quick Reference,  Next: Resources,  Prev: Putting It All Together,  Up: lib-tcltk

10.41.6 Quick Reference
-----------------------

* Menu:

* Command Format Summary:: Command Format Summary
* Predicates for Prolog to Interact with Tcl Interpreters:: Predicates for Prolog to Interact with Tcl Interpreters
* Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions:: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions
* Commands for Tcl Interpreters to Interact with The Prolog System:: Commands for Tcl Interpreters to Interact with The Prolog System


File: sicstus.info,  Node: Command Format Summary,  Next: Predicates for Prolog to Interact with Tcl Interpreters,  Up: Quick Reference

10.41.6.1 Command Format Summary
................................

COMMAND        ::= NAME                      
               | `codes("code-list")'        
               | `write("term")'             
               | `writeq("term")'            
               | `write_canonical("term")'   
               | `format(FMT,ARGS)'          
               | `dq(COMMAND)'               
               | `br(COMMAND)'               
               | `sqb(COMMAND)'              
               | `min(COMMAND)'              
               | `dot(LISTOFNAMES)'          
               | `list(LISTOFCOMMANDS)'      
               | LISTOFCOMMANDS              

FMT            ::= "atom"                    

NAME           ::= "atom"                    { other than `[]' }
               | "number"                    

LISTOFCOMMANDS ::= `[]'                      
               | `[ COMMAND |                
               LISTOFCOMMANDS ]'             

LISTOFNAMES    ::= `[]'                      
               | `[ NAME | LISTOFNAMES ]'    

ARGS           ::= `[]'                      
               | `[ "term" | ARGS ]'         

where

ATOM
NUMBER
     denote their printed representations

`codes(PROLOGSTRING)'
     denotes the string represented by PROLOGSTRING (a code-list)

`write(TERM)'
`writeq(TERM)'
`write_canonical(TERM)'
     denotes the string that is printed by the corresponding built-in
     predicate

`format(FMT, ARGS)'
     denotes the string that is printed by the corresponding built-in
     predicate

`dq(COMMAND)'
     denotes the string specified by COMMAND, enclosed in double quotes

`br(COMMAND)'
     denotes the string specified by COMMAND, enclosed in curly brackets

`sqb(COMMAND)'
     denotes the string specified by COMMAND, enclosed in square
     brackets

`min(COMMAND)'
     denotes the string specified by COMMAND, immediately preceded by a
     hyphen

`dot(LISTOFNAME)'
     denotes the widget path specified by LISTOFNAME, preceded by and
     separated by dots

`list(LISTOFCOMMANDS)'
     denotes the TCL list with one element for each element in
     LISTOFCOMMANDS.

LISTOFCOMMANDS
     denotes the string denoted by each element, separated by spaces


File: sicstus.info,  Node: Predicates for Prolog to Interact with Tcl Interpreters,  Next: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions,  Prev: Command Format Summary,  Up: Quick Reference

10.41.6.2 Predicates for Prolog to Interact with Tcl Interpreters
.................................................................

`tcl_new(-TCLINTERPRETER)'
     Create a Tcl interpreter and return a handle to it in the variable
     INTERPRETER.

`tcl_delete(+TCLINTERPRETER)'
     Given a handle to a Tcl interpreter in variable TCLINTERPRETER, it
     deletes the interpreter from the system.

`tcl_eval(+TCLINTERP, +COMMAND, -RESULT)'
     Evaluates the Tcl command term  given in COMMAND in the Tcl
     interpreter handle provided in TCLINTERPRETER.  The result of the
     evaluation is returned as a string in RESULT.

`tcl_event(+TCLINTERP, +COMMAND, -EVENTS)'
     Evaluates the Tcl command term given in COMMAND in the Tcl
     interpreter handle provided in TCLINTERPRETER.  The first Prolog
     events arising from the evaluation is returned as a list in
     EVENTS.  Blocks until there is something on the event queue.


File: sicstus.info,  Node: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions,  Next: Commands for Tcl Interpreters to Interact with The Prolog System,  Prev: Predicates for Prolog to Interact with Tcl Interpreters,  Up: Quick Reference

10.41.6.3 Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions
....................................................................................

`tk_new(+OPTIONS, -INTERP)'
     Create a Tcl interpreter with Tk extensions.

     OPTIONS should be a list of options described following:

    `top_level_events'
          This allows Tk events to be handled while Prolog is waiting
          for terminal input; for example, while the Prolog system is
          waiting for input at the top-level prompt. Without this
          option, Tk events are not serviced while the Prolog system is
          waiting for terminal input.

    `name(+APPLICATIONNAME)'
          This gives the main window a title APPLICATIONNAME.  This
          name is also used for communicating between Tcl/Tk
          applications via the Tcl `send' command.

    `display(+DISPLAY)'
          (This is X windows specific.) Gives the name of the screen on
          which to create the main window. If this is not given, the
          default display is determined by the `DISPLAY' environment
          variable.

`tk_do_one_event'
`tk_do_one_event(+OPTIONS)'
     Passes control to Tk to handle a single event before passing
     control back to Prolog. The type of events handled is passed
     through the OPTIONS variable, a list of event types and options.

     The OPTIONS list can contain the following atoms:

    `tk_dont_wait'
          don't wait for new events, process only those that are ready

    `tk_window_events'
          process window events

    `tk_file_events'
          process file events

    `tk_timer_events'
          process timer events

    `tk_idle_events'
          process `Tcl_DoWhenIdle' events

    `tk_all_events'
          process any event

     Calling `tk_do_one_event/0' is equivalent to a call to
     `tk_do_one_event/1' with all flags set. If the `tk_dont_wait' flag
     is set and there is no event to handle, the call will fail.

`tk_next_event(+OPTIONS, -EVENT)'
`tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)'
     These predicates are similar to `tk_do_one_event/[0,1]' except
     that they processes Tk events until is at least one Prolog event
     happens, when they succeed binding EVENT to the first term on the
     Prolog event queue associated with the interpreter TCLINTERPRETER.

`tk_main_loop'
     Pass control to Tk until all windows in all Tcl/Tk interpreters
     are gone.

`tk_main_window(+TCLINTERPRETER, -TKWINDOW)'
     Return in TKWINDOW a reference to the main window of a Tcl/Tk
     interpreter with handle passed in TCLINTERPRETER.

`tk_destroy_window(+TKWINDOW)'
     Destroy a window or widget.

`tk_make_window_exist(+TKWINDOW)'
     Force display of a window or widget.

`tk_num_main_windows(-NUMBEROFWINDOWS)'
     Return in NUMBEROFWINDOWS the total number of Tk main windows
     existing in the system.


File: sicstus.info,  Node: Commands for Tcl Interpreters to Interact with The Prolog System,  Prev: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions,  Up: Quick Reference

10.41.6.4 Commands for Tcl Interpreters to Interact with The Prolog System
..........................................................................

`prolog'
     Evaluate a Prolog expression from Tcl.

`prolog_event'
     Place a Prolog term on the Prolog event queue from inside Tcl.


File: sicstus.info,  Node: Resources,  Prev: Quick Reference,  Up: lib-tcltk

10.41.7 Resources
-----------------

We don't know of any resources out there specifically for helping with
creating Prolog applications with Tcl/Tk interfaces.  Instead we list
here some resources for Tcl/Tk, which may help readers to build the
Tcl/Tk side of the application.

* Menu:

* Web Sites:: Web Sites
* Books:: Books
* TclTk Manual Pages:: Manual Pages


File: sicstus.info,  Node: Web Sites,  Next: Books,  Up: Resources

10.41.7.1 Web Sites
...................

The home of Tcl/Tk is at:
     `http://tcl.sourceforge.net'

   The Tcl Developer Xchange site is at:
     `http://www.tcl.tk'


File: sicstus.info,  Node: Books,  Next: TclTk Manual Pages,  Prev: Web Sites,  Up: Resources

10.41.7.2 Books
...............

There are a surprising number of books on Tcl/Tk, extensions to Tcl/Tk,
and Tk as an extension to other languages.  Here we mention just a few
of the well-known books that will get you started with building Tcl/Tk
GUIs, which can then be interfaced to your Prolog applications.

   * Brent Welch, `Practical Programming in Tcl and Tk'. Prentice Hall,
     1999. 3rd Edition ISBN: 0-13-022028-0 `http://www.beedub.com/book/'

   * John Ousterhout, `Tcl and the Tk Toolkit'. Addison-Wesley, 1994,
     ISBN 0-201-63337-X

   * Paul Raines, `Tcl/Tk Pocket Reference', 1st Ed., Oct. 1998, ISBN
     1-56592-498-3

   * Paul Raines & Jeff Tranter, `Tcl/Tk in a Nutshell', 1st Ed., March
     1999, 1-56592-433-9

   Also visit the Tcl/Tk wiki:

     `http://wiki.tcl.tk/'


File: sicstus.info,  Node: TclTk Manual Pages,  Prev: Books,  Up: Resources

10.41.7.3 Manual Pages
......................

Complete manual pages in various formats and for various versions of
the Tcl/Tk library can be found at the Tcl/Tk web site:

     `http://www.tcl.tk/'


File: sicstus.info,  Node: lib-gauge,  Next: lib-jasper,  Prev: lib-tcltk,  Up: The Prolog Library

10.42 The Gauge Profiling Tool--`library(gauge)'
================================================

The Gauge library package is a graphical interface to the SICStus
built-in predicates `profile_data/1' and `profile_reset/0'.  *Note
Execution Profiling:: for more information about execution profiling.
The interface is based on Tcl/Tk (*note lib-tcltk::).

   The SICStus IDE (*note SPIDER::) can also show profiling
information. This makes the Gauge library largely obsolescent.

`view   "since release 4.2"'
     Creates a graphical user interface for viewing the profile data
     accumulated so far.  When the display first comes up it is blank
     except for the control panel.  A screen shot is shown below.


 [image src="images/gauge.png" text="" ]                     Gauge graphical user interface

The menus and buttons on the control panel are used as follows:

_Specification_
     Selects what statistics to display.  One of:

    _Calls_
          The number of times a predicate was called.

    _Instructions_
          The number of abstract instructions executed, plus two times
          the number of choice point accesses.

    _Choicepoints_
          Number of choicepoints accessed (saved or restored).

_Sort Order_
     Selects the sort order of the histogram.  One of:

    _Alphabetic_
          Sort the bars in alphabetic order.

    _Descending values_
          Sort the bars by descending values.

    _Ascending values_
          Sort the bars by ascending values.

    _Top 40_
          Show just the 40 highest values in descending order.


_Scale_
     Controls the scaling of the bars.  One of:

    _Linear_
          Display values with a linear scale.

    _Logarithmic_
          Display values with a logarithmic scale.


_Show_
     Controls whether to show bars with zero counts.  One of:

    _All_
          Show all values in the histogram.

    _No zero values_
          Show only non-zero values.


_Font_
     The font used in the histogram chart.

_Calculate_
     Calculates the values according to the current settings. The
     values are displayed in a histogram.

_Reset_
     The execution counters of the selected predicates and clauses are
     reset.

_Print_
     A choice of printing the histogram on a Postscript printer, or to
     a file.

_Help_
     Shows a help text.

_Quit_
     Quits Gauge and closes its windows.

   By clicking on the bars of the histogram, the figures are displayed
in the _Value Info_ window.


File: sicstus.info,  Node: lib-jasper,  Next: lib-prologbeans,  Prev: lib-gauge,  Up: The Prolog Library

10.43 Jasper Interface--`library(jasper)'
=========================================

* Menu:

* Jasper Overview:: Jasper Overview
* Getting Started:: Getting Started
* Calling Prolog from Java:: Calling Prolog from Java
* Jasper Package Class Reference:: Jasper Package Class Reference
* Java Exception Handling:: Java Exception Handling
* SPTerm and Memory:: SPTerm and Memory
* Java Threads:: Java Threads
* The Jasper Library: The Jasper Library


File: sicstus.info,  Node: Jasper Overview,  Next: Getting Started,  Up: lib-jasper

10.43.1 Jasper Overview
-----------------------

Jasper is a bi-directional interface between Java and SICStus. The
Java-side of the interface consists of a Java package
(`se.sics.jasper') containing classes representing the SICStus runtime
system (`SICStus', `SPTerm', etc).  The Prolog part is designed as a
library module (`library(jasper)').

   The library module `library(jasper)' (*note The Jasper Library::)
provides functionality for controlling the loading and unloading the JVM
(Java Virtual Machine), method call functionality (`jasper_call/4'),
and predicates for managing object references.

   Jasper can be used in two modes, depending on which system acts as
"Parent Application". If Java is the parent application, the SICStus
runtime kernel will be loaded into the JVM using the
`System.loadLibrary()' method (this is done indirectly when
instantiating a `SICStus' object). In this mode, SICStus is loaded as a
runtime system (*note Runtime Systems::).

   As of release 3.9, it is possible to use Jasper in multi threaded
mode. This means that several Java threads can call SICStus runtime via
a server thread. The communication between the client threads and the
server thread is hidden from the programmer, and the API is based on
Java `Interfaces', which are implemented both by the multi thread
capable classes and the pre-3.9 classes, which are restricted to single
threaded mode. The decision whether to run in single thread mode or in
multi threaded mode can thus be left until runtime.

   If SICStus is the parent application, Java will be loaded as a
foreign resource using the query `use_module(library(jasper))'. The
Java engine is initialized using `jasper_initialize/[1,2]'.

   * Some of the information in this chapter is a recapitulation of the
     information in *note Mixing C and Prolog::. The intention is that
     this chapter should be possible to read fairly independently.

   * Before proceeding, please read *note Jasper Notes:
     (relnotes)Jasper Notes.  It contains important information about
     requirements, availability, installation tips, limitations, and
     how to access other (online) Jasper/Java resources.


File: sicstus.info,  Node: Getting Started,  Next: Calling Prolog from Java,  Prev: Jasper Overview,  Up: lib-jasper

10.43.2 Getting Started
-----------------------

*Note Java: (relnotes)Getting Started for a detailed description of how
to get started using the interface. It addresses issues such as finding
SICStus from within Java and vice versa, setting the classpath
correctly, etc. If you have trouble in getting started with Jasper, read
that chapter before contacting SICStus Support.


File: sicstus.info,  Node: Calling Prolog from Java,  Next: Jasper Package Class Reference,  Prev: Getting Started,  Up: lib-jasper

10.43.3 Calling Prolog from Java
--------------------------------

Calling Prolog from Java is done by using the Java package
`se.sics.jasper'. This package contains a set of Java classes, which
can be used to create and manipulate terms, ask queries and request one
or more solutions. The functionality provided by this set of classes is
basically the same as the functionality provided by the C-Prolog
interface (*note Mixing C and Prolog::).

   It is possible to debug the Prolog code using the Prolog debugger,
either from the command line or from the SICStus Prolog IDE (SPIDER),
see *note Examples of Debugging Runtime Systems::.

   The usage is easiest described by some examples.

* Menu:

* Single Threaded Example:: Single Threaded Example
* Multi Threaded Example:: Multi Threaded Example
* Another Multi Threaded Example (Prolog Top-Level):: Another Multi Threaded Example (Prolog Top-Level)

