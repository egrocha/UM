This is info/sicstus.info, produced by makeinfo version 4.13 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 8 May 2014.


File: sicstus.info,  Node: lib-aggregate,  Next: lib-assoc,  Up: The Prolog Library

10.1 An Aggregation Operator for Data-Base-Style Queries--`library(aggregate)'
==============================================================================

Data base query languages usually provide so-called "aggregation"
operations.  Given a relation, aggregation specifies
   * a column of the relation

   * an operation, one of {sum,max,min,ave,var} or more

   One might, for example, ask

         PRINT DEPT,SUM(AREA) WHERE OFFICE(_ID,DEPT,AREA,_OCCUPANT)

   and get a table of <DEPARTMENT,TOTALAREA> pairs.  The Prolog
equivalent of this might be

         dept_office_area(Dept, TotalArea) :-
                 aggregate(sum(Area),
                     I^O^office(I,Dept,Area,O), TotalArea).

   where AREA is the column and `sum(_)' is the aggregation operator.
We can also ask who has the smallest office in each department:

         smallest_office(Dept, Occupant) :-
                 aggregate(min(Area),
                         I^O^office(I,Dept,Area,O), MinArea),
                 office(_, Dept, MinArea, Occupant).

   This module provides an aggregation operator in Prolog:

             aggregate(Template, Generator, Results)

   where:
   * TEMPLATE is OPERATOR(EXPRESSION) or  CONSTRUCTOR(ARG,...,ARG)

   * each ARG is OPERATOR(EXPRESSION)

   * OPERATOR is `sum | min | max'  {for now}

   * EXPRESSION is an arithmetic expression

   RESULTS is unified with a form of the same structure as TEMPLATE.

   Things like mean and standard deviation can be calculated from sums,
e.g. to find the average population of countries (defined as "if you
sampled people at random, what would be the mean size of their answers
to the question 'what is the population of your country?'?") we could do

     ?-  aggregate(x(sum(Pop),sum(Pop*Pop)),
                   Country^population(Country,Pop),
                   x(People,PeopleTimesPops)),
         AveragePop is PeopleTimesPops/People.

   Note that according to this definition, `aggregate/3' FAILS if there
are no solutions.  For `max(_)', `min(_)', and many other operations
(such as `mean(_)') this is the only sensible definition (which is why
`bagof/3' works that way).  Even if BAGOF/3 yielded an empty list,
AGGREGATE/3 would still fail.

   Concerning the minimum and maximum, it is convenient at times to
know Which term had the minimum or maximum value.  So we write

         min(Expression, Term)
         max(Expression, Term)

   and in the constructed term we will have

         min(MinimumValue, TermForThatValue)
         max(MaximumValue, TermForThatValue)

   So another way of asking who has the smallest office is

         smallest_office(Dept, Occupant) :-
                 aggregate(min(Area,O),
                         I^office(I,Dept,Area,O), min(_,Occupant)).

   Consider queries like

         aggregate(sum(Pay), Person^pay(Person,Pay), TotalPay)

   where for some reason `pay/2' might have multiple solutions.  (For
example, someone might be listed in two departments.)  We need a way of
saying "treat identical instances of the Template as a single instance,
UNLESS they correspond to different instances of a Discriminator."
That is what

         aggregate(Template, Discriminator, Generator, Results)

   does.

   Operations available:
`count'
     `sum(1)'

`sum(E)'
     sum of values of E

`min(E)'
     minimum of values of E

`min(E,X)'
     `min(E)' with corresponding instance of X

`max(E)'
     maximum of values of E

`max(E,X)'
     `max(E)' with corresponding instance of X

`set(X)'
     ordered set of instances of X

`bag(X)'
     list of instances of X in generated order.

     bagof(X, G, B) :- aggregate(bag(X),    G, L).
     setof(X, G, B) :- aggregate(set(X), X, G, L).

   Exported predicates:

`forall(:GENERATOR, :GOAL)'
     succeeds when GOAL is provable for each true instance of GENERATOR.
     Note that there is a sort of double negation going on in here (it
     is in effect a nested pair of failure-driven loops), so it will
     never bind any of the variables which occur in it.

`foreach(:GENERATOR, :GOAL)'
     for each proof of Generator in turn, we make a copy of GOAL with
     the appropriate substitution, then we execute these copies in
     sequence.  For example, `foreach(between(1,3,I), p(I))' is
     equivalent to `p(1), p(2), p(3)'.

     Note that this is not the same as `forall/2'.  For example,
     `forall(between(1,3,I), p(I))' is equivalent to `\+ \+ p(1), \+ \+
     p(2), \+ \+ p(3)'.

     The trick in `foreach/2' is to ensure that the variables of GOAL
     which do not occur in GENERATOR are restored properly.  (If there
     are no such variables, you might as well use `forall/2'.)

     Like `forall/2', this predicate does a failure-driven loop over the
     GENERATOR.  Unlike `forall/2', the GOALS are executed as an
     ordinary conjunction, and may succeed in more than one way.

`aggregate(+TEMPLATE, +DISCRIMINATOR, :GENERATOR, -RESULT)'
     is a generalisation of `setof/3' which lets you compute sums,
     minima, maxima, and so on.

`aggregate(+TEMPLATE, :GENERATOR, -RESULT)'
     is a generalisation of `findall/3' which lets you compute sums,
     minima, maxima, and so on.

`aggregate_all(+Template, +Discriminator, :Generator, -Result)'
     is like `aggregate/4' except that it will find at most one
     solution, and does not bind free variables in the GENERATOR.

`aggregate_all(+Template, :Generator, -Result)'
     is like `aggregate/3' except that it will find at most one
     solution, and does not bind free variables in the GENERATOR.

`free_variables(:Goal, +Bound, +Vars0, -Vars)'
     binds VARS to the union of VARS0 with the set of _free_ variables
     in GOAL, that is the set of variables which are captured neither
     by BOUND nor by any internal quantifiers or templates in GOAL.  We
     have to watch out for `setof/3' and `bagof/3' themselves, for the
     explicit existential quantifier `VARS^GOAL', and for things like
     `\+(_)' which might look as though they bind variables but can't.

`term_variables(+TERM, +VARS0, -VARS)'
     binds VARS to a union of VARS0 and the variables which occur in
     TERM.  This doesn't take quantifiers into account at all.

     New code should consider the built in `term_variables/2' which is
     likely to be faster, and works for cyclic terms.

     Could be defined as:

          term_variables(Term, Vars0, Vars) :-
          	nonvar(Term), !,
          	(   foreacharg(Arg,Term),
          	    fromto(Vars0,S0,S,Vars)
          	do  term_variables(Arg, S0, S)
          	).
          term_variables(Term, Vars0, Vars) :-
          	(   foreach(X,Vars0),
          	    param(Term)
          	do  X\==Term
          	), !,
              Vars = [Term|Vars0].
          term_variables(_, Vars, Vars).


File: sicstus.info,  Node: lib-assoc,  Next: lib-atts,  Prev: lib-aggregate,  Up: The Prolog Library

10.2 Association Lists--`library(assoc)'
========================================

This library provides a binary tree implementation of "association
lists". The binary tree is _not_ kept balanced, as opposed to
`library(avl)', which provides similar functionality based on balanced
AVL trees.

   Exported predicates:

`empty_assoc(?ASSOC)'
     is true when ASSOC is an empty assoc.

`assoc_to_list(+ASSOC, -LIST)'
     assumes that ASSOC is a proper "assoc" tree, and is true when LIST
     is a list of KEY-VALUE pairs in ascending order with no duplicate
     KEYS specifying the same finite function as ASSOC.  Use this to
     convert an assoc to a list.

`gen_assoc(?KEY, +ASSOC, ?VALUE)'
     assumes that ASSOC is a proper "assoc" tree, and is true when KEY
     is associated with VALUE in ASSOC.  Use this to enumerate KEYS and
     VALUES in the ASSOC, or to find KEYS associated with a particular
     VALUE.  If you want to look up a particular KEY, you should use
     `get_assoc/3'.  Note that this predicate is not determinate.  If
     you want to maintain a finite bijection, it is better to maintain
     two assocs than to drive one both ways.  The KEYS and VALUES are
     enumerated in ascending order of KEYS.

`get_assoc(+KEY, +ASSOC, -VALUE)'
     assumes that ASSOC is a proper "assoc" tree.  It is true when KEY
     is identical to (`==') one of the keys in ASSOC, and Value unifies
     with the associated value.  Note that since we use the term
     ordering to identify keys, we obtain logarithmic access, at the
     price that it is not enough for the KEY to unify with a key in
     ASSOC, it must be identical.  This predicate is determinate.  The
     argument order follows the pattern established by the built-in
     predicate `arg/3' (called the `arg/3', or selector, rule):
              PREDICATE(INDICES, STRUCTURE, ELEMENT).
     The analogy with `arg(N, TERM, ELEMENT)' is that
              KEY:N :: ASSOC:TERM :: VALUE:ELEMENT.

`get_next_assoc(+KEY, +ASSOC, -KNEXT, -VNEXT)'
     is true when KNEXT is the smallest key in ASSOC such that
     KNEXT@>KEY, and VNEXT is the value associated with KNEXT.  If
     there is no such KNEXT, `get_next_assoc/4' naturally fails.  It
     assumes that ASSOC is a proper assoc.  KEY should normally be
     ground.  Note that there is no need for KEY to be in the
     association at all.  You can use this predicate in combination
     with `min_assoc/3' to traverse an association tree; but if there
     are N pairs in the tree the cost will be O(N LG N).  If you want
     to traverse all the pairs, calling `assoc_to_list/2' and walking
     down the list will take O(N) time.

`get_prev_assoc(+KEY, +ASSOC, -KPREV, -VPREV)'
     is true when KPREV is the largest key in ASSOC such that
     KPREV@<KEY, and VPREV is the value associated with KPREV.  You can
     use this predicate in combination with `max_assoc/3' to traverse
     an assoc.  See the notes on `get_next_assoc/4'.

`is_assoc(+THING)'
     is true when THING is a (proper) association tree.  If you use the
     routines in this file, you have no way of constructing a tree with
     an unbound tip, and the heading of this file explicitly warns
     against using variables as keys, so such structures are NOT
     recognised as being association trees.  Note that the code relies
     on variables (to be precise, the first anonymous variable in
     `is_assoc/1') being `@<' than any non-variable.

`list_to_assoc(+LIST, -ASSOC)'
     is true when LIST is a proper list of KEY-VAL pairs (in any order)
     and ASSOC is an association tree specifying the same finite
     function from KEYS to VALUES.  Note that the list should not
     contain any duplicate keys.  In this release, `list_to_assoc/2'
     doesn't check for duplicate keys, but the association tree which
     gets built won't work.

`ord_list_to_assoc(+LIST, -ASSOC)'
     is a version of `list_to_assoc/2' which trusts you to have sorted
     the list already.  If you pair up an ordered set with suitable
     values, calling this instead will save the sort.

`map_assoc(:PRED, +ASSOC)'
     is true when ASSOC is a proper association tree, and for each
     KEY->VAL pair in ASSOC, the proposition PRED(VAL) is true.  PRED
     must be a closure, and ASSOC should be proper.  There should be a
     version of this predicate which passes KEY to PRED as well as VAL,
     but there isn't.

`map_assoc(:PRED, ?OLDASSOC, ?NEWASSOC)'
     is true when OLDASSOC and NEWASSOC are association trees of the
     same shape (at least one of them should be provided as a proper
     assoc, or `map_assoc/3' may not terminate), and for each KEY, if
     KEY is associated with OLD in OLDASSOC and with NEW in NEWASSOC,
     the proposition PRED(OLD,NEW) is true.  Normally we assume that
     PRED is a function from OLD to NEW, but the code does not require
     that.  There should be a version of this predicate which passes
     KEY to PRED as well as OLD and NEW, but there isn't.  If you'd
     have a use for it, please tell us.

`max_assoc(+ASSOC, -KEY, -VAL)'
     is true when KEY is the largest KEY in ASSOC, and VAL is the
     associated value.  It assumes that ASSOC is a proper assoc.  This
     predicate is determinate.  If ASSOC is empty, it just fails
     quietly; an empty set can have no largest element!

`min_assoc(+ASSOC, -KEY, -VAL)'
     is true when KEY is the smallest KEY in ASSOC, and VAL is the
     associated value.  It assumes that ASSOC is a proper assoc.  This
     predicate is determinate.  If ASSOC is empty, it just fails
     quietly; an empty set can have no smallest element!

`portray_assoc(+ASSOC)'
     writes an association tree to the current output stream in a
     pretty form so that you can easily see what it is.  Note that an
     association tree written out this way can NOT be read back in.
     For that, use `writeq/1'.  The point of this predicate is to get
     association trees displayed nicely by `print/1'.

`put_assoc(+KEY, +OLDASSOC, +VAL, -NEWASSOC)'
     is true when OLDASSOC and NEWASSOC define the same finite function,
     except that NEWASSOC associates VAL with KEY.  OLDASSOC need not
     have associated any value at all with Key,


File: sicstus.info,  Node: lib-atts,  Next: lib-avl,  Prev: lib-assoc,  Up: The Prolog Library

10.3 Attributed Variables--`library(atts)'
==========================================

This package implements attributed variables.  It provides a means of
associating with variables arbitrary attributes, i.e. named properties
that can be used as storage locations as well as to extend the default
unification algorithm when such variables are unified with other terms
or with each other.  This facility was primarily designed as a clean
interface between Prolog and constraint solvers, but has a number of
other uses as well.  The basic idea is due to Christian Holzbaur and he
was actively involved in the final design.  For background material,
see the dissertation [Holzbaur 90].

   The package provides a means to declare and access named attributes
of variables.  The attributes are compound terms whose arguments are
the actual attribute values.  The attribute names are _private_ to the
module in which they are defined.  They are defined with a declaration

     :- attribute ATTRIBUTESPEC, ..., ATTRIBUTESPEC.

where each ATTRIBUTESPEC has the form (NAME/ARITY).  There must be at
most one such declaration in a module MODULE.

   Having declared some attribute names, these attributes can now be
added, updated and deleted from unbound variables.  For each declared
attribute name, any variable can have at most one such attribute
(initially it has none).

   The declaration causes the following two access predicates to become
defined by means of the `goal_expansion/5' mechanism.  They take a
variable and an ACCESSSPEC as arguments where an ACCESSSPEC is either
`+(ATTRIBUTE)', `-(ATTRIBUTE)', or a list of such.  The `+' prefix may
be dropped for convenience.  The meaning of the `+'/`-' prefix is
documented below:

`MODULE:get_atts(-VAR, ?ACCESSSPEC)'
     Gets the attributes of VAR according to ACCESSSPEC.  If ACCESSSPEC
     is unbound, it will be bound to a list of all set attributes of
     VAR.  Non-variable terms cause a type error to be raised.  The
     prefixes in the ACCESSSPEC have the following meaning:
    `+(ATTRIBUTE)'
          The corresponding actual attribute must be present and is
          unified with ATTRIBUTE.

    `-(ATTRIBUTE)'
          The corresponding actual attribute must be absent.  The
          arguments of ATTRIBUTE are ignored, only the name and arity
          are relevant.

`MODULE:put_atts(-VAR, +ACCESSSPEC)'
     Sets the attributes of VAR according to ACCESSSPEC.  Non-variable
     terms cause a type error to be raised.  The effects of
     `put_atts/2' are undone on backtracking.
    `+(ATTRIBUTE)'
          The corresponding actual attribute is set to ATTRIBUTE.  If
          the actual attribute was already present, it is simply
          replaced.

    `-(ATTRIBUTE)'
          The corresponding actual attribute is removed.  If the actual
          attribute was already absent, nothing happens.

   A module that contains an attribute declaration has an opportunity
to extend the default unification algorithm by defining the following
predicate:

`MODULE:verify_attributes(-VAR, +VALUE, -GOALS)   "hook"'
     This predicate is called whenever a variable VAR that might have
     attributes in MODULE is about to be bound to VALUE (it might have
     none).  The unification resumes after the call to
     `verify_attributes/3'.  VALUE is a non-variable term, or another
     attributed variable.  VAR might have no attributes present in
     MODULE; the unification extension mechanism is not sophisticated
     enough to filter out exactly the variables that are relevant for
     MODULE.

     `verify_attributes/3' is called _before_ VAR has actually been
     bound to VALUE.  If it fails, the unification is deemed to have
     failed.  It may succeed nondeterminately, in which case the
     unification might backtrack to give another answer.  It is
     expected to return, in GOALS, a list of goals to be called _after_
     VAR has been bound to VALUE.  Finally, after calling GOALS, any
     goals blocked on VAR are called.

     `verify_attributes/3' may invoke arbitrary Prolog goals, but VAR
     should _not_ be bound by it.  Binding VAR will result in undefined
     behavior.

     If VALUE is a non-variable term, `verify_attributes/3' will
     typically inspect the attributes of VAR and check that they are
     compatible with VALUE and fail otherwise.  If VALUE is another
     attributed variable, `verify_attributes/3' will typically copy the
     attributes of VAR over to VALUE, or merge them with VALUE's, in
     preparation for VAR to be bound to VALUE.  In either case,
     `verify_attributes/3' may determine VAR's current attributes by
     calling `get_atts(VAR,LIST)' with an unbound LIST.

     In the case when a single unification binds multiple attributed
     variables, first all such bindings are _undone_, then the
     following actions are carried out for each relevant variable:

       1. For each relevant module M, `M:verify_attributes/3' is
          called, collecting a list of returned GOALS.

       2. The variable binding is _redone_.

       3. Any GOALS are called.

       4. Any blocked goals are called.


   An important use for attributed variables is in implementing
coroutining facilities as an alternative or complement to the built-in
coroutining mechanisms.  In this context it might be useful to be able
to interpret some of the attributes of a variable as a goal that is
blocked on that variable.  Certain built-in predicates (`frozen/2',
`copy_term/3') and the Prolog top-level need to access blocked goals,
and so need a means of getting the goal interpretation of attributed
variables by calling:

`MODULE:attribute_goal(-VAR, -GOAL)   "hook"'
     This predicate is called in each module that contains an attribute
     declaration, when an interpretation of the attributes as a goal is
     needed, in particular in `frozen/2', `copy_term/3' and the Prolog
     top-level.  It should unify GOAL with the interpretation, or
     merely fail if no such interpretation is available.

   An important use for attributed variables is to provide an interface
to constraint solvers.  An important function for a constraint solver
in the constraint logic programming paradigm is to be able to perform
projection of the residual constraints onto the variables that occurred
in the top-level query.  A module that contains an attribute
declaration has an opportunity to perform such projection of its
residual constraints by defining the following predicate:

`MODULE:project_attributes(+QUERYVARS, +ATTRVARS)   "hook"'
     This predicate is called by the Prolog top level in each module
     that contains an attribute declaration.  QUERYVARS is the list of
     variables occurring in the query, or in terms bound to such
     variables, and ATTRVARS is a list of possibly attributed variables
     created during the execution of the query.  The two lists of
     variables may or may not be disjoint.

     If the attributes on ATTRVARS can be interpreted as constraints,
     this predicate will typically "project" those constraints onto the
     relevant QUERYVARS.  Ideally, the residual constraints will be
     expressed entirely in terms of the QUERYVARS, treating all other
     variables as existentially quantified.  Operationally,
     `project_attributes/2' must remove all attributes from ATTRVARS,
     and add transformed attributes representing the projected
     constraints to some of the QUERYVARS.

     Projection has the following effect on the Prolog top-level.  When
     the top-level query has succeeded, `project_attributes/2' is
     called first.  The top-level then prints the answer substition and
     residual constraints.  While doing so, it searches for attributed
     variables created during the execution of the query.  For each
     such variable, it calls `attribute_goal/2' to get a printable
     representation of the constraint encoded by the attribute.  Thus,
     `project_attributes/2' is a mechanism for controlling how the
     residual constraints should be displayed at top-level.

     The exact definition of `project_attributes/2' is constraint system
     dependent, but *note Answer Constraints:: and *note CLPQR
     Projection:: for details about projection in CLPFD and CLP(Q,R)
     respectively.

   In the following example we sketch the implementation of a finite
domain "solver".  Note that an industrial strength solver would have to
provide a wider range of functionality and that it quite likely would
utilize a more efficient representation for the domains proper.  The
module exports a single predicate `domain(-VAR,?DOMAIN)', which
associates DOMAIN (a list of terms) with VAR.  A variable can be
queried for its domain by leaving DOMAIN unbound.

   We do not present here a definition for `project_attributes/2'.
Projecting finite domain constraints happens to be difficult.

                                                          _% domain.pl_
     :- module(domain, [domain/2]).

     :- use_module(library(atts)).
     :- use_module(library(ordsets), [
             ord_intersection/3,
             ord_intersect/2,
             list_to_ord_set/2
        ]).

     :- attribute dom/1.

     verify_attributes(Var, Other, Goals) :-
             get_atts(Var, dom(Da)), !,          % are we involved?
             (   var(Other) ->                   % must be attributed then
                 (   get_atts(Other, dom(Db)) -> %   has a domain?
                     ord_intersection(Da, Db, Dc),
                     Dc = [El|Els],              % at least one element
                     (   Els = [] ->             % exactly one element
                         Goals = [Other=El]      % implied binding
                     ;   Goals = [],
                         put_atts(Other, dom(Dc))% rescue intersection
                     )
                 ;   Goals = [],
                     put_atts(Other, dom(Da))    % rescue the domain
                 )
             ;   Goals = [],
                 ord_intersect([Other], Da)      % value in domain?
             ).
     verify_attributes(_, _, []).                % unification triggered
                                                 % because of attributes
                                                 % in other modules

     attribute_goal(Var, domain(Var,Dom)) :-     % interpretation as goal
             get_atts(Var, dom(Dom)).

     domain(X, Dom) :-
             var(Dom), !,
             get_atts(X, dom(Dom)).
     domain(X, List) :-
             list_to_ord_set(List, Set),
             Set = [El|Els],                     % at least one element
             (   Els = [] ->                     % exactly one element
                 X = El                          % implied binding
             ;   put_atts(Fresh, dom(Set)),
                 X = Fresh                       % may call
                                                 % verify_attributes/3
             ).

   Note that the "implied binding" `Other=El' was deferred until after
the completion of `verify_attribute/3'.  Otherwise, there might be a
danger of recursively invoke `verify_attribute/3', which might bind
`Var', which is not allowed inside the scope of `verify_attribute/3'.
Deferring unifications into the third argument of `verify_attribute/3'
effectively serializes th calls to `verify_attribute/3'.

   Assuming that the code resides in the file `domain.pl', we can load
it via:

     | ?- use_module(domain).

   Let's test it:

     | ?- domain(X,[5,6,7,1]), domain(Y,[3,4,5,6]), domain(Z,[1,6,7,8]).

     domain(X,[1,5,6,7]),
     domain(Y,[3,4,5,6]),
     domain(Z,[1,6,7,8])

     | ?- domain(X,[5,6,7,1]), domain(Y,[3,4,5,6]), domain(Z,[1,6,7,8]),
          X=Y.

     Y = X,
     domain(X,[5,6]),
     domain(Z,[1,6,7,8])

     | ?- domain(X,[5,6,7,1]), domain(Y,[3,4,5,6]), domain(Z,[1,6,7,8]),
          X=Y, Y=Z.

     X = 6,
     Y = 6,
     Z = 6

   To demonstrate the use of the GOALS argument of
`verify_attributes/3', we give an implementation of `freeze/2'.  We
have to name it `myfreeze/2' in order to avoid a name clash with the
built-in predicate of the same name.

                                                        _% myfreeze.pl_
     :- module(myfreeze, [myfreeze/2]).

     :- use_module(library(atts)).

     :- attribute frozen/1.

     verify_attributes(Var, Other, Goals) :-
             get_atts(Var, frozen(Fa)), !,       % are we involved?
             (   var(Other) ->                   % must be attributed then
                 (   get_atts(Other, frozen(Fb)) % has a pending goal?
                 ->  put_atts(Other, frozen((Fa,Fb))) % rescue conjunction
                 ;   put_atts(Other, frozen(Fa)) % rescue the pending goal
                 ),
                 Goals = []
             ;   Goals = [Fa]
             ).
     verify_attributes(_, _, []).

     attribute_goal(Var, Goal) :-                % interpretation as goal
             get_atts(Var, frozen(Goal)).

     myfreeze(X, Goal) :-
             put_atts(Fresh, frozen(Goal)),
             Fresh = X.

   Assuming that this code lives in file `myfreeze.pl', we would use it
via:

     | ?- use_module(myfreeze).
     | ?- myfreeze(X,print(bound(x,X))), X=2.

     bound(x,2)                      % side-effect
     X = 2                           % bindings

   The two solvers even work together:

     | ?- myfreeze(X,print(bound(x,X))), domain(X,[1,2,3]),
          domain(Y,[2,10]), X=Y.

     bound(x,2)                      % side-effect
     X = 2,                          % bindings
     Y = 2

   The two example solvers interact via bindings to shared attributed
variables only.  More complicated interactions are likely to be found
in more sophisticated solvers.  The corresponding `verify_attributes/3'
predicates would typically refer to the attributes from other known
solvers/modules via the module prefix in `MODULE:get_atts/2'.


File: sicstus.info,  Node: lib-avl,  Next: lib-bags,  Prev: lib-atts,  Up: The Prolog Library

10.4 AVL Trees--`library(avl)'
==============================

This library module provides an AVL tree implementation of "association
lists". The binary tree _is_ kept balanced, as opposed to
`library(assoc)', which provides similar functionality based on binary
trees that are not kept balanced.

   Exported predicates:

`empty_avl(?AVL)'
     is true when AVL is an empty AVL tree.

`avl_to_list(+AVL, -LIST)'
     assumes that AVL is a proper AVL tree, and is true when LIST is a
     list of KEY-VALUE pairs in ascending order with no duplicate keys
     specifying the same finite function as AVL.  Use this to convert
     an AVL to an ordered list.

`is_avl(+AVL)'
     is true when AVL is a (proper) AVL tree.  It checks both the order
     condition (that the keys are in ascending order as you go from left
     to right) and the height balance condition.  This code relies on
     variables (to be precise, the first anonymous variable in is_avl/1)
     being `@<' than any non-variable.  in strict point of fact you
     _can_ construct an AVL tree with variables as keys, but `is_avl/1'
     doesn't believe it, and it is not good taste to do so.

`avl_domain(+AVL, -DOMAIN)'
     unifies DOMAIN with the ordered set representation of the domain
     of the AVL tree (the keys of it).  As the keys are in ascending
     order with no duplicates, we just read them off like
     `avl_to_list/2'.

`avl_range(+AVL, -RANGE)'
     unifies RANGE with the ordered set representation of the range of
     the AVL (the values associated with its keys, not the keys
     themselves).  Note that the cardinality (length) of the domain and
     the range are seldom equal, except of course for trees
     representing intertible maps.

`avl_min(+AVL, -KEY)'
     is true when KEY is the smallest key in AVL.

`avl_min(+AVL, -KEY, -VAL)'
     is true when KEY is the smallest key in AVL and VAL is its value.

`avl_max(+AVL, -KEY)'
     is true when KEY is the greatest key in AVL.

`avl_max(+AVL, -KEY, -VAL)'
     is true when KEY is the greatest key in AVL and VAL is its value.

`avl_height(+AVL, -HEIGHT)'
     is true when HEIGHT is the height of the given AVL tree, that is,
     the longest path in the tree has HEIGHT 'node's on it.

`avl_size(+AVL, -SIZE)'
     is true when SIZE is the size of the AVL tree, the number of
     'node's in it.

`portray_avl(+AVL)'
     writes an AVL tree to the current output stream in a pretty form so
     that you can easily see what it is.  Note that an AVL tree written
     out this way can NOT be read back in; for that use `writeq/1'.  The
     point of this predicate is to get AVL trees displayed nicely by
     `print/1'.

`avl_member(?KEY, +AVL)'
     is true when KEY is one of the keys in the given AVL.  This
     predicate should be used to enumerate the keys, not to look for a
     particular key (use `avl_fetch/2' or `avl_fetch/3' for that).  The
     KEYS are enumerated in ascending order.

`avl_member(?KEY, +AVL, ?VAL)'
     is true when KEY is one of the keys in the given AVL and VAL is
     the value the AVL associates with that KEY.  This predicate should
     be used to enumerate the keys and their values, not to look up the
     value of a known key (use `avl_fetch/3') for that.  The KEYS are
     enumerated in ascending order.

`avl_fetch(+KEY, +AVL)'
     is true when the (given) KEY is one of the keys in the (given) AVL.
     Use this to test whether a known Key occurs in AVL and you don't
     want to know the value associated with it.

`avl_fetch(+KEY, +AVL, -VAL)'
     is true when the (given) KEY is one of the keys in the (given) AVL
     and the value associated with it therein is VAL.  It should be
     used to look up _known_ keys, not to enumerate keys (use either
     `avl_member/2' or `avl_member/3' for that).

`avl_next(+KEY, +AVL, -KNEXT)'
     is true when KNEXT is the next key after KEY in AVL; that is,
     KNEXT is the smallest key in AVL such that KNEXT @> KEY.

`avl_next(+KEY, +AVL, -KNEXT, -VNEXT)'
     is true when KNEXT is the next key after KEY in AVL and VNEXT is
     the value associated with KNEXT in AVL.  That is, KNEXT is the
     smallest key in AVL such that KNEXT @> KEY, and `avl_fetch(KNEXT,
     AVL, VNEXT)'.

`avl_prev(+KEY, +AVL, -KPREV)'
     is true when KPREV is the key previous to KEY in AVL; that is,
     KPREV is the greatest key in AVL such that KPREV @< KEY.

`avl_prev(+KEY, +AVL, -KPREV, -VPREV)'
     is true when KPREV is the key previous to Key in AVL and VPREV is
     the value associated with KPREV in AVL.  That is, KPREV is the
     greatest key in AVL such that KPREV @< KEY, and `avl_fetch(KPREV,
     AVL, VPREV)'.

`avl_change(+KEY, ?AVL1, ?VAL1, ?AVL2, ?VAL2)'
     is true when AVL1 and AVL2 are avl trees of exactly the same shape,
     KEY is a key of both of them, VAL1 is the value associated with KEY
     in AVL1 and VAL2 is the value associated with it in AVL2, and when
     AVL1 and AVL2 are identical except perhaps for the value they
     assign to KEY.  Use this to change the value associated with a KEY
     which is already present, not to insert a new KEY (it won't).

`ord_list_to_avl(+LIST, -AVL)'
     is given a list of KEY-VAL pairs where the KEYS are already in
     standard order with no duplicates (this is not checked) and
     returns an AVL representing the same associations.  This takes
     O(N) time, unlike `list_to_avl/2' which takes O(N LG N).

`list_to_avl(+PAIRS, -AVL)'
     is given a list of KEY-VAL pairs where the KEYS are in no
     particular order (but are sufficiently instantiated to be told
     apart) and returns an AVL representing the same associations.
     This works by starting with an empty tree and inserting the
     elements of the list into it.  This takes O(N LG N) time.  Since
     it is possible to read off a sorted list in O(N) time from the
     result, O(N LG N) is as good as can possibly be done.  If the same
     KEY appears more than once in the input, the last value associated
     with it will be used.  Could be defined as:

          list_to_avl(Pairs, AVL) :-
          	(   foreach(K-V,Pairs),
          	    fromto(empty,AVL0,AVL1,AVL)
          	do  avl_store(K, AVL0, V, AVL1)
          	).

`avl_store(+KEY, +OLDAVL, +VAL, +NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that NEWAVL associates VAL with KEY.  OLDAVL need not have
     associated any value at all with KEY.  When it didn't, you can
     read this as "insert (KEY->VAL) into OLDAVL giving NEWAVL".

`avl_incr(+KEY, +OLDAVL, +INC, +NEWAVL)'
     if KEY is not present in OLDAVL, adds KEY->INCR.  if KEY->N is
     present in OLDAVL, changes it to KEY->N+INCR.

`avl_delete(+KEY, +OLDAVL, -VAL, -NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that OLDAVL associates KEY with VAL and NEWAVL doesn't
     associate KEY with any value.

`avl_del_min(+OLDAVL, -KEY, -VAL, -NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that OLDAVL associates KEY with VAL and NEWAVL doesn't
     associate KEY with any value and KEY precedes all other keys in
     OLDAVL.

`avl_del_max(+OLDAVL, -KEY, -VAL, -NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that OLDAVL associates KEY with VAL and NEWAVL doesn't
     associate KEY with any value and KEY is preceded by all other keys
     in OLDAVL.

`avl_map(:PRED, +AVL)'
     is true when AVL is an association tree, and for each KEY, if KEY
     is associated with VALUE in AVL, PRED(VALUE) is true.

`avl_map(:PRED, +OLDAVL, -NEWAVL)'
     is true when OLDAVL and NEWAVL are association trees of the same
     shape, and for each KEY, if KEY is associated with OLD in OLDAVL
     and with NEW in NEWAVL, PRED(OLD,NEW) is true.


File: sicstus.info,  Node: lib-bags,  Next: lib-bdb,  Prev: lib-avl,  Up: The Prolog Library

10.5 Bags, or Multisets--`library(bags)'
========================================

This library module provides operations on bags.  Bags are also known
as multisets.  A bag B is a function from a set `dom(B)' to the
non-negative integers.  For the purposes of this module, a bag is
constructed from two functions:

`bag'
     creates an empty bag

`bag(E,M,B)'
     extends the bag B with a _new_ element E which occurs with
     multiplicity M, and which precedes all elements of B in Prolog's
     order.

   A bag is represented by a Prolog term mirroring its construction.
There is one snag with this: what are we to make of
         bag(f(a,Y), 1, bag(f(X,b), 1, bag))     ?
   As a term it has two distinct elements, but `f(a,b)' will be
reported as occurring in it twice.  But according to the definition
above,
         bag(f(a,b), 1, bag(f(a,b), 1, bag))
   is not the representation of any bag, that bag is represented by
         bag(f(a,b), 2, bag)
   alone.  We are apparently stuck with a scheme which is only
guaranteed to work for "sufficiently instantiated" terms, but then,
that's true of a lot of Prolog code.

   The reason for insisting on the order is to make union and
intersection linear in the sizes of their arguments.
`library(ordsets)' does the same for ordinary sets.

   Exported predicates:

`is_bag(+BAG)'
     recognises proper well-formed bags.  You can pass variables to
     `is_bag/1', and it will reject them.

`portray_bag(+BAG)'
     writes a bag to the current output stream in a pretty form so that
     you can easily see what it is.  Note that a bag written out this
     way can _not_ be read back in.  For that, use `write_canonical/1'.
     The point of this predicate is to have bags displayed nicely by
     print/1 and the debugger.  This will print things which are not
     fully instantiated, which is mainly of interest for debugging this
     module.

`checkbag(:PRED, +BAG)'
     is true when BAG is a BAG{E1:M1, ..., EN:MN} with elements EI of
     multiplicity MI, and PRED(EI, MI) is true for each I.

`mapbag(:PRED, +BAG)'
     is true when BAG is a BAG{E1:M1, ..., EN:MN} with elements EI of
     multiplicity MI, and PRED(EI) is true for each element EI.  The
     multiplicities are ignored:  if you don't want this, use
     `checkbag/2'.

`mapbag(:PRED, +OLDBAG, -NEWBAG)'
     is true when OLDBAG is a BAG{E1:M1, ..., EN:MN} and NEWBAG is a
     BAG{F1:M'1, ..., FN:M'N} and the elements of OLDBAG and NEWBAG are
     related by PRED(EI, FJ).  What happens is that the elements of
     OLDBAG are mapped, and then the result is converted to a bag, so
     there is no positional correspondence between EI and FJ.  Even
     when PRED is bidirectional, `mapbag/3' is _not_.  OLDBAG should
     satisfy `is_bag/1' before `mapbag/3' is called.

`somebag(:PRED, +BAG)'
     is true when BAG is a BAG{E1:M1, ..., EN:MN} with elements EI of
     multiplicity MI and PRED(EI, MI) is true of some element EI and
     its multiplicity.  There is no version which ignores the MI.

`somechkbag(:PRED, +BAG)'
     is like `somebag(PRED, BAG)', but commits to the first solution it
     finds.  For example, if `p(X,X,_)', `somechk(p(X), BAG)' would be
     an analogue of `memberchk/2' for bags.

`bag_to_list(+BAG, -LIST)'
     converts a BAG{E1:M1, ..., EN:MN} to a list where each element
     appears as many times as its multiplicity requires.  For example,
     `Bag{a:1, b:3, c:2}' would be converted to `[a,b,b,b,c,c]'.

`bag_to_ord_set(+BAG, -ORDSET)'
     converts a BAG{E1:M1, ..., EN:MN} to a list where each element
     appears once without its multiplicity.  The result is always an
     ordered (representation of a) set, suitable for processing by
     `library(ordsets)'.  See also `bag_to_list/2'.

`bag_to_ord_set(+BAG, +THRESHOLD, -ORDSET)'
     given a BAG{E1:M1, ..., EN:MN} returns a list in standard order of
     the set of elements {EI | MI >= THRESHOLD}.  The result is an
     Ordset.

`list_to_bag(+LIST, -BAG)'
     converts a LIST to a BAG representing the same multi-set.  Each
     element of the List appears once in the BAG together with the
     number of times it appears in the LIST.

`bag_to_set(+BAG, -SET)'
     converts a BAG{E1:M1, ..., EN:MN} to a list which represents the
     SET {E1, ..., EN}.  The order of elements in the result is not
     defined:  for a version where the order is defined use
     `bag_to_ord_set/2'.

`bag_to_set(+BAG, +THRESHOLD, -SET)'
     given a BAG{E1:M1, ..., EN:MN} returns a list which represents the
     SET of elements {EI | MI >= THRESHOLD}.  Because the BAG is sorted,
     the result is necessarily an ordered set.

`empty_bag(?BAG)'
     is true when BAG is the representation of an empty bag.  It can be
     used both to make and to recognise empty bags.

`member(?ELEMENT, ?MULTIPLICITY, +BAG)'
     is true when ELEMENT appears in the multi-set represented by BAG
     with the indicated MULTIPLICITY.  BAG should be instantiated, but
     ELEMENT and MULTIPLICITY may severally be given or solved for.

`memberchk(+ELEMENT, ?MULTIPLICITY, +BAG)'
     is true when ELEMENT appears in the multi-set represented by BAG,
     with the indicated MULTIPLICITY.  It should only be used to check
     whether a given element occurs in the BAG, or whether there is an
     element with the given MULTIPLICITY.  Note that guessing the
     multiplicity and getting it wrong may force the wrong choice of
     clause, but the result will be correct if `is_bag(BAG)'.

`bag_max(+BAG, -COMMONESTELEMENT)'
     unifies COMMONESTELEMENT with the element of BAG which occurs most
     often, picking the leftmost element if several have this
     multiplicity.  To find the multiplicity as well, use `bag_max/3'.
     `bag_max/2' and `bag_min/2' break ties the same way.

`bag_min(+BAG, -RARESTELEMENT)'
     unifies RARESTELEMENT with the element of BAG which occurs least
     often, picking the leftmost element if several have this
     multiplicity.  To find the multiplicity as well, use `bag_min/3'.
     `bag_max/2' and `bag_min/2' break ties the same way, so
              bag_max(Bag, Elt), bag_min(Bag, Elt)
     is true only when all the elements of BAG have the same
     multiplicity.

`bag_max(+BAG, -COMMONESTELEMENT, -MULTIPLICITY)'
     unifies COMMONESTELEMENT with the element of BAG which occurs most
     often, and MULTIPLICITY with the multiplicity of that element.  If
     there are several elements with the same greatest multiplicity,
     the left-most is returned.  `bag_min/3' breaks ties the same way.

`bag_min(+BAG, -RARESTELEMENT)'
     unifies RARESTELEMENT with the element of BAG which occurs least
     often, and MULTIPLICITY with the multiplicity of that element.  If
     there are several elements with the same least multiplicity, the
     left-most is returned.  `bag_max/3' breaks ties the same way, so
              bag_max(Bag, Elt, Mult), bag_min(Bag, Elt, Mult)
     is true only when all the elements of BAG have multiplicity MULT.

`length(+BAG, -BAGCARDINALITY, -SETCARDINALITY)'
     unifies BAGCARDINALITY with the total cardinality of the multi-set
     BAG (the sum of the multiplicities of its elements) and
     SETCARDINALITY with the number of distinct elements.

`make_sub_bag(+BAG, -SUBBAG)'
     enumerates the sub-bags of BAG, unifying SUBBAG with each of them
     in turn.  The order in which the sub-bags are generated is such
     that if SB2 is a sub-bag of SB1 which is a sub-bag of Bag, SB1 is
     generated before SB2.  In particular, Bag is enumerated first and
     bag last.

`test_sub_bag(+BAG, +SUBBAG)'
     is true when SUBBAG is (already) a sub-bag of BAG.  That is, each
     element of SubBag must occur in BAG with at least the same
     multiplicity.  If you know SUBBAG, you should use this to test,
     not `make_sub_bag/2'.

`bag_union(+BAG1, +BAG2, -UNION)'
     unifies UNION with the multi-set union of bags BAG1 and BAG2.

`bag_union(+LISTOFBAGS, -UNION)'
     is true when LISTOFBAGS is given as a proper list of bags and UNION
     is their multi-set union.  Letting K be the length of LISTOFBAGS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).

`bag_intersection(+BAG1, +BAG2, -INTERSECTION)'
     unifies INTERSECTION with the multi-set intersection of bags BAG1
     and BAG2.

`bag_intersection(+LISTOFBAGS, -INTERSECTION)'
     is true when LISTOFBAGS is given as a non-empty proper list of Bags
     and INTERSECTION is their intersection.  The intersection of an
     empty list of Bags would be the universe with infinite
     multiplicities!

`bag_intersect(+BAG1, +BAG2)'
     is true when the multi-sets BAG1 and BAG2 have at least one
     element in common.

`bag_add_element(+BAG1, +ELEMENT, +MULTIPLICITY, -BAG2)'
     computes BAG2 = BAG1 U {ELEMENT:MULTIPLICITY}.  MULTIPLICITY must
     be an integer.

`bag_del_element(+BAG1, +ELEMENT, +MULTIPLICITY, -BAG2)'
     computes BAG2 = BAG1 \ {ELEMENT:MULTIPLICITY}.  MULTIPLICITY must
     be an integer.

`bag_subtract(+BAG1, +BAG2, -DIFFERENCE)'
     is true when DIFFERENCE is the multiset difference of BAG1 and
     BAG2.


File: sicstus.info,  Node: lib-bdb,  Next: lib-between,  Prev: lib-bags,  Up: The Prolog Library

10.6 External Storage of Terms (Berkeley DB)--`library(bdb)'
============================================================

This library module handles storage and retrieval of terms on files.
By using indexing, the store/retrieve operations are efficient also for
large data sets.  The package is an interface to the Berkeley DB
toolset.

* Menu:

* BDB Basics:: Basics
* Current Limitations:: Current Limitations
* Berkeley DB:: Berkeley DB
* The DB-Spec Informal Description:: The DB-Spec---Informal Description
* Predicates:: Predicates
* An Example Session:: An Example Session
* The DB-Spec:: The DB-Spec
* Exporting and importing a database:: Exporting and importing a database


File: sicstus.info,  Node: BDB Basics,  Next: Current Limitations,  Up: lib-bdb

10.6.1 Basics
-------------

The idea is to get a behavior similar to `assert/1', `retract/1' and
`clause/2', but the terms are stored on files instead of in primary
memory.

   The differences compared with the Prolog database are:

   * A "database" must be opened before any access and closed after the
     last access. (There are special predicates for this:
     `db_open/[4,5]' and `db_close/1'.)

   * The functors and the indexing specifications of the terms to be
     stored have to be given when the database is created. (*note The
     DB-Spec::).

   * The indexing is specified when the database is created.  It is
     possible to index on other parts of the term than just the functor
     and first argument.

   * Changes affect the database immediately.

   * The database will store variables with attributes or with blocked
     goals as ordinary variables.

   Some commercial databases can't store non-ground terms or more than
one instance of a term.  This library module can however store terms of
either kind.


File: sicstus.info,  Node: Current Limitations,  Next: Berkeley DB,  Prev: BDB Basics,  Up: lib-bdb

10.6.2 Current Limitations
--------------------------

   * The terms are not necessarily fetched in the same order as they
     were stored.

   * If the process dies during an update operation (`db_store/3',
     `db_erase/[2,3]'), the database can be inconsistent.

   * Databases can only be shared between processes running on the
     machine where the environment is created (*note Predicates::).  The
     database itself can be on a different machine.

   * The number of terms ever inserted in a database cannot exceed
     2^32-1.

   * Duplicate keys are not handled efficiently by Berkeley DB.  This
     limitation is supposed to get lifted in the future.  Duplicate
     keys can result from indexing on non-key attribute sets, inserting
     terms with variables on indexing positions, or simply from storing
     the same term more than once.


File: sicstus.info,  Node: Berkeley DB,  Next: The DB-Spec Informal Description,  Prev: Current Limitations,  Up: lib-bdb

10.6.3 Berkeley DB
------------------

This library module is an interface to the Berkeley DB toolset to
support persistent storage of Prolog terms.  Some of the notions of
Berkeley DB are directly inherited, e.g. the environment.

   The interface uses the Concurrent Access Methods product of Berkeley
DB.  This means that multiple processes can open the same database, but
transactions and disaster recovery are not supported.

   The environment and the database files are ordinary Berkeley DB
entities which means that the standard support utilities (e.g.
`db_stat') will work.


File: sicstus.info,  Node: The DB-Spec Informal Description,  Next: Predicates,  Prev: Berkeley DB,  Up: lib-bdb

10.6.4 The DB-Spec--Informal Description
----------------------------------------

The "db-spec" defines which functors are allowed and which parts of a
term are used for indexing in a database.  The syntax of a db-spec is a
skeletal goal with no module.  The db-spec is a list of atoms and
compound terms where the arguments are either `+' or `-'.  A term can
be inserted in the database if there is a spec in the spec list with
the same functor.

   Multilevel indexing is not supported, terms have to be "flattened".

   Every spec with the functor of the "indexed term" specifies an
indexing.  Every argument where there is a `+' in the spec is indexed
on.

   The idea of the db-spec is illustrated with a few examples.  (A
section further down explains the db-spec in a more formal way).

   Given a spec of `[f(+,-), .(+,-), g, f(-,+)]' the indexing works as
follows.  (The parts with indexing are underlined.)

TERM         STORE                             FETCH

`g(x,y)'     domain error                      domain error

`f(A,B)'     `f(A,B)'                          instantiation error
             `-'                               

`f(a,b)'     `f(a,b)  f(a,b)'                  `f(a,b)'
             `- -     -   -'                   `- -'

`[a,b]'      `.(a,.(b,[]))'                    `.(a,.(b,[]))'
             `- -'                             `- -'

`g'          `g'                               `g'
             `-'                               `-'

   The specification `[f(+,-), f(-,+)]' is different from `[f(+,+)]'.
The first specifies that two indices are to be made whereas the second
specifies that only one index is to be made on both arguments of the
term.


File: sicstus.info,  Node: Predicates,  Next: An Example Session,  Prev: The DB-Spec Informal Description,  Up: lib-bdb

10.6.5 Predicates
-----------------

* Menu:

* Conventions:: Conventions
* The Environment:: The Environment
* Memory Leaks:: Memory Leaks
* The Predicates:: The Predicates


File: sicstus.info,  Node: Conventions,  Next: The Environment,  Up: Predicates

10.6.5.1 Conventions
....................

The following conventions are used in the predicate descriptions below.
   * MODE is either `update' or `read' or `enumerate'.  In mode `read'
     no updates can be made.  Mode `enumerate' is like mode `read', but
     indexing cannot be used, i.e. you can only sequentially enumerate
     the items in the database.  In mode `enumerate' only the file
     storing the terms along with their references is used.

   * ENVREF is a reference to an open database environment.  The
     environment is returned when it is opened.  The reference becomes
     invalid after the environment has been closed.

   * DBREF is a reference to an open database.  The reference is
     returned when the database is opened.  The reference becomes
     invalid after the database has been closed.

   * TERMREF is a reference to a term in a given database.  The
     reference is returned when a term is stored.  The reference stays
     valid even after the database has been closed and hence can be
     stored permanently as part of another term.  However, if such
     references are stored in the database, automatic compression of
     the database (using `db_compress/[2,3]') is not possible, in that
     case the user has to write her own compressing predicate.

   * SPECLIST is a description of the indexing scheme; *note The
     DB-Spec::.

   * TERM is any Prolog term.

   * ITERATOR is a non-backtrackable mutable object.  It can be used to
     iterate through a set of terms stored in a database.  The
     iterators are unidirectional.


File: sicstus.info,  Node: The Environment,  Next: Memory Leaks,  Prev: Conventions,  Up: Predicates

10.6.5.2 The Environment
........................

To enable sharing of databases between process, programs have to create
"environments" and the databases should be opened in these
environments.  A database can be shared between processes that open it
in the same environment.  An environment physically consists of a
directory containing the files needed to enable sharing databases
between processes.  The directory of the environment has to be located
in a local file system.

   Databases can be opened outside any environment (see `db_open/4'),
but in that case a process writing the database must ensure exclusive
access or the behavior of the predicates is undefined.


File: sicstus.info,  Node: Memory Leaks,  Next: The Predicates,  Prev: The Environment,  Up: Predicates

10.6.5.3 Memory Leaks
.....................

In order to avoid memory leaks, environments, databases and iterators
should always be closed explicitly.  Consider using `call_cleanup/2' to
automate the closing/deallocation of these objects.  You can always use
`db_current_env/1', `db_current/5' and `db_current_iterator/3' to
enumerate the currently living objects.

     *Please note*: a database must not be closed while there are
     outstanding choices for some `db_fetch/3' goal that refers to that
     database.  Outstanding choices can be removed with a cut (`!').


File: sicstus.info,  Node: The Predicates,  Prev: Memory Leaks,  Up: Predicates

10.6.5.4 The Predicates
.......................

`db_open_env(+ENVNAME, -ENVREF)'
`db_open_env(+ENVNAME, +CACHESIZE, -ENVREF)'
     Opens an environment with the name ENVNAME.  A directory with this
     name is created for the environment if necessary.

     By using `db_open_env/3' one can specify the size of the cache:
     CACHESIZE is the (integer) size of the cache in kilobytes.  The
     size of the cache cannot be less than 20 kilobytes.
     `db_open_env/2' will create a cache of the system's default size.

     The size of the cache is determined when the environment is
     created and cannot be changed by future openings.

     A process cannot open the same environment more than once.

`db_close_env(+ENVREF)'
     Closes an environment.  All databases opened in the environment
     will be closed as well.

`db_current_env(?ENVNAME, ?ENVREF)'
     Unifies the arguments with the open environments.  This predicate
     can be used for enumerating all currently open environments
     through backtracking.

`db_open(+DBNAME, +MODE, ?SPECLIST, -DBREF)'
`db_open(+DBNAME, +MODE, ?SPECLIST, +OPTIONS, -DBREF)'
     Opens a database with the name DBNAME.  The database physically
     consists of a directory with the same name, containing the files
     that make up the database.  If the directory does not exist, it is
     created.  In that case MODE must be `update' and the db-spec
     SPECLIST must be ground.  If an existing database is opened and
     MODE is `read' or `update', SPECLIST is unified with the db-spec
     given when the database was created.  If the unification fails an
     error is raised.  DBREF is unified with a reference to the opened
     database.

     If MODE is `enumerate' then the indexing specification is not
     read, and SPECLIST is left unbound.

     OPTIONS provides a way to specify an environment in which to open
     the database, or a cache size.  OPTIONS should be a list of terms
     of the following form:

    `environment(ENVREF)'
          The database will be opened in this environment.

    `cache_size(CACHESIZE)'
          This is the (integer) size of the cache in kilobytes.  The
          size of the cache cannot be less than 20 kilobytes.  If
          CACHESIZE is given as the atom `default', a default cache
          size will be used.  If CACHESIZE is given as the atom `off'
          or the atom `none', all modified records will be flushed to
          disk after each operation.

     To avoid inconsistency, if multiple processes open the same
     database, then all of them should do that with MODE set to `read'
     or `enumerate'.  (This is not enforced by the system.)

`db_close(+DBREF)'
     Closes the database referenced by DBREF.  Any iterators opened in
     the database will be deallocated.

`db_current(?DBNAME, ?MODE, ?SPECLIST, ?ENVREF, ?DBREF)'
     Unifies the arguments with the open databases.  This predicate can
     be used to enumerate all currently open databases through
     backtracking.  If the database was opened without an environment,
     then ENVREF will be unified with the atom `none'.

`db_store(+DBREF, +TERM, -TERMREF)'
     Stores TERM in the database DBREF.  TERMREF is unified with a
     corresponding term reference.  The functor of TERM must match the
     functor of a spec in the db-spec associated with DBREF.

`db_fetch(+DBREF, ?TERM, ?TERMREF)'
     Unifies TERM with a term from the database DBREF.  At the same
     time, TERMREF is unified with a corresponding term reference.
     Backtracking over the predicate unifies with all terms matching
     TERM.

     If TERMREF is not instantiated then both the functor and the
     instantiatedness of TERM must match a spec in the db-spec
     associated with DBREF.

     If TERMREF is instantiated, the referenced term is read and
     unified with TERM.

     If you simply want to find all matching terms, it is more
     efficient to use `db_findall/5' or `db_enumerate/3'.

`db_erase(+DBREF, +TERMREF)'
`db_erase(+DBREF, +TERMREF, +TERM)'
     Deletes the term from the database DBREF that is referenced by
     TERMREF.

     In the case of `db_erase/2' the term associated with TERMREF has
     to be looked up.  `db_erase/3' assumes that the term TERM is
     identical with the term associated with TERMREF (modulo variable
     renaming).  If this is not the case, the behavior is undefined.

`db_enumerate(+DBREF, ?TERM, ?TERMREF)'
     Unifies TERM with a term from the database DBREF.  At the same
     time, TERMREF is unified with a corresponding term reference.
     Backtracking over the predicate unifies with all terms matching
     TERM.

     Implemented by linear search--the db-spec associated with DBREF is
     ignored.  It is not useful to call this predicate with TERMREF
     instantiated.

`db_findall(+DBREF, +TEMPLATE, +TERM, :GOAL, -BAG)'
     Unifies BAG with the list of instances of TEMPLATE in all proofs
     of GOAL found when TERM is unified with a matching term from the
     database DBREF.  Both the functor and the instantiatedness of TERM
     must match a spec in the db-spec associated with DBREF.
     Conceptually, this predicate is equivalent to `findall(TEMPLATE,
     (db_fetch(DBREF, TERM, _), GOAL), BAG)'.

`db_compress(+DBREF, +DBNAME)'
`db_compress(+DBREF, +DBNAME, +SPECLIST)'
     Copies the database given by DBREF to a new database named by
     DBNAME.  The new database will be a compressed version of the
     first one in the sense that it will not have "holes" resulting
     from deletion of terms.  Deleted term references will also be
     reused, which implies that references that refer to terms in the
     old database will be invalid in the new one.

     `db_compress/2' looks for a database with the db-spec of the
     original one.  `db_compress/3' stores the terms found in the
     original database with the indexing specification SPECLIST.
     `db_compress/2' cannot be used if the database DBREF was opened in
     mode `enumerate'.

     If the database DBNAME already exists then the terms of DBREF will
     be appended to it.  Of course DBNAME must have an indexing
     specification, which enables the terms in DBREF to be inserted
     into it.

     In the case of `db_compress/3' if the database DBNAME does not
     exist, then SPECLIST must be a valid indexing specification.

`db_sync(+DBREF)'
     Flushes any cached information from the database referenced by
     DBREF to stable storage.

`db_make_iterator(+DBREF, -ITERATOR)'
`db_make_iterator(+DBREF, +TERM, -ITERATOR)'
     Creates a new iterator and unifies it with ITERATOR.  Iterators
     created with `db_make_iterator/2' iterate through the whole
     database.  Iterators created with `db_make_iterator/3' iterate
     through the terms that would be found by `db_fetch(DBREF, TERM,
     _)'.

     Every iterator created by `db_make_iterator/[2,3]' must be
     destroyed with `db_iterator_done/1'.

`db_iterator_next(+ITERATOR, -TERM, -TERMREF)'
     ITERATOR advances to the next term, TERM and TERMREF is unified
     with the term and its reference pointed to by ITERATOR.  If there
     is no next term, the predicate fails.

`db_iterator_done(+ITERATOR)'
     Deallocates ITERATOR, which must not be in use anymore.

`db_current_iterator(?DBREF, ?TERM, ?ITERATOR)'
     Unifies the variables with the respective properties of the living
     iterators.  This predicate can be used to enumerate all currently
     alive iterators through backtracking.  If ITERATOR was made with
     `db_make_iterator/2' then TERM will be left unbound.

`db_export(+DBNAME, +EXPORTFILE)'
`db_export(+DBNAME, +OPTIONS, +EXPORTFILE)'
     Exports the database with the name DBNAME to the text file
     EXPORTFILE. EXPORTFILE can be imported by `db_import/[2,3]'.

     OPTIONS should be an options list of the form acceptable by
     `db_open/[4,5]'.

     In SICStus 3.12.0 `bdb:export/[2,3]' is available instead of
     `db_export/[2,3]'.

`db_import(+DBNAME, +IMPORTFILE)'
`db_import(+DBNAME, +OPTIONS, +IMPORTFILE)'
     Imports the text file IMPORTFILE into the database with the name
     DBNAME.

     If IMPORTFILE is imported into an existing database, the SPECLIST
     found in the IMPORTFILE will be unified with the SPECLIST in the
     database.

     OPTIONS should be an options list of the form acceptable by
     `db_open/[4,5]'.

     In SICStus 3.12.0 `bdb:import/[2,3]' is available instead of
     `db_import/[2,3]'.


File: sicstus.info,  Node: An Example Session,  Next: The DB-Spec,  Prev: Predicates,  Up: lib-bdb

10.6.6 An Example Session
-------------------------

     | ?- db_open(tempdb, update, [a(+,-)], DBRef), assert(tempdb(DBRef)).
     DBRef = '$db'(1077241400)

     | ?- tempdb(DBRef), db_store(DBRef, a(b,1), _).
     DBRef = '$db'(1077241400)

     | ?- tempdb(DBRef), db_store(DBRef, a(c,2), _).
     DBRef = '$db'(1077241400)

     | ?- tempdb(DBRef), db_fetch(DBRef, a(b,X), _).
     X = 1,
     DBRef = '$db'(1077241400) ? ;
     no

     | ?- tempdb(DBRef), db_enumerate(DBRef, X, _).
     X = a(b,1),
     DBRef = '$db'(1077241400) ? ;
     X = a(c,2),
     DBRef = '$db'(1077241400) ? ;
     no

     | ?- db_current(DBName, Mode, Spec, EnvRef, DBRef).
     Mode = update,
     Spec = [a(+,-)],
     DBRef = '$db'(1077241400),
     DBName = tempdb,
     EnvRef = none ? ;
     no

     | ?- tempdb(DBRef), db_close(DBRef).
     DBRef = '$db'(1077241400)


File: sicstus.info,  Node: The DB-Spec,  Next: Exporting and importing a database,  Prev: An Example Session,  Up: lib-bdb

10.6.7 The DB-Spec
------------------

A db-spec has the form of a SPECLIST:

SPECLIST
     = `['SPEC1, ..., SPECM`]'

SPEC
     = FUNCTOR`('ARGSPEC1, ..., ARGSPECN`)'

ARGSPEC
     = `+' | `-'
   where FUNCTOR is a Prolog atom.  The case N = 0 is allowed.

   A spec F`('ARGSPEC1, ..., ARGSPECN`)' is _applicable_ to any nonvar
term with principal functor F/N.

   When storing a term T we generate a hash code for every applicable
spec in the db-spec, and a reference to T is stored with each of them.
(More precisely with each element of the set of generated hash codes).
If T contains nonvar elements on each `+' position in the spec, then
the hash code depends on each of these elements.  If T does contain
some variables on `+' position, then the hash code depends only on the
functor of T.

   When fetching a term Q we look for an applicable spec for which
there are no variables in Q on positions maked `+'.  If no applicable
spec can be found a domain error is raised.  If no spec can be found
where on each `+' position a nonvar term occurs in Q an instantiation
error is raised.  Otherwise, we choose the spec with the most `+'
postitions in it breaking ties by choosing the leftmost one.

   The terms that contain nonvar terms on every `+' postition will be
looked up using indexing based on the principal functor of the term and
the principal functor of terms on `+' postitions.  The other (more
general) terms will be looked up using an indexing based on the
principal functor of the term only.

   As can be seen, storing and fetching terms with variables on `+'
positions are not vigorously supported operations.


File: sicstus.info,  Node: Exporting and importing a database,  Prev: The DB-Spec,  Up: lib-bdb

10.6.8 Exporting and importing a database
-----------------------------------------

Since the database format of a Berkeley DB may change from version to
version it may become necessary to migrate a database when upgrading.
To this purpose there are two predicates available: `db_export/[2,3]'
and `db_import/[2,3]' (*note The Predicates::).

   The export/import feature was introduced in SICStus 3.12.0, but in
that version you have to use `bdb:export/[2,3]' and `bdb:import/[2,3]'.
Neither is exported from the bdb module, but can be used with module
prefixing.

   Since the bdb interface prior to SICStus 4 uses a custom hash
function, the standard Berkeley DB migration tools will not work when
migrating a database from SICStus 3 to SICStus 4.


File: sicstus.info,  Node: lib-between,  Next: lib-codesio,  Prev: lib-bdb,  Up: The Prolog Library

10.7 Generating Integers--`library(between)'
============================================

This library module provides some means of generating integers.
Exported predicates:

`between(+LOWER, +UPPER, -NUMBER)'
     is true when LOWER, UPPER, and NUMBER are integers, and LOWER =<
     NUMBER =< UPPER.  If LOWER and UPPER are given, NUMBER can be
     tested or enumerated.  If either LOWER or UPPER is absent, there
     is not enough information to find it, and an error will be
     reported.

`gen_nat(?N)'
     is true when N is a natural number.  If N is a variable, it will
     enumerate the natural numbers 0,1,2,... and of course not
     terminate.  It is not meant to be applied to anything but integers
     and variables.

`gen_int(?I)'
     is true when I is an integer.  If I is a variable, it will
     enumerate the integers in the order 0, 1, -1, 2, -2, 3, -3, &c.
     Of course this sequence has no end.  It is not meant to be applied
     to anything but integers and variables.

`repeat(+N)'
     (where N is a non-negative integer) succeeds exactly N times.  You
     can only understand it procedurally, and really it is only
     included for compatibility with some other Prologs.

`numlist(?UPPER, ?LIST)'
     is true when LIST is the list of integers [1, ..., UPPER].  For
     example, `numlist(3,L)' binds `L = [1,2,3]'.

`numlist(?LOWER, ?UPPER, ?LIST)'
     is true when LIST is [LOWER, ..., UPPER], LOWER and UPPER integers.
     For example, `numlist(1, 3, L)' binds `L = [1,2,3]'.

`numlist(?LOWER, ?STEP, ?UPPER, ?LENGTH, ?LIST)'
     is true when LIST is the list of integers [LOWER, LOWER+STEP, ...,
     UPPER] and of length LENGTH.  For example,
     `numlist(L,2,U,S,[1,X,Y,Z])' binds `L=1, S=4, U=7, X=3, U=5, Z=7'.


File: sicstus.info,  Node: lib-codesio,  Next: lib-file_systems,  Prev: lib-between,  Up: The Prolog Library

10.8 I/O on Lists of Character Codes--`library(codesio)'
========================================================

This package defines I/O predicates that read from, or write to, a
code-list.  There are also predicates to open a stream referring to a
code-list.  The stream may be used with general Stream I/O predicates.

   Exported predicates:

`format_to_codes(+FORMAT, :ARGUMENTS, -CODES)'
`format_to_codes(+FORMAT, :ARGUMENTS, ?S0, ?S)'
     Prints ARGUMENTS into a code-list using `format/3'.  CODES is
     unified with the list, alternatively S0 and S are unified with the
     head and tail of the list, respectively.

`write_to_codes(+TERM, -CODES)'
`write_to_codes(+TERM, ?S0, ?S)'
     A specialized `format_to_codes/[3,4]'. Writes TERM into a
     code-list using `write/2'.  CODES is unified with the list.
     Alternatively, S0 and S are unified with the head and tail of the
     list, respectively.

`write_term_to_codes(+TERM, -CODES, +OPTIONS)'
`write_term_to_codes(+TERM, ?S0, ?S, +OPTIONS)'
     A specialized `format_to_codes/[3,4]'. Writes TERM into a
     code-list using `write_term/3' and OPTIONS.  CODES is unified with
     the list.  Alternatively, S0 and S are unified with the head and
     tail of the list, respectively.

`read_from_codes(+CODES, -TERM)'
     Reads TERM from CODES using `read/2'.  The CODES must, as usual,
     be terminated by a FULL-STOP, i.e. a `.', possibly followed by
     LAYOUT-TEXT.

`read_term_from_codes(+CODES, -TERM, +OPTIONS)'
     Reads TERM from CODES using `read_term/3' and OPTIONS.  The CODES
     must, as usual, be terminated by a FULL-STOP, i.e. a `.', possibly
     followed by LAYOUT-TEXT.

`open_codes_stream(+CODES, -STREAM)'
     STREAM is opened as an input stream to an existing code-list.  The
     stream may be read with the Stream I/O predicates and must be
     closed using `close/1'.  The list is copied to an internal buffer
     when the stream is opened and must therefore be a ground code-list
     at that point.

`with_output_to_codes(:GOAL, -CODES)'
`with_output_to_codes(:GOAL, ?S0, ?S)'
`with_output_to_codes(:GOAL, -STREAM, ?S0, ?S)'
     GOAL is called with the `current_output' stream set to a new
     stream. This stream writes to an internal buffer, which is, after
     the successful execution of GOAL, converted to a list of character
     codes.  CODES is unified with the list, alternatively S0 and S are
     unified with the head and tail of the list, respectively.
     `with_output_to_codes/4' also passes the stream in the STREAM
     argument. It can be used only by GOAL for writing.


File: sicstus.info,  Node: lib-file_systems,  Next: lib-heaps,  Prev: lib-codesio,  Up: The Prolog Library

10.9 Accessing Files And Directories--`library(file_systems)'
=============================================================

This module provides operations on files and directories, such as
renaming, deleting, opening, checking permissions, accessing members of.

   The following principles have been observed:

   * An absolute distinction is drawn between files and directories.
     The set of operations one can usefully perform on a directory is
     different from the set one can perform on a file:  for example,
     having write permission to a directory allows the user to create
     new files in it, not to rewrite the entire directory!  If any
     routine in this package tells you that a "file" exists, you can be
     sure that it means a file and not a directory (and vice versa for
     "directory" exists).

   * The directory scanning routines do not actually open the files they
     find.  Thus finer discriminations, such as that between source and
     object code, are not made.

   * All paths are expanded as if by `absolute_file_name/3'.

   * Every predicate acts like a genuine logical relation insofar as it
     possibly can.

   * If anything goes wrong, the predicates raise an error exception.
     Any time that a predicate fails quietly, it should mean "this
     question is meaningful, but the answer is no".

   * The directory scanning routines insist that the directory argument
     name a searchable directory.

   * On Unix-like systems, symbolic links are followed by default and
     symbolic links that can not be followed are treated as
     non-existing. This means `file_exists/1' will fail if passed such
     a "broken" link and that neither `file_members_of_directory/1' nor
     `directory_members_of_directory/1' et al. will return such a link.

     On Windows, symbolic links (and other reparse points) are _not_
     followed when enumerating directory contents with
     `file_members_of_directory/1' nor
     `directory_members_of_directory/1' et al. and are not returned for
     these predicates.

     The behavior for symbolic links (and reparse points) may change on
     all platforms in the future to ensure a well defined and
     consistent behavior on all platforms.

     To see _all_ members of a directory you can use
     `absolute_file_name/3' with a `glob('*')' option.

   The "property" routines use the same simplistic access control model
as that used by the `absolute_file_name/3' `access/1'-option. *Note
mpg-ref-absolute_file_name::, for details.

   Exported predicates:

`rename_file(+OLDNAME, +NEWNAME)'
     OLDNAME must identify an existing file, which will be renamed to
     NEWNAME.  The details of just when this can be done are
     operating-system dependent.  Typically it is only possible to
     rename within the same file system.

`rename_directory(+OLDNAME, +NEWNAME)'
     OLDNAME must identify an existing directory, which will be renamed
     to NEWNAME.  The details of just when this can be done are
     operating-system dependent.  Typically it is only possible to
     rename empty directories within the same file system.

`delete_file(+OLDNAME)'
     OLDNAME must identify an existing file, which will be deleted.

`delete_directory(+DIRECTORY)'
`delete_directory(+DIRECTORY, +OPTIONS)'
     DIRECTORY must identify an existing directory, which will be
     deleted, if empty.  OPTIONS should be a list of at most one term
     of the form:
    `if_nonempty(VALUE)'
          Defines what to do if the directory is nonempty.  One of:
         `ignore'
               The predicate simply succeeds, deleting nothing.

         `fail'
               The predicate simply fails, deleting nothing.

         `error'
               The predicate raises a permisison error.

         `delete'
               The predicate recursively deletes the directory and its
               contents.

`directory_exists(+DIRECTORY)'
`directory_exists(+DIRECTORY, +MODE)'
     is true when DIRECTORY is an existing directory that is accessible
     according to MODE. MODE defaults to `exist'.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [file_type(directory),access([exist|MODE]),file_errors(fail)])'.

`make_directory(+DIRECTORY)'
     DIRECTORY is expanded, as if by `absolute_file_name/3', and the
     resulting directory is created.

`file_exists(+FILE)'
`file_exists(+FILE, +MODE)'
     is true when FILE is an existing file that is accessible according
     to MODE. MODE defaults to `exist'.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(fail)])'.

`file_must_exist(+FILE)'
`file_must_exist(+FILE, +MODE)'
     is like `file_exists(FILE[, MODE])' except that if the file is
     _not_ accessible it reports an error.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(error)])'.

`directory_must_exist(+FILE)'
`directory_must_exist(+FILE, +MODE)'
     is like `file_must_exists(FILE[, MODE])', but for directories.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [file_type(directory),access([exists|MODE]),file_errors(error)])'.

`close_all_streams'
     closes all the streams (other than the standard streams) which are
     currently open.  The time to call this is after an `abort/0'.
     Note that `current_stream/3' does not notice the standard streams.

`directory_member_of_directory(?BASENAME, ?FULLNAME)'
     is true when BASENAME is the name of a subdirectory of the current
     directory (other than '.' or '..') and FULLNAME is its absolute
     name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a subdirectory of
     that directory (other than '.' or '..') and FULLNAME is its
     absolute name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a directory of that
     directory (other than '.' or '..') which matches the given PATTERN,
     and FULLNAME is the absolute name of the subdirectory.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`directory_members_of_directory(-SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the current
     directory.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY.  DIRECTORY need not be absolute; the FULLNAMES will be
     regardless.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given Pattern.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`file_member_of_directory(?BASENAME, ?FULLNAME)'
     is true when BASENAME is the name of a file in the current
     directory and FULLNAME is its absolute name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory, and FULLNAME is its absolute name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory which matches the given PATTERN, and FULLNAME is its
     absolute name.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`file_members_of_directory(-SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the current directory.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the given DIRECTORY.
     DIRECTORY need not be absolute; the FULLNAMES will be regardless.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given PATTERN.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`directory_property(+DIRECTORY, ?PROPERTY)'
     is true when DIRECTORY is a name of a directory, and PROPERTY is a
     boolean property which that directory possesses, e.g.
              directory_property(., searchable).

     The current set of file and directory properties include:
    `readable'
    `writable'
    `executable'
    `searchable'
          Tries to determine whether the process has permission to
          read, write, execute (only for files) or search (only for
          directories) the file.

    `size_in_bytes'
          The size, in bytes, of the file. Not available for
          directories.

    `create_timestamp'
    `modify_timestamp'
    `access_timestamp'
          The time of creation, last modification or last access
          expressed as a timestamp.  A "timestamp" is an integer
          expressing the time interval, in seconds, since the "Epoch".
          The "Epoch" is the time zero hours, zero minutes, zero
          seconds, on January 1, 1970 Coordinated Universal Time (UTC).

          The timestamp is what should be used when comparing
          information between files since it is independent of locale
          issues like time zone and daylight savings time etc.

    `create_localtime'
    `modify_localtime'
    `access_localtime'
          The same as the corresponding `..._timestamp' values passed
          through `system:datime/2', i.e. expressed as local time and
          split up in the components year, month, day, hour, minute,
          seconds.

    `set_user_id'
    `set_group_id'
    `save_text'
          True if the set-uid, set-group-id, save-text bits,
          respectively, are set for the file. Always false on Windows.

    `who_can_read'
    `who_can_write'
    `who_can_execute'
    `who_can_search'
          A list containing the subset of `[user,group,other]' for the
          process classes that can, respectively, read, write, execute
          (only for files) or search (only for directories.

    `owner_user_id'
    `owner_group_id'
          The id of the owner and group of the file. The id is an
          integer on UNIX and an atom (expressed as a string security
          identifier) on Windows.

    `owner_user_name'
    `owner_group_group'
          The atom containing the name of the files owner and group
          respectively. On Windows a name like `'DOMAIN\NAME'' will be
          used.

          If for some reason the name cannot be found it will fall back
          to using the same value as `owner_user_id' and
          `owner_group_id'.


     Other properties may be added in the future. You can backtrack
     through the available properties by calling `file_property/3' or
     `directory_property/3' with an uninstantiated PROPERTY argument.

`directory_property(+DIRECTORY, ?PROPERTY, ?VALUE)'
     is true when DIRECTORY is a name of a directory, PROPERTY is a
     property of directories, and VALUE is DIRECTORY's PROPERTY VALUE.
     See `directory_property/2', above, for a list of properties.

`file_property(+FILE, ?PROPERTY)'
     is true when FILE is a name of a file, and PROPERTY is a boolean
     property which that file possesses, e.g.
              file_property('foo.txt', readable).
     See `directory_property/2', above, for a list of properties.

`file_property(+FILE, ?PROPERTY, ?VALUE)'
     is true when FILE is a name of a file, PROPERTY is a property of
     files, and VALUE is FILE's PROPERTY VALUE.  See
     `directory_property/2', above, for a list of properties.

`current_directory(-DIRECTORY)'
`current_directory(-DIRECTORY, +NEWDIRECTORY)'
     DIRECTORY is unified with the current working directory and the
     working directory is set to NEWDIRECTORY.


File: sicstus.info,  Node: lib-heaps,  Next: lib-lists,  Prev: lib-file_systems,  Up: The Prolog Library

10.10 Heap Operations--`library(heaps)'
=======================================

A heap is a labelled binary tree where the key of each node is less
than or equal to the keys of its sons.  The point of a heap is that we
can keep on adding new elements to the heap and we can keep on taking
out the minimum element.  If there are N elements total, the total time
is O(N LG N).  If you know all the elements in advance, you are better
off doing a merge-sort, but this file is for when you want to do say a
best-first search, and have no idea when you start how many elements
there will be, let alone what they are.

   A heap is represented as a triple `heap(N,Free,Tree)' where N is the
number of elements in the tree, FREE is a list of integers which
specifies unused positions in the tree, and TREE is a tree made of:
`heap'
     terms for empty subtrees and

`heap(KEY,DATUM,LSON,RSON)'
     terms for the rest

   The nodes of the tree are notionally numbered like this:

                                     1
                      2				    3
              4               6               5               7
          8      12      10     14       9       13      11     15
       ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
   The idea is that if the maximum number of elements that have been in
the heap so far is M, and the tree currently has K elements, the tree
is some subtreee of the tree of this form having exactly M elements,
and the FREE list is a list of M-K integers saying which of the
positions in the M-element tree are currently unoccupied.  This free
list is needed to ensure that the cost of passing N elements through
the heap is O(N LG M) instead of O(N LG N).  For M say 100 and N say
10^4 this means a factor of two.  The cost of the free list is slight.
The storage cost of a heap in a copying Prolog is 2K+3M words.
Exported predicates:

`add_to_heap(+OLDHEAP, +KEY, +DATUM, -NEWHEAP)'

`add_to_heap/4 (heaps)'
     inserts the new KEY-DATUM pair into the heap.  The insertion is
     not stable, that is, if you insert several pairs with the same KEY
     it is not defined which of them will come out first, and it is
     possible for any of them to come out first depending on the
     history of the heap.

`delete_from_heap(+OLDHEAP, +KEY, -DATUM, -NEWHEAP)'

`delete_from_heap/4 (heaps)'
     deletes a single KEY-DATUM pair from the OLDHEAP producing a
     NEWHEAP.  This is useful if you want to e.g. change the priority
     of Datum.

`get_from_heap(+OLDHEAP, -KEY, -DATUM, -NEWHEAP)'

`get_from_heap/4 (heaps)'
     returns the KEY-DATUM pair in OLDHEAP with the smallest KEY, and
     also a NEWHEAP which is the OLDHEAP with that pair deleted.

`heap_size(+HEAP, -SIZE)'

`heap_size/2 (heaps)'
     reports the number of elements currently in the heap.

`heap_to_list(+HEAP, -LIST)'

`heap_to_list/2 (heaps)'
     returns the current set of KEY-DATUM pairs in the HEAP as a LIST,
     sorted into ascending order of KEYS.

`list_to_heap(+LIST, -HEAP)'

`list_to_heap/2 (heaps)'
     takes a list of KEY-DATUM pairs (such as `keysort/2' could be used
     to sort) and forms them into a heap.

`empty_heap(?HEAP)'

`empty_heap/1 (heaps)'
     is true when HEAP represents an empty heap.  There is only one way
     it can be true.

`is_heap(+HEAP)'

`is_heap/1 (heaps)'
     is true when HEAP is a well formed heap.  For this to be true, the
     size must be right and the tree must satisfy the heap condition.

`min_of_heap(+HEAP, -KEY, -DATUM)'

`min_of_heap/3 (heaps)'
     returns the KEY-DATUM pair at the top of the heap (which is of
     course the pair with the smallest KEY), but does not remove it
     from the heap.  It fails if the heap is empty.

`min_of_heap(+HEAP, -KEY1, -DATUM1, -KEY2, -DATUM2)'

`min_of_heap/5 (heaps)'
     returns the smallest (KEY1) and second smallest (KEY2) pairs in
     the heap, without deleting them.  It fails if the heap does not
     have at least two elements.

`portray_heap(+HEAP)'

`portray_heap/1 (heaps)'
     writes a heap to the current output stream in a pretty format so
     that you can easily see what it is.  Note that a heap written out
     this way can _not_ be read back in.  The point of this predicate
     is that you can add a clause
              portray(X) :- is_heap(X), !, portray_heap(X).


File: sicstus.info,  Node: lib-lists,  Next: lib-logarr,  Prev: lib-heaps,  Up: The Prolog Library

10.11 List Operations--`library(lists)'
=======================================

This library module provides operations on lists.  Exported predicates:

`select(?ELEMENT, ?SET, ?RESIDUE)'
     is true when SET is a list, ELEMENT occurs in SET, and RESIDUE is
     everything in SET except ELEMENT (things stay in the same order).

`selectchk(+ELEMENT, +SET, ?RESIDUE)'
     is to `select/3' what `memberchk/2' is to `member/2'.  That is, it
     locates the first occurrence of ELEMENT in SET, and deletes it,
     giving RESIDUE.  It is steadfast in RESIDUE.

`append(+LISTOFLISTS, -LIST)'
     is true when LISTOFLISTS is a list [L1,...,LN] of lists, LIST is a
     list, and appending L1, ..., LN together yields LIST.  The
     LISTOFLISTS _must_ be a proper list.  Additionally, either LIST
     should be a proper list, or each of L1, ..., LN should be a proper
     list.  The behavior on non-lists is undefined.  LISTOFLISTS must
     be proper because for any given solution, infinitely many more can
     be obtained by inserting nils ([]) into LISTOFLIST.  Could be
     defined as:

          append(Lists, Appended) :-
          	(   foreach(List,Lists),
          	    fromto(Appended,S0,S,[])
          	do  append(List, S, S0)
          	).

`append(?PREFIX, ?TAIL1, ?LIST1, ?TAIL2, ?LIST2)'
     is true when `append(PREFIX, TAIL1, LIST1)' and `append(PREFIX,
     TAIL2, LIST2)' are both true.  You could call `append/3' twice,
     but that is order- dependent.  This will terminate if PREFIX is a
     proper list or if either LIST1 or LIST2 is a proper list.

`correspond(?X, ?XLIST, ?YLIST, ?Y)'
     is true when XLIST and YLIST are lists, X is an element of XLIST,
     Y is an element of YLIST, and X and Y are in similar places in
     their lists.  No relation is implied between other elements of
     XLIST and YLIST.  For a similar predicate without the cut, see
     `select/4'.

`delete(+LIST, +KILL, -RESIDUE)'
     is true when LIST is a list, in which KILL may or may not occur,
     and RESIDUE is a copy of LIST with all elements equal to KILL
     deleted.  To extract a single copy of KILL, use `select(KILL,
     LIST, RESIDUE)'.  If LIST is not proper, `delete/3' will _fail_.
     KILL and the elements of LIST should be sufficiently instantiated
     for `\=' to be sound.  Could be defined as:

          delete(List, Kill, Residue) :-
          	(   foreach(X,List),
          	    fromto(Residue,S0,S,[]),
          	    param(Kill)
          	do  (X = Kill -> S0 = S ; S0 = [X|S])
          	).

`delete(+LIST, +KILL, +COUNT, -RESIDUE)'
     is true when LIST is a list, in which KILL may or may not occur,
     and COUNT is a non-negative integer, and RESIDUE is a copy of LIST
     with the first COUNT elements equal to KILL deleted.  If LIST has
     fewer than COUNT elements equal to COUNT, all of them are deleted.
     If LIST is not proper, `delete/4' may _fail_.  KILL and the
     elements of LIST should be sufficiently instantiated for `\=' to
     be sound.

`is_list(+LIST)'
     succeeds when LIST is a proper list.  That is, LIST is nil ([]) or
     a cons cell ([HEAD|TAIL]) whose TAIL is a proper list.  A
     variable, or a list whose final tail is a variable, or a cyclic
     list, will fail this test.

`keys_and_values(?[K1-V1,...,KN-VN], ?[K1,...,KN], ?[V1,...,VN])'
     is true when its arguments look like the picture above.  It is
     meant for splitting a list of KEY-VALUE pairs (such as `keysort/2'
     wants and produces) into separate lists of KEYS and of VALUES.  It
     may just as well be used for building a list of pairs from a pair
     of lists.   In fact one usually wants just the keys or just the
     values, but you can supply `_' as the other argument.   For
     example, suppose you wanted to sort a list without having
     duplicates removed.  You could do
              keys_and_values(RawPairs, RawKeys, _),
              keysort(RawPairs, OrdPairs),
              keys_and_values(OrdPairs, OrdKeys, _).
     Could be defined as:

          keys_and_values([], [], []).
          keys_and_values([Key-Value|Pairs], [Key|Keys], [Value|Values]) :-
          	keys_and_values(Pairs, Keys, Values).

`last(+LIST, -LAST)'
     is true when LIST is a LIST and LAST is its last element.  There
     is also a `last(?FORE, ?LAST, ?LIST)' whose argument order matches
     append/3.  This could be defined as
              last(L, X) :- append(_, [X], L).

`nextto(?X, ?Y, ?LIST)'
     is true when X and Y appear side-by-side in LIST.  It could be
     written as
              nextto(X, Y, List) :- append(_, [X,Y|_], List).
     It may be used to enumerate successive pairs from the list.  LIST
     should be proper, otherwise `nextto/3' will generate it.

`nth0(?N, ?LIST, ?ELEM)'
     is true when ELEM is the Nth member of LIST, counting the first as
     element 0.  That is, throw away the first N elements and unify ELEM
     with the next.  E.g. `nth0(0, [H|T], H)'.  Either N should be an
     integer, or LIST should be proper.

`nth1(?N, ?LIST, ?ELEMENT)'
     is true when ELEM is the NTH member of LIST, counting the first as
     element 1.  That is, throw away the first N-1 elements and unify
     ELEM with the next element (the NTH).  E.g. `nth1(1, [H|T], H)'.
     This is just like `nth0/3' except that it counts from 1 instead of
     0.  Either N should be an integer, or LIST should be proper.

`nth0(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 0, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 0) element of REST, when it yields
     LIST, e.g.  `nth0(2, List, c, [a,b,d,e])' unifies LIST with
     `[a,b,c,d,e]'.  This can be seen as inserting ELEM _after_ the NTH
     element of REST if you count from 1 rather than 0.  Either N
     should be an integer, or LIST or REST should be proper.

`nth1(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 1, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 1) element of REST, when it yields
     LIST, e.g.  `nth1(2, List, b, [a,c,d,e])' unifies LIST with
     `[a,b,c,d,e]'.  Either N should be an integer, or LIST or REST
     should be proper.

`one_longer(?LONGER, ?SHORTER)'
     is true when
              length(Longer,N), length(Shorter,M), succ(M,N)
     for some integers M, N.  It was written to make `{nth0,nth1}/4'
     able to find the index, just as `same_length/2' is useful for
     making things invertible.

`perm(+LIST, ?PERM)'
     is true when LIST and PERM are permutations of each other.  The
     main use of `perm/2' is to generate permutations.  You should not
     use this predicate in new programs; use `permutation/2' instead.
     LIST must be a proper list.  PERM may be partly instantiated.

`permutation(?LIST, ?PERM)'
     is true when LIST and PERM are permuations of each other.  Unlike
     `perm/2', it will work even when LIST is not a proper list.  It
     even acts in a marginally sensible way when PERM isn't proper
     either, but it will still backtrack forever.  Be careful: this is
     quite efficient, but the number of permutations of an N-element
     list is N!, and even for a 7-element list that is 5040.

`perm2(?A,?B, ?C,?D)'
     is true when {A,B} = {C,D}.  It is very useful for writing pattern
     matchers over commutative operators.

`proper_length(+LIST, ?LENGTH)'
     succeeds when LIST is a proper list, binding LENGTH to its length.
     That is, `is_list(List), length(List, Length)'.  Will fail for
     cyclic lists.

`remove_dups(+LIST, ?PRUNED)'
     removes duplicated elements from LIST, which should be a proper
     list.  If LIST has non-ground elements, PRUNED may contain
     elements which unify; two elements will remain separate iff there
     is a substitution which makes them different.  E.g. [X,X] -> [X]
     but [X,Y] -> [X,Y].  The surviving elements, by ascending standard
     order, is unified with PRUNED.

`reverse(?LIST, ?REVERSED)'
     is true when LIST and REVERSED are lists with the same elements
     but in opposite orders.  Either LIST or REVERSED should be a
     proper list: given either argument the other can be found.  If
     both are incomplete `reverse/2' can backtrack forever trying ever
     longer lists.

`rev(+LIST, ?REVERSED)'
     is a version of `reverse/2' which only works one way around.  Its
     LIST argument must be a proper list whatever REVERSED is.  You
     should use `reverse/2' in new programs, though `rev/2' is faster
     when it is safe to use it.

`same_length(?LIST1, ?LIST2)'
     is true when LIST1 and LIST2 are both lists and have the same
     number of elements.  No relation between the values of their
     elements is implied.  It may be used to generate either list given
     the other, or indeed to generate two lists of the same length, in
     which case the arguments will be bound to lists of length 0, 1, 2,
     ...

`same_length(?LIST1, ?LIST2, ?LENGTH)'
     is true when LIST1 and LIST2 are both lists, LENGTH is a
     non-negative integer, and both LIST1 and LIST2 have exactly LENGTH
     elements.  No relation between the elements of the lists is
     implied.  If LENGTH is instantiated, or if either LIST1 or LIST2
     is bound to a proper list, same_length is determinate and
     terminating.

`select(?X, ?XLIST, ?Y, ?YLIST)'
     is true when X is the KTH member of XLIST and Y the KTH element of
     YLIST for some K, and apart from that XLIST and YLIST are the
     same.  You can use it to replace X by Y or vice versa.  Either
     XLIST or YLIST should be a proper list.

`selectchk(?X, +XLIST, ?Y, +YLIST)'
     is to `select/4' as `memberhck/2' is to `member/2'.  That is, it
     finds the first K such that X unifies with the KTH element of
     XLIST and Y with the KTH element of YLIST, and it commits to the
     bindings thus found.  If you have KEYS and VALUES in "parallel"
     lists, you can use this to find the VALUE associated with a
     particular KEY (much better methods exist).  Except for argument
     order, this is identical to `correspond/4', but `selectchk/4' is a
     member of a coherent family.  Note that the arguments are like the
     arguments of `memberchk/2', twice.

`shorter_list(?SHORT, ?LONG)'
     is true when SHORT is a list is strictly shorter than LONG.  LONG
     doesn't have to be a proper list provided it is long enough.  This
     can be used to generate lists shorter than LONG, lengths 0, 1, 2...
     will be tried, but backtracking will terminate with a list that is
     one element shorter than LONG.  It cannot be used to generate lists
     longer than SHORT, because it doesn't look at all the elements of
     the longer list.

`subseq(?SEQUENCE, ?SUBSEQUENCE, ?COMPLEMENT)'
     is true when SUBSEQUENCE and COMPLEMENT are both subsequences of
     the list SEQUENCE (the order of corresponding elements being
     preserved) and every element of SEQUENCE which is not in
     SUBSEQUENCE is in the COMPLEMENT and vice versa.  That is,
     `length(Sequence) = length(SubSequence)+length(Complement)', e.g.
     `subseq([1,2,3,4], [1,3,4], [2])'.  This was written to generate
     subsets and their complements together, but can also be used to
     interleave two lists in all possible ways.

`subseq0(+SEQUENCE, ?SUBSEQUENCE)'
     is true when SUBSEQUENCE is a subsequence of SEQUENCE, but may be
     SEQUENCE itself.   Thus `subseq0([a,b], [a,b])' is true as well as
     `subseq0([a,b], [a])'.  SEQUENCE must be a proper list, since
     there are infinitely many lists with a given SUBSEQUENCE.
          ?- setof(X, subseq0([a,b,c],X), Xs).
          Xs = [[],[a],[a,b],[a,b,c],[a,c],[b],[b,c],[c]]
          ?- bagof(X, subseq0([a,b,c,d],X), Xs).
          Xs = [[a,b,c,d],[b,c,d],[c,d],[d],[],[c],[b,d],[b],[b,c],[a,c,d],
                [a,d],[a],[a,c],[a,b,d],[a,b],[a,b,c]]

`subseq1(+SEQUENCE, ?SUBSEQUENCE)'
     is true when SUBSEQUENCE is a proper subsequence of SEQUENCE, that
     is it contains at least one element less.  SEQUENCE must be a
     proper list, as SUBSEQUENCE does not determine SEQUENCE.

`sumlist(+NUMBERS, ?TOTAL)'
     is true when NUMBERS is a list of integers, and TOTAL is their sum.
     Could be defined as:

          sumlist(Numbers, Total) :-
          	(   foreach(X,Numbers),
          	    fromto(0,S0,S,Total)
          	do  S is S0+X
          	).

`transpose(?X, ?Y)'
     is true when X is a list of the form
     [[X11,...,X1M],...,[XN1,...,XNM]] and Y is its transpose, that is,
     Y = [[X11,...,XN1],...,[X1M,...,XNM]] We insist that both lists
     should have this rectangular form, so that the predicate can be
     invertible.  For the same reason, we reject empty arrays with M =
     0 or N = 0.

`append_length(?PREFIX, ?SUFFIX, ?LIST, ?LENGTH)'
     is true when
              append(Prefix, Suffix, List), length(Prefix, Length).
     The normal use of this is to split a LIST into a PREFIX of a given
     LENGTH and the corresponding SUFFIX, but it can be used any way
     around provided that     LENGTH is instantiated, or     PREFIX is
     a proper list, or     LIST   is a proper list.

`append_length(?SUFFIX, ?LIST, ?LENGTH)'
     is true when there exists a list PREFIX such that
     `append_length(PREFIX, SUFFIX, LIST, LENGTH)' is true.  When you
     don't want to know the PREFIX, you should call this predicate,
     because it doesn't construct the PREFIX argument, which
     `append_length/4' would do.

`prefix_length(?LIST, ?PREFIX, ?LENGTH)'
     is true when
              prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that
     LENGTH is instantiated, or     PREFIX is a proper list, or
     LIST   is a proper list.  It is identical in effect to
     `append_length(Prefix, _, List, Length)'.

`proper_prefix_length(?LIST, ?PREFIX, ?LENGTH)'
     is true when
              proper_prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that
     LENGTH is instantiated, or     PREFIX is a proper list, or
     LIST   is a proper list.  It is logically equivalent to
     `prefix(Prefix, List, Length), Length > 0'.

`suffix_length(+LIST, ?SUFFIX, ?LENGTH)'
     is true when
              suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination,     LIST must be
     a proper list.  The predicate suffix/2 has the same requirement.
     If LENGTH is instantiated or SUFFIX is a proper list, this
     predicate is determinate.

`proper_suffix_length(+LIST, ?SUFFIX, ?LENGTH)'
     is true when
              proper_suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination,     LIST must be
     a proper list.  The predicate proper_suffix/2 has the same If
     LENGTH is instantiated or SUFFIX is a proper list, this predicate
     is determinate.

`rotate_list(+AMOUNT, ?LIST, ?ROTATED)'
     is true when LIST and ROTATED are lists of the same length, and
              append(Prefix, Suffix, List) &
              append(Suffix, Prefix, Rotated) &
              (   Amount >= 0 & length(Prefix, Amount)
              |   Amount =< 0 & length(Suffix, Amount)
              ).
     That is to say, LIST rotated LEFT by AMOUNT is ROTATED.   AMOUNT
     must already be instantiated.  As it is a strict input,  it must
     come first.

`rotate_list(?LIST, ?ROTATED)'
     is true when `rotate_list(1, List, Rotated)', but is a bit less
     heavy-handed.  `rotate_list(X, Y)' rotates X left  one place
     yielding Y.  `rotate_list(Y, X)' rotates X right one place
     yielding Y.  Either LIST or ROTATED should be a proper list.

`sublist(+WHOLE, ?PART, ?BEFORE, ?LENGTH, ?AFTER)'
     is true when
        * WHOLE is a list - it must be proper already

        * PART  is a list

        * WHOLE = ALPHA || PART || OMEGA

        * `length(ALPHA, BEFORE)'

        * `length(PART,  LENGTH)'

        * `length(OMEGA, AFTER)'

`cons(?HEAD, ?TAIL, ?LIST)'
     is true when HEAD is the head of LIST and TAIL is its tail.  i.e.
     `append([Head], Tail, List)'.   No restrictions.

`last(?FORE, ?LAST, ?LIST)'
     is true when LAST is the last element of LIST and FORE is the list
     of preceding elements, e.g. `append(Fore, [Last], List)'.  FORE or
     LAST should be proper.  It is expected that LIST will be proper
     and FORE unbound, but it will work in reverse too.

`head(?LIST, ?HEAD)'
     is true when LIST is a non-empty list and HEAD is its head.  A
     list has only one head.  No restrictions.

`tail(?LIST, ?TAIL)'
     is true when LIST is a non-empty list and TAIL is its tail.  A
     list has only one tail.  No restrictions.

`prefix(?LIST, ?PREFIX)'
     is true when LIST and PREFIX are lists and PREFIX is a prefix of
     LIST.  It terminates if either argument is proper, and has at most
     N+1 solutions.  Prefixes are enumerated in ascending order of
     length.

`proper_prefix(?LIST, ?PREFIX)'
     is true when LIST and PREFIX are lists and PREFIX is a proper
     prefix of LIST.  That is, PREFIX is a prefix of LIST but is not
     LIST itself.  It terminates if either argument is proper, and has
     at most N solutions.  Prefixes are enumerated in ascending order
     of length.

`suffix(?LIST, ?SUFFIX)'
     is true when LIST and SUFFIX are lists and SUFFIX is a suffix of
     LIST.  It terminates only if LIST is proper, and has at most N+1
     solutions.  Suffixes are enumerated in descending order of length.

`proper_suffix(?LIST, ?SUFFIX)'
     is true when LIST and SUFFIX are lists and SUFFIX is a proper
     suffix of LIST.  That is, SUFFIX is a suffix of LIST but is not
     LIST itself.  It terminates only if LIST is proper, and has at
     most N solutions.  Suffixes are enumerated in descending order of
     length.

`segment(?LIST, ?SEGMENT)'
     is true when LIST and SEGMENT are lists and SEGMENT is a segment
     of LIST.  That is, LIST = _ <> SEGMENT <> _ .  Terminates only if
     LIST is proper.  If SEGMENT is proper it enumerates all solutions.
     If neither argument is proper, it would have to diagonalise to
     find all solutions, but it doesn't, so it is then incomplete.  If
     SEGMENT is proper, it has at most N+1 solutions.  Otherwise, it
     has at most (1/2)(N+1)(N+2) solutions.

`proper_segment(?LIST, ?SEGMENT)'
     is true when LIST and SEGMENT are lists and SEGMENT is a proper
     segment of LIST.  It terminates only if LIST is proper.  The only
     solution of `segment/2' which is not a solution of
     `proper_segment/2' is `segment(List,List)'.  So `proper_segment/2'
     has one solution fewer.

`cumlist(:PRED, +[X1,...,XN], ?V0, ?[V1,...,VN])'
`cumlist(:PRED, +[X1,...,XN], +[Y1,...,YN], ?V0, ?[V1,...,VN])'
`cumlist(:PRED, +[X1,...,XN], +[Y1,...,YN], +[Z1,...,ZN], ?V0, ?[V1,...,VN])'
     `cumlist/4' maps a ternary predicate PRED down the list
     [X1,...,XN] just as `scanlist/4' does, and returns a list of the
     results.  It terminates when the lists runs out.  If PRED is
     bidirectional, it may be used to derive [X1...XN] from V0 and
     [V1...VN], e.g.  `cumlist(plus, [1,2,3,4], 0, /* -> */
     [1,3,6,10])' and `cumlist(plus, [1,1,1,1], /* <- */ 0, [1,2,3,4])'.
     Could be defined as:

          cumlist(Pred, Xs, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,V1,V)
          	).

          cumlist(Pred, Xs, Ys, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,Y,V1,V)
          	).

          cumlist(Pred, Xs, Ys, Zs, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,Y,Z,V1,V)
          	).

`maplist(:PRED, +LIST)'
     succeeds when PRED(X) succeeds for each element X of LIST.  Could
     be defined as:

          maplist(Pred, Xs) :-
          	(   foreach(X,Xs),
          	    param(Pred)
          	do  call(Pred, X)
          	).

`maplist(:PRED, +OLDLIST, ?NEWLIST)'
     succeeds when PRED(OLD,NEW) succeeds for each corresponding OLD in
     OLDLIST, NEW in NEWLIST.  Either OLDLIST or NEWLIST should be a
     proper list.  Could be defined as:

          maplist(Pred, Xs, Ys) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    param(Pred)
          	do  call(Pred, X, Y)
          	).

`maplist(:PRED, +XS, ?YS, ?ZS)'
     is true when XS, YS, and ZS are lists of equal length, and PRED(X,
     Y, Z) is true for corresponding elements X of XS, Y of YS, and Z
     of ZS.  At least one of XS, YS, and ZS should be a proper list.
     Could be defined as:

          maplist(Pred, Xs, Ys, Zs) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    param(Pred)
          	do  call(Pred, X, Y, Z)
          	).

`map_product(Pred, Xs, Ys, PredOfProduct)'
     Just as `maplist(P, Xs, L)' is the analogue of Miranda's
              let L = [ P x | x <- Xs ]
     so `map_product(P, Xs, Ys, L)' is the analogue of Miranda's
              let L = [ P x y | x <- Xs; y <- Ys ]
     That is, if XS = [X1,...,XM], YS = [Y1,...,YN], and P(XI,YJ,ZIJ),
     L = [Z11,...,Z1N,Z21,...,Z2N,...,ZM1,...,ZMN].  It is as if we
     formed the cartesian product of XS and YS and applied P to the
     (XI,YJ) pairs.  Could be defined as:

          map_product(Pred, Xs, Ys, Zs) :-
          	(   foreach(X,Xs),
          	    fromto(Zs,S0,S,[]),
          	    param([Ys,Pred])
          	do  (   foreach(Y,Ys),
          		fromto(S0,[Z|S1],S1,S),
          		param([X,Pred])
          	    do  call(Pred, X, Y, Z)
          	    )
          	).

`scanlist(:PRED, [X1,...,XN], ?V1, ?V)'
`scanlist(:PRED, [X1,...,XN], [Y1,...,YN], ?V1, ?V)'
`scanlist(:PRED, [X1,...,XN], [Y1,...,YN], [Z1,...,ZN], ?V1, ?V)'
     `scanlist/4' maps a ternary relation PRED down a list.  The
     computation is PRED(X1,V1,V2), PRED(X2,V2,V3), ..., PRED(XN,VN,V)
     So if PRED is `plus/3', `scanlist(plus, [X1,...,Xn], 0, V)' puts
     the sum of the list elements in V.  Note that the order of the
     arguments passed to Pred is the same as the order of the arguments
     following Pred.  This also holds for scanlist/5 and scanlist/6,
     e.g.  scanlist(Pred, Xs, Ys, Zs, V1, V) calls Pred(X3,Y3,Z3,V3,V4).
     Could be defined as:

          scanlist(Pred, Xs, V0, V) :-
          	(   foreach(X,Xs),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, V1, V2)
          	).

          scanlist(Pred, Xs, Ys, V0, V) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, Y, V1, V2)
          	).

          scanlist(Pred, Xs, Ys, Zs, V0, V) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, Y, Z, V1, V2)
          	).

`some(:PRED, +LIST)'
     succeeds when PRED(ELEM) succeeds for some ELEM in LIST.  It will
     try all ways of proving PRED for each ELEM, and will try each ELEM
     in the LIST.  `somechk/2' is to `some/2' as `memberchk/2' is to
     `member/2'.
              member(X,L)     <-> some(=(X), L).
              memberchk(X, L) <-> somechk(=(X), L).
              some(Pred,L)    <-> member(X, L), call(Pred,X).
     This acts on backtracking like member/2; List should be a proper
     list.

`some(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.

`some(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZI) is true for some I.

`somechk(:PRED, +[X1,...,XN])'
     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like `memberchk/2').

`somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').

`somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZN) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').

`convlist(:REWRITE, +OLDLIST, ?NEWLIST)'
     is a sort of hybrid of `maplist/3' and `include/3'.  Each element
     of NEWLIST is the image under REWRITE of some element of OLDLIST,
     and order is preserved, but elements of OLDLIST on which REWRITE
     is undefined (fails) are not represented.  Thus if `foo(K,X,Y) :-
     integer(X), Y is X+K.' then `convlist(foo(1), [1,a,0,joe(99),101],
     [2,1,102]).' OLDLIST should be a proper list.  Could be defined as:

          convlist(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,N) -> S0 = [N|S] ; S0 = S)
          	).

`exclude(:PRED, +XS, ?SUBLIST)'
`exclude(:PRED, +XS, +YS, ?SUBLIST)'
`exclude(:PRED, +XS, +YS, +ZS, ?SUBLIST)'
     succeeds when SUBLIST is the sublist of XS containing all the
     elements XI[,YI[,ZI]] for which PRED(XI[,YI[,ZI]]) is _false_.
     That is, it removes all the elements satisfying PRED.  Could be
     defined as:

          exclude(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = S ; S0 = [X|S])
          	).

          exclude(Pred, Xs, Ys, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y) -> S0 = S ; S0 = [X|S])
          	).

          exclude(Pred, Xs, Ys, Zs, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y,Z) -> S0 = S ; S0 = [X|S])
          	).

`include(:PRED, +XS, ?SUBLIST)'
`include(:PRED, +XS, +YS, ?SUBLIST)'
`include(:PRED, +XS, +YS, +ZS, ?SUBLIST)'
     succeeds when SUBLIST is the sublist of XS containing all the
     elements XI[,YI[,ZI]] for which PRED(XI[,YI[,ZI]]) is _true_.
     That is, it retains all the elements satisfying PRED.  Could be
     defined as:

          include(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, Ys, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, Ys, Zs, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y,Z) -> S0 = [X|S] ; S0 = S)
          	).

`partition(:PRED, +LIST, ?LESS, ?EQUAL, ?GREATER)'
     is a relative of `include/3' and `exclude/3' which has some
     pretensions to being logical.  For each X in LIST, we call
     PRED(X,R), and route X to LESS, EQUAL, or GREATER according as R
     is `<', `=', or `>' .

`group(:PRED, +LIST, ?FRONT, ?BACK)'
     is true when `append(Front, Back, List), maplist(Pred, Front)',
     and FRONT is as long as possible.

`group(:PRED, +KEY, +LIST, ?FRONT, ?BACK)'
     is true when `append(Front, Back, List), maplist(call(Pred,Key),
     Front)', and FRONT is as long as possible.  Strictly speaking we
     don't need it; `group(call(Pred,Key), List, Front, Back)' would do
     just as well.

`group(:PRED, +LIST, ?LISTOFLISTS)'
     is true when `append(ListOfLists, List)', each element of
     LISTOFLISTS has the form [HEAD|TAIL] such that `group(Pred, Head,
     Tail, Tail, [])', and each element of LISTOFLISTS is as long as
     possible.  For example, if you have a keysorted list, and define
     `same_key(K-_, K-_)', then `group(same_key, List, Buckets)' will
     divide LIST up into BUCKETS of pairs having the same key.

`ordered(+LIST)'
     is true when LIST is a list of terms [T1,T2,...,TN] such that for
     all K in 2..N TK-1 `<=' TK, i.e. T1 `<=' T2 `<=' T3 ...  The
     output of `keysort/2' is always ordered, and so is that of
     `sort/2'.  Beware: just because a list is ordered does not mean
     that it is the representation of an ordered set; it might contain
     duplicates.

`ordered(+P, +[T1,T2,...,TN])'
     is true when P(T1,T2) & P(T2,T3) & ...   That is, if you take P as
     a "comparison" predicate like `<=', the list is ordered.  This is
     good for generating prefixes of sequences, e.g. `L = [1,_,_,_,_],
     ordered(times(2), L)' yields `L = [1,2,4,8,16]'.

`max_member(?XMAX, +[X1,...,XN])'
     unifies XMAX with the maximum (in the sense of `<=') of X1,...,XN.
     If the list is empty, it fails quietly.  Could be defined as:

          max_member(Maximum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Maximum)
          	do  (X<=M0 -> M = M0 ; M = X)
          	).

`min_member(?XMIN, +[X1,...,XN])'
     unifies XMIN with the minimum (in the sense of `<=') of X1,...,XN.
     If the list is empty, it fails quietly.  Could be defined as:

          min_member(Minimum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Minimum)
          	do  (M0<=X -> M = M0 ; M = X)
          	).

`max_member(:P, ?XMAX, +[X1,...,XN])'
     unifies XMAX with the maximum element of [X1,...,XN], as defined
     by the comparison predicate P, which should act like `<=' .  Could
     be defined as:

          max_member(Pred, Maximum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Maximum),
          	    param(Pred)
          	do  (call(Pred,X,M0) -> M = M0 ; M = X)
          	).

`min_member(:P, ?XMIN, +[X1,...,XN])'
     unifies XMIN with the minimum element of [X1,...,XN], as defined
     by the comparison predicate P, which should act like `<=' .  Could
     be defined as:

          min_member(Pred, Minimum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Minimum),
          	    param(Pred)
          	do  (call(Pred,M0,X) -> M = M0 ; M = X)
          	).

`select_min(?ELEMENT, +SET, ?RESIDUE)'
     unifies ELEMENT with the smallest (in the sense of `<=') element
     of SET, and RESIDUE with a list of all the other elements.

`select_min(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the least ELEMENT of SET, i.e. PRED(ELEMENT,X) for all X in
     SET.

`select_max(?ELEMENT, +SET, ?RESIDUE)'
     unifies ELEMENT with the (leftmost) maximum element of the SET,
     and RESIDUE to the other elements in the same order.

`select_max(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the greatest ELEMENT of SET, i.e. PRED(X,ELEMENT) for all X
     in SET.

`increasing_prefix(?SEQUENCE, ?PREFIX, ?TAIL)'
     is true when `append(Prefix, Tail, Sequence)' and PREFIX, together
     with the first element of TAIL, forms a monotone non-decreasing
     sequence, and no longer Prefix will do.  Pictorially,
          Sequence = [x1,...,xm,xm+1,...,xn]
          Prefix   = [x1,...,xm]
          Tail     = [xm+1,...,xn]
          x1 <= x2 <= ... <= xm <= xm+1
          not xm+1 <= xm+2
     This is perhaps a surprising definition; you might expect that the
     first element of TAIL would be included in PREFIX.  However, this
     way, it means that if Sequence is a strictly decreasing sequence,
     the PREFIX will come out empty.

`increasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?TAIL)'
     is the same as `increasing_prefix/3', except that it uses the
     binary relation ORDER in place of `<='.

`decreasing_prefix(?SEQUENCE, ?PREFIX, ?TAIL)'
`decreasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?TAIL)'
     is the same, except it looks for a decreasing prefix.  The order
     is the converse of the given order.  That is, where
     `increasing_prefix/[3,4]' check X(R)Y, these routines check Y(R)X.

`clumps(+ITEMS, -CLUMPS)'
     is true when CLUMPS is a list of lists such that
        * `append(Clumps, Items)'

        * for each CLUMP in CLUMPS, all the elements of CLUMP are
          identical (`==')
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.

`keyclumps(+PAIRS, ?CLUMPS)'
     is true when PAIRS is a list of pairs and CLUMPS a list of lists
     such that
        * `append(Clumps, Pairs)'

        * for each CLUMP in CLUMPS, all of the KEY-VALUE pairs in CLUMP
          have identical (`==') KEYS.
     PAIRS must be a proper list of pairs for which keysorting would
     have been sound.  In fact, it usually is the result of keysorting.

`clumped(+ITEMS, ?COUNTS)'
     is true when COUNTS is a list of ITEM-COUNT pairs such that if
     `clumps(Items, Clumps)', then each ITEM-COUNT pair in COUNTS
     corresponds to an element [ITEM/*1*/,...,ITEM/*COUNT*/] of CLUMPS.
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.

`keyclumped(+PAIRS, ?GROUPS)'
     is true when PAIRS is a list of KEY-ITEM pairs and GROUPS is a
     list of KEY-ITEMS pairs such that if `keyclumps(Pairs, Clumps)',
     then for each K-[I1,...,IN] pair in GROUPS there is a
     [K-I1,...,K-IN] clump in CLUMPS.  PAIRS must be a proper list of
     pairs for which keysorting would have been sound.  In fact, it
     usually is the result of keysorting.


File: sicstus.info,  Node: lib-logarr,  Next: lib-objects,  Prev: lib-lists,  Up: The Prolog Library

10.12 Array Operations--`library(logarr)'
=========================================

This libary module provides extendible arrays with logarithmic access
time.  *Please note:* the atom `$' is used to indicate an unset
element, and the functor `$/4' is used to indicate a subtree.  In
general, array elements whose principal function symbol is `$' will not
work.

   Exported predicates:

     new_array(-A)     returns a new empty array A.

`is_array(+A)'
     checks whether A is an array.

`alist(+ARRAY, -LIST)'
     returns a list of pairs INDEX-ELEMENT of all the elements of ARRAY
     that have been set.

`aref(+INDEX, +ARRAY, -ELEMENT)'
     unifies ELEMENT with ARRAY[INDEX], or fails if ARRAY[INDEX] has
     not been set.

`arefa(+INDEX, +ARRAY, -ELEMENT)'
     is as `aref/3', except that it unifies ELEMENT with a new array if
     ARRAY[INDEX] is undefined.  This is useful for multidimensional
     arrays implemented as arrays of arrays.

`arefl(+INDEX, +ARRAY, -ELEMENT)'
     is as `aref/3', except that ELEMENT appears as `[]' for undefined
     cells.

`aset(+INDEX, +ARRAY, +ELEMENT, -NEWARRAY)'
     unifies NEWARRAY with the result of setting ARRAY[INDEX] to
     ELEMENT.


File: sicstus.info,  Node: lib-objects,  Next: lib-odbc,  Prev: lib-logarr,  Up: The Prolog Library

10.13 The Objects Package--`library(objects)'
=============================================

* Menu:

* obj-exp::                             Exported Predicates
* obj-glo::                             Glossary
* obj-bas::                             Introduction
* obj-scl::                             Simple Classes
* obj-inh::                             Inheritance
* obj-tcl::                             Term Classes
* obj-tech::                            Technical Details

   The SICStus Objects package enables programmers to write
object-oriented programs in SICStus Prolog. The objects in SICStus
Objects are modifiable data structures that provide a clean and
efficient alternative to storing data in the Prolog database.


File: sicstus.info,  Node: obj-bas,  Next: obj-scl,  Prev: obj-glo,  Up: lib-objects

10.13.1 Introduction
--------------------

* Menu:

* obj-bas-uobj::                        Using SICStus Objects
* obj-bas-def::                         Defining Classes
* obj-bas-ucl::                         Using Classes
* obj-bas-la::                          Looking Ahead

   The SICStus Objects package enables programmers to write
object-oriented programs in SICStus Prolog. The objects in SICStus
Objects are modifiable data structures that provide a clean and
efficient alternative to storing data in the Prolog database.

   This user's guide is neither an introduction to object-oriented
programming nor an introduction to SICStus Prolog. A number of small,
sample programs are described in this manual, and some larger programs
are in the `demo' directory.


File: sicstus.info,  Node: obj-bas-uobj,  Next: obj-bas-def,  Up: obj-bas

10.13.1.1 Using SICStus Objects
...............................

One of the basic ideas of object-oriented programming is the
encapsulation of data and procedures into objects. Each object belongs
to exactly one class, and an object is referred to as an instance of
its class. A class definition determines the following things for its
objects:

   * slots, where an object holds data

   * messages, the commands that can be sent to an object

   * methods, the procedures the object uses to respond to the messages

   All interaction with an object is by sending it messages. The command
to send a message to an object has the form

     OBJECT MESSAGEOP MESSAGE

where OBJECT is an object, MESSAGEOP is one of the message operators
(`<<', `>>', or `<-') and MESSAGE is a message defined for the object's
class.  Roughly speaking, the `>>' message operator is used for
extracting information from an object, `<<' is for storing information
into an object, and `<-' is for any other sort of operation.

   For example, using the point class defined in the next section, it
would be possible to give the following command, which demonstrates all
three message operators.

     | ?- create(point, PointObj),
          PointObj >> x(InitX),
          PointObj >> y(InitY),
          PointObj << x(2.71828),
          PointObj << y(3.14159),
          PointObj <- print(user_output),
          nl(user_output).

     (2.71828,3.14159)
     PointObj = point(23461854),
     InitX = 1.0,
     InitY = 2.0

   First it binds the variable `PointObj' to a newly created `point'
object. Then, the two get messages (sent with the `>>' operator) fetch
the initial values of the point's `x' and `y' slots, binding the
variables `InitX' and `InitY' to these values.  Next, the two put
messages (sent with the `<<' operator) assign new values to the
object's `x' and `y' slots. Finally, the send message (sent with the
`<-' operator) instructs the point object to print itself to the
`user_output' stream, followed by a newline.  Following the goal, we see
the point has been printed in a suitable form.  Following this, the
values of `PointObj', `InitX', and `InitY' are printed as usual for
goals entered at the top-level prompt.

   Because this goal is issued at the top-level prompt, the values of
the variables `PointObj', `InitX' and `InitY' are not retained after
the command is executed and their values are displayed, as with any
goal issued at the top-level prompt.  However, the point object still
exists, and it retains the changes made to its slots. Hence, objects,
like clauses asserted to the Prolog database, are more persistent than
Prolog variables.

   Another basic idea of object-oriented programming is the notion of
inheritance. Rather than defining each class separately, a new class
can inherit the properties of a more general superclass. Or, it can be
further specialized by defining a new subclass, which inherits its
properties. (C++ uses the phrase "base class" where we use
"superclass." It also uses "derived class" where we use "subclass.")

   SICStus Objects uses term expansion to translate object-oriented
programs into ordinary Prolog. (This is the same technique that Prolog
uses for its DCG grammar rules.) As much as possible is done at compile
time. Class definitions are used to generate Prolog clauses that
implement the class's methods. Message commands are translated into
calls to those Prolog clauses.  And, inheritance is resolved at
translation time.

   SICStus Objects consists of two modules, `obj_decl' and `objects'.
The `obj_decl' module is used at compile time to translate the
object-oriented features of SICStus Objects. Any file that defines
classes or sends messages should include the command

     :- load_files(library(obj_decl),
                   [when(compile_time), if(changed)]).

   The `objects' module provides runtime support for SICStus Objects
programs. A file that sends messages or asks questions about what
classes are defined or to what class an object belongs should include
the command:

     :- use_module(library(objects)).

   You will probably include both in most files that define and use
classes.

   *Please note:* A file that loads `library(obj_decl)' currently cannot
recursively load another file that loads `library(obj_decl)', because
that would confuse the internal database being used by the package.

   If you use the foreign resource linker, `splfr', on a Prolog file
that uses the `objects' package, you must pass it the `--objects'
option.  This will make `splfr' understand the package's syntax
extensions.


File: sicstus.info,  Node: obj-bas-def,  Next: obj-bas-ucl,  Prev: obj-bas-uobj,  Up: obj-bas

10.13.1.2 Defining Classes
..........................

A class definition can restrict the values of any slot to a particular
C-style type. It can specify whether a slot is "private" (the default,
meaning that it cannot be accessed except by that methods of that
class), "protected" (like "private", except that the slot can also be
accessed by subclasses of the class), or "public" (meaning get and put
methods for the slot are generated automatically), and it can specify
an initial value. The class definition also may contain method clauses,
which determine how instances of the class will respond to messages.  A
class definition may also specify one or more superclasses and which
methods are to be inherited.

   The point object created in the previous example had two floating
point slots, named `x' and `y', with initial values of 1.0 and 2.0,
respectively. As we have seen, the `point' class also defined put and
get methods for `x' and `y', as well as a send method for printing the
object.  The put and get methods for `x' and `y' can be automatically
generated simply by declaring the slots `public', but the `print'
method must be explicitly written.  In addition, in order to be able to
create instances of this class, we must define a `create' method, as
explained in *note obj-scl-meth::.  We also provide a second `create'
method, taking two arguments, allowing us to specify an `x' and `y'
value when we first create a point object.

     :- class point =
             [public x:float = 1.0,
              public y:float = 2.0].

     Self <- create.

     Self <- create(X, Y) :-
             Self << x(X),
             Self << y(Y).

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, '(~w,~w)', [X,Y]).

     :- end_class point.

   The variable name `Self' in these clauses is arbitrary--any variable
to the left of the message operator in the head of a method clause
refers to the instance of the class receiving the message.


File: sicstus.info,  Node: obj-bas-ucl,  Next: obj-bas-la,  Prev: obj-bas-def,  Up: obj-bas

10.13.1.3 Using Classes
.......................

Given this definition, the following command creates an instance of the
point class, assigning values to its `x' and `y' slots, and prints a
description of the point.

     | ?- create(point(3,4), PointObj),
          PointObj <- print(user_output).

   The print message prints `(3.0,4.0)'. The variable `PointObj' is
bound to a Prolog term of the form

     `point(ADDRESS)'

where ADDRESS is essentially a pointer to the object.

   In general, an object belonging to a class CLASSNAME will be
represented by a Prolog term of the form

     CLASSNAME(ADDRESS)

   The name CLASSNAME must be an atom. This manual refers to such a
term as if it were the object, not just a pointer to the object.  Users
are strongly discouraged from attempting to do pointer arithmetic with
the address.

   After execution of this command, the point object still exists, but
the variable `PointObj' can no longer be used to access it. So, while
objects resemble clauses asserted into the Prolog database in their
persistence, there is no automatic way to search for an object.
Objects are not automatically destroyed when they are no longer needed.
And, there is no automatic way to save an object from one Prolog
session to the next. It is the responsibility of the programmer to keep
track of objects, perhaps calling the `destroy/1' predicate for
particular objects that are no longer needed or asserting bookkeeping
facts into the Prolog database to keep track of important objects.


File: sicstus.info,  Node: obj-bas-la,  Prev: obj-bas-ucl,  Up: obj-bas

10.13.1.4 Looking Ahead
.......................

The next few sections of this manual describe the SICStus Objects
package in greater detail.  In particular, they describe how to define
classes, their methods and their slots, and how to reuse class
definitions via inheritance. Small sample programs and program
fragments are provided for most of the features described.

   Experienced Prolog programmers may choose to skip over these sections
and look at the sample programs in this package's demo directory,
referring to the reference pages as necessary. Everyone is encouraged
to experiment with the sample programs before writing their own
programs.


File: sicstus.info,  Node: obj-scl,  Next: obj-inh,  Prev: obj-bas,  Up: lib-objects

10.13.2 Simple Classes
----------------------

* Menu:

* obj-scl-scp::                         Scope of a Class Definition
* obj-scl-slt::                         Slots
* obj-scl-meth::                        Methods

   This section is about simple classes that inherit nothing--neither
slots nor methods--from more general superclasses. Everything about
these classes is given directly in their definitions, so they are the
best starting point for programming with SICStus Objects.

   The use of inheritance in defining classes is described in the next
section. Classes that inherit properties from superclasses are called
derived classes in some systems, such as C++. In general, the use of
inheritance extends the properties of the simple classes in this
section.


File: sicstus.info,  Node: obj-scl-scp,  Next: obj-scl-slt,  Up: obj-scl

10.13.2.1 Scope of a Class Definition
.....................................

A simple class definition begins with a statement of the form

     :- class CLASSNAME = [SLOTDEF, ...].

   The class's slots are described in the list of SLOTDEF terms. It is
possible, though not often useful, to define a class with no slots, by
specifying the empty list. In that case the `=' and the list may be
omitted.

   The class's methods are defined following the `class/1' directive,
by Prolog clauses. Most of this section is about defining and using
methods.

   The class definition ends with any of the following:

     :- end_class CLASSNAME.

or

     :- end_class.

or the next `class/1' directive or the end of the file. The CLASSNAME
argument to `end_class/1' must match the class name in the
corresponding `class/1' directive. It is not possible to nest one class
definition inside another.


File: sicstus.info,  Node: obj-scl-slt,  Next: obj-scl-meth,  Prev: obj-scl-scp,  Up: obj-scl

10.13.2.2 Slots
...............

A slot description has the form

     VISIBILITY SLOTNAME:SLOTTYPE = INITIALVALUE

where VISIBILITY and `= INITIALVALUE' are optional. Each slot of a
class must have a distinct name, given by the atom SLOTNAME. The
VISIBILITY, SLOTTYPE and INITIALVALUE parts of the slot description are
described separately.

Visibility
----------

A slot's visibility is either private, protected, or public. If its
visibility is not specified, the slot is private. The following example
shows all four possibilities:

     :- class example = [w:integer,
                         private   x:integer,
                         protected y:integer,
                         public    z:integer]

   Slot `z' is public, `y' is protected, and both `x' and `w' are
private.

   Direct access to private slots is strictly limited to the methods of
the class.  Any other access to such slots must be accomplished through
these methods.  Making slots private will allow you later to change how
you represent your class, adding and removing slots, without having to
change any code that uses your class.  You need only modify the methods
of the class to accomodate that change.  This is known as "information
hiding".

   Protected slots are much like private slots, except that they can
also be directly accessed by subclasses.  This means that if you wish to
modify the representation of your class, you will need to examine not
only the class itself, but also its subclasses.

   Public slots, in contrast, can be accessed from anywhere.  This is
accomplished through automatically generated get and put methods named
for the slot and taking one argument.  In the example above, our
`example' class would automatically support a get and put method named
`z/1'.  Note, however, that unlike other object oriented programming
languages that support them, public slots in SICStus Objects don't
violate information hiding.  This is because you may easily replace a
public slot with your own get and put methods of the same name.  In
this sense, a public slot is really only a protected slot with
automatically generated methods to fetch and store its contents.

   Within a method clause, any of the class's slots can be accessed via
the `fetch_slot/2' and `store_slot/2' predicates. These are the only
way to access private and protected slots. They may be used to define
get and put methods for the class, which provide controlled access to
the protected slots. But, they can only be used within the method
clauses for the class, and they can only refer to slots of the current
class and protected and public slots of superclasses.

   In the slot description, `public', `protected' and `private' are
used as prefix operators. The `obj_decl' module redefines the prefix
operator `public', as follows:

     :- op(600, fy, [public]).

   Unless you use the obsolete `public/1' directive in your Prolog
programs, this should cause no problems.

Types
-----

A slot's type restricts the kinds of values it may contain. The slot is
specified in the slot description by one of the following Prolog terms
with the corresponding meaning.  Most of these will be familiar, but
the last four, `address', `term', CLASS and `pointer(TYPE)', require
some additional explanation:

`integer'
     signed integer, large enough to hold a pointer

`integer_64   "since release 4.3"'
     64-bit signed integer

`integer_32'
     32-bit signed integer

`integer_16'
     16-bit signed integer

`integer_8'
     8-bit signed integer

`unsigned'
     unsigned integer, large enough to hold a pointer

`unsigned_64   "since release 4.3"'
     64-bit unsigned integer

`unsigned_32'
     32-bit unsigned integer

`unsigned_16'
     16-bit unsigned integer

`unsigned_8'
     8-bit unsigned integer

`float'
     64-bit floating point number

`float_32'
     32-bit floating point number

`atom'
     Prolog atom

`address'
     Pointer.  The `address' type is intended for use with foreign code.
     A slot of this type might store an address returned from a foreign
     function. That address might, in turn, be used in calling another
     foreign function. Hence, most Prolog programmers can safely ignore
     this type.

`term'
     Prolog term.  The `term' type is for general Prolog terms. Such a
     slot can hold any of the other types. However, if you know a slot
     will be used to hold only values of a particular type, it is more
     efficient to specify that type in the class definition.

     Storing a term containing free variables is similar to asserting a
     clause containing free variables into the Prolog database. The
     free variables in the term are replaced with new variables in the
     stored copy. And, when you fetch the term from the slot, you are
     really fetching a copy of the term, again with new variables.

`CLASS'
     where CLASS is the name of a defined class.  The class type is for
     any object in a class defined with SICStus Objects. Such a slot
     holds an object of its class or one of that class's descendants,
     or the `null' object.

`pointer(TYPE)'
     where TYPE is an atom.  The pointer type is intended for use with
     the Structs Package.  It is similar to the `address' type, except
     that access to this slot yields, and update to this slot expects,
     a term of arity 1 whose functor is TYPE and whose argument is the
     address. Again, most Prolog programmers can safely ignore this
     type.


Initial Values
--------------

A slot description may optionally specify an initial value for the
slot. The initial value is the value of the slot in every instance of
the class, when the object is first created. The initial value must be
a constant of the correct type for the slot.

   If an initial value is not specified, a slot is initialized to a
value that depends on its type. All numbers are initialized to 0, of the
appropriate type. Atom and term slots are initialized to the empty atom
(`'''). Addresses and pointers are initialized to null pointers. And,
objects are initialized to the `null' object.

   More complicated initialization--not the same constant for every
instance of the class--must be performed by create methods, which are
described later.

The `null' object
-----------------

The `null' object is a special object that is not an instance of any
class, but that can be stored in a slot intended for any class of
object.  This is very much like the `NULL' pointer in C.  This is
useful when you don't yet have an object to store in a particular slot.

   In Prolog, the `null' is represented by the atom `null'.

   Note that because the `null' object is not really an object of any
class, you cannot determine its class with `class_of/2'.  Unless noted
otherwise, when we write of an "object" in this document, we don't
include the `null' object.


File: sicstus.info,  Node: obj-scl-meth,  Prev: obj-scl-slt,  Up: obj-scl

10.13.2.3 Methods
.................

Some methods are defined by method clauses, between the `class/1'
directive and the end of the class's definition. Others are generated
automatically. There are three kinds of messages in SICStus Objects,
distinguished by the message operator they occur with:

`>>'
     A get message, which is typically used to fetch values from an
     object's slots.

`<<'
     A put message, which is typically used to store values in an
     object's slots.

`<-'
     A send message, which is used for other operations on or involving
     an object.

   SICStus Objects automatically generates some get and put methods.
And, it expects particular message names with the send operator for
create and destroy methods. For the most part, however, you are free to
use any message operators and any message names that seem appropriate.

   A method clause has one of these message operators as the principal
functor of its head. Its first argument, written to the left of the
message operator, is a variable. By convention, we use the variable
`Self'. Its second argument, written to the right of the message
operator, is a term whose functor is the name of the message and whose
arguments are its arguments.

   For example, in the class whose definition begins as follows, a
0-argument send message named `increment' is defined. No parentheses are
needed in the clause head, because the precedence of the `<-' message
operator is lower than that of the `:-' operator.

     :- class counter = [public count:integer = 0].

     Self <- increment :-
             Self >> count (X0),
             X1 is X0 + 1,
             Self << count (X1).

   Its definition uses the automatically generated get and put methods
for the public slot `count'.

   It may look as though this technique is directly adding clauses to
the `>>/2', `<</2' and `<-/2' predicates, but the method clauses are
transformed by term expansion, at compile time.  However, the method
clauses have the effect of extending the definitions of those
predicates.

   Methods are defined by Prolog clauses, so it is possible for them to
fail, like Prolog predicates, and it is possible for them to be
nondeterminate, producing multiple answers, upon backtracking. The rest
of this section describes different kinds of methods.

Get and Put Methods
-------------------

Get and put methods are generated automatically for each of a class's
public slots. These are 1-argument messages, named after the slots.

   In the point class whose definition begins with

     :- class point =
             [public x:float=0,
              public y:float=0].

the get and put methods are automatically generated for the `x' and `y'
slots. If the class defines a `create/0' method, the command

     | ?- create(point, PointObj),
          PointObj >>  x(OldX),
          PointObj >>  y(OldY),
          PointObj <<  x(3.14159),
          PointObj <<  y(2.71828).

creates a point object and binds both `OldX' and `OldY' to 0.0E+00, its
initial slot values. Then, it changes the values of the `x' and `y'
slots to 3.14159 and 2.71828, respectively. The variable `PointObj' is
bound to the point object.

   It is possible, and sometimes quite useful, to create get and put
methods for slots that don't exist. For example, it is possible to add
a polar coordinate interface to the point class by defining get and put
methods for `r' and `theta', even though there are no `r' and `theta'
slots. The get methods might be defined as follows:

     Self >> r(R) :-
             Self >> x(X),
             Self >> y(Y),
             R is sqrt(X*X + Y*Y).

     Self >> theta(T) :-
             Self >> x(X),
             Self >> y(Y),
             T is atan(Y/X).

   The put methods are left as an exercise.

   In the rational number class whose definition begins with:

     :- class rational =
             [public num:integer,
              public denom:integer].

get and put methods are automatically generated for the `num' and
`denom' slots. It might be reasonable to add a get method for `float',
which would provide a floating point approximation to the rational in
response to that get message. This is left as an exercise.

   It is also possible to define get and put methods that take more than
one argument. For example, it would be useful to have a put method for
the point class that sets both slots of a point object. Such a method
could be defined by

     Self << point(X,Y) :-
             Self << x(X),
             Self << y(Y).

   Similarly, a 2-argument get method for the rational number class
might be defined as

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   Note that the name of the put message is `(/)/2', and that the
parentheses are needed because of the relative precedences of the `>>'
and `/' operators.

   Put messages are used to store values in slots. Get messages,
however, may be used either to fetch a value from a slot or to test
whether a particular value is in a slot. For instance, the following
command tests whether the `do_something/2' predicate sets the point
object's `x' and `y' slots to 3.14159 and 2.71828, respectively.

     | ?- create(point, PointObj),
          do_something(PointObj),
          PointObj >> x(3.14159),
          PointObj >> y(2.71828).

   The `fetch_slot/2' predicate can similarly be used to test the value
of a slot.

   The effects of a put message (indeed, of any message) are not undone
upon backtracking. For example, the following command fails:

     | ?- create(point, PointObj),
          PointObj << x(3.14159),
          PointObj << y(2.71828),
          fail.

   But, it leaves behind a point object with `x' and `y' slots
containing the values 3.14159 and 2.71828, respectively. In this,
storing a value in an object's slot resembles storing a term in the
Prolog database with `assert/1'.

   Some care is required when storing Prolog terms containing unbound
variables in term slots.  For example, given the class definition that
begins with

     :- class prolog_term = [public p_term:term].

     Self <- create.

the following command would succeed:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,Y)),
          X = a,
          Y = b,
          TermObj >> p_term(foo(c,d)).

   The reason is that the free variables in `foo(X,Y)' are renamed when
the term is stored in the `prolog_term' object's `p_term' slot. This is
similar to what happens when such a term is asserted to the Prolog
database:

     | ?- retractall(foo(_,_)),
          assert(foo(X,Y)),
          X = a,
          Y = b,
          foo(c,d).

   However, this goal would fail, because `c' and `d' cannot be unified:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,X)),
          TermObj >> p_term(foo(c,d)).

Direct Slot Access
------------------

Get and put methods are not automatically generated for private and
protected slots. Those slots are accessed by the `fetch_slot/2' and
`store_slot/2' predicates, which may only appear in the body of a
method clause and which always operate on the object to which the
message is sent. It is not possible to access the slots of another
object with these predicates.

   You may declare a slot to be private or protected in order to limit
access to it. However, it is still possible, and frequently useful, to
define get and put methods for such a slot.

   For example, if numerator and denominator slots of the rational
number class were private rather than public, it would be possible to
define put methods to ensure that the denominator is never 0 and that
the numerator and denominator are relatively prime. The get methods
merely fetch slot values, but they need to be defined explicitly, since
the slots are private. The new definition of the rational number class
might start as follows:

     :- class rational =
             [num:integer=0,
              denom:integer=1].

     Self >> num(N) :-
             fetch_slot(num, N).

     Self >> denom(D) :-
             fetch_slot(denom, D).

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   One of the put methods for the class might be

     Self << num(NO) :-
             fetch_slot(denom, DO)
             reduce(NO, DO, N, D),
             store_slot(num, N),
             store_slot(denom, D).

where the `reduce/4' predicate would be defined to divide `NO' and `DO'
by their greatest common divisor, producing `N' and `D', respectively.

   The definition of `reduce/4' and the remaining put methods is left
as an exercise.  The put methods should fail for any message that
attempts to set the denominator to 0.

Send Methods
------------

Messages that do something more than fetch or store slot values are
usually defined as send messages. While the choice of message operators
is (usually) up to the programmer, choosing them carefully enhances the
readability of a program.

   For example, print methods might be defined for the point and
rational number classes, respectively, as

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, "(~w,~w)", [X, Y]).

and

     Self <- print(Stream) :-
             fetch_slot(num, N),
             fetch_slot(denom, D),
             format(Stream, "~w/~w", [N, D]).

   These methods are used to access slot values. But, the fact that the
values are printed to an output stream makes it more reasonable to
define them as send messages than get messages.

   Frequently send methods modify slot values. For example, the point
class might have methods that flip points around the x and y axes,
respectively:

     Self <- flip_x :-
             Self >> y(Y0),
             Y1 is -1 * Y0,
             Self << y(Y1).

     Self <- flip_y :-
             Self >> x(X0),
             X1 is -1 * X0,
             Self << x(X1).

   And, the rational number class might have a method that swaps the
numerator and denominator of a rational number object. It fails if the
numerator is 0.

     Self <- invert :-
             fetch_slot(num, N)
             N =\= 0,
             fetch_slot(denom, D)
             store_slot(num, D),
             store_slot(denom, N).

   These methods modify slot values, but they don't simply store values
that are given in the message. Hence, it is more reasonable to use the
send operator.

   It is possible for a method to produce more than one answer. For
example, the class whose definition begins with

     :- class interval =
             [public lower:integer,
              public upper:integer].

might define a send method

     Self <- in_interval(X) :-
             Self >> lower(L),
             Self >> upper(U),
             between(L, U, X).

which uses the `between/3' predicate from `library(between)'. The
`in_interval' message will bind `X' to each integer, one at a time,
between the lower and upper slots, inclusive. It fails if asked for too
many answers.

   The rest of this section describes particular kinds of send messages.

Create and Destroy Methods
--------------------------

Objects are created with the `create/2' predicate. When you define a
class, you must specify all the ways that instances of the class can be
created. The simplest creation method is defined as

     Self <- create.

   If this method were defined for CLASS, the command

     | ?- create(CLASS, `Object').

would create an instance of CLASS and bind the variable `Object' to that
instance. All slots would receive their (possibly default) initial
values.

   More generally, if the definition for CLASS contains a create method

     Self <- create(ARGUMENTS) :-
             BODY.

the command

     | ?- create(CLASS(ARGUMENTS), OBJECT).

will create an instance of CLASS and execute the BODY of the create
method, using the specified ARGUMENTS. The variable OBJECT is bound to
the new instance.

   If a simple class definition has no create methods, it is impossible
create instances of the class. While the absence of create methods may
be a programmer error, that is not always the case. Abstract classes,
which are classes that cannot have instances, are often quite useful in
defining a class hierarchy.

   Create methods can be used to initialize slots in situations when
specifying initial slot values will not suffice. (Remember that initial
values must be specified as constants at compile time).  The simplest
case uses the arguments of the create message as initial slot values.
For example, the definition of the point class might contain the
following create method.

     Self <- create(X,Y) :-
             Self << x(X),
             Self << y(Y).

   If used as follows

     | ?- create(point(3.14159, 2.71828), PointObj),
          PointObj >> x(X),
          PointObj >> y(Y).

it would give `X' and `Y' the values of 3.14159 and 2.71828,
respectively.

   In some cases, the create method might compute the initial values.
The following (partial) class definition uses the `date/1' predicate
from `library(date)' to initialize its year, month and day slots.

     :- class date_stamp =
             [year:integer,
              month:integer,
              day:integer].

     Self <- create :-
             date(date(Year, Month, Day)),
             store_slot(year, Year),
             store_slot(month, Month),
             store_slot(day, Day).

   All three slots are private, so it will be necessary to define get
methods in order to retrieve the time information. If no put methods
are defined, however, the date cannot be modified after the
`date_stamp' object is created (unless some other method for this class
invokes `store_slot/2' itself).

   Create methods can do more than initialize slot values. Consider the
`named_point' class, whose definition begins as follows:

     :- class named_point =
             [public name:atom,
              public x:float=1,
              public y:float=0].

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y),
             assert(name_point(Name, Self)).

   Not only does the `create/3' message initialize the slots of a new
`named_point' object, but it also adds a `name_point/2' fact to the
Prolog database, allowing each new object to be found by its name.
(This create method does not require the `named_point' object to have a
unique name. Defining a `uniq_named_point' class is left as an
exercise.)

   An object is destroyed with the `destroy/1' command. Unlike
`create/2', `destroy/1' does not require that you define a `destroy'
method for a class. However, `destroy/1' will send a destroy message
(with no arguments) to an object before it is destroyed, if a `destroy'
method is defined for the object's class.

   If a `named_point' object is ever destroyed, the address of the
object stored in this name `point/2' fact is no longer valid. Hence,
there should be a corresponding destroy method that retracts it.

     Self <- destroy :-
             Self >> name(Name),
             retract(name_point(Name, Self)).

   Similar create and destroy methods can be defined for objects that
allocate their own separate memory or that announce their existence to
foreign code.

Instance Methods
----------------

Instance methods allow each object in a class to have its own method
for handling a specified message. For example, in a push-button class
it would be convenient for each instance (each push-button) to have its
own method for responding to being pressed.

   The declaration

     :- instance_method NAME/ARITY, ....

inside a class definition states that the message NAME/ARITY supports
instance methods. If the class definition defines a method for this
message, it will be treated as a default method for the message.

   The `define_method/3' predicate installs a method for an object of
the class, and the `undefine_method/3' predicate removes that method.

   Suppose that the `date_stamp' class, defined earlier, declared an
instance method to print the year of a `date_stamp' instance.

     :- instance_method print_year/1.

     Self <- print_year(Stream) :-
             Self >> year(Y0),
             Y1 is YO + 1970,
             format(Stream, "~d", [Y1]).

   The arithmetic is necessary because UNIX dates are based on January
1, 1970.

   If a particular `date_stamp' object's date were to be printed in
Roman numerals, it could be given a different `print_year' method, using
the `define_method/3' predicate.

     | ?- create(date_stamp, DateObj),
          define_method(DateObj,
     		   print_year(Stream),
     		   print_roman_year(Stream, DateObj)).

   If this `date_stamp' object is created in 1994, a `print_year'
message sent to it would print the current year as

     MCMXCIV

   Defining the predicate `print_roman_year/2' is left as an exercise.
It must be able to access the `year' slot of a `date_stamp' object.
Because it is not defined by a method clause within the class
definition, `print_roman_year/2' cannot use the `get_slot/2' predicate.

   None of `instance_method/1', `define_method/3', `undefine_method/3'
specify a message operator. Instance methods can only be defined for
send messages.


File: sicstus.info,  Node: obj-inh,  Next: obj-tcl,  Prev: obj-scl,  Up: lib-objects

10.13.3 Inheritance
-------------------

* Menu:

* obj-inh-sih::                         Single Inheritance
* obj-inh-mih::                         Multiple Inheritance
* obj-inh-ask::                         Asking About Classes and Objects

   This section describes the additional features (and the additional
complexity) of defining classes with inheritance in SICStus Objects.
Most of what was said about classes in the previous section remains
true in these examples.


File: sicstus.info,  Node: obj-inh-sih,  Next: obj-inh-mih,  Up: obj-inh

10.13.3.1 Single Inheritance
............................

The simplest case is when a new class inherits some properties (slots
and methods) from a single superclass. That superclass may, in turn, be
defined in terms of its superclass, etc. The new class, its superclass,
its superclass's superclass (if any) and so on are all ancestors of the
new class.

Class Definitions
-----------------

The definition of a class with a single superclass begins with a
`class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] +  SUPERCLASS.

where the list of SLOTDEF descriptions may be empty. In that case, the
definition can simplified to

     :- class CLASSNAME = SUPERCLASS.

   The class SUPERCLASS must be a defined class when this definition is
given.

   In SICStus Objects, a subclass inherits all the slots of its
superclass. And, by default, it inherits all the methods of its
superclass. The remainder of this section describes what the programmer
can do to control this inheritance.

Slots
-----

A class's slots are a combination of those explicitly defined in its
slot description list and the slots it inherits from its superclass. In
SICStus Objects, a class inherits all the slots of its superclass. It
follows that a class inherits all the slots of all its ancestors.

   The programmer's control over inheritance of slots is limited. It is
not possible to rename an inherited slot, nor is it possible to change
its type, unless it is a class slot. It is possible to change a slot's
initial value. And, it is possible to effectively change a slot's
visibility.

   To change the initial value or the type (when allowed) of a slot,
include a new SLOTDEF in the list of slot descriptions for the class,
with the same slot name and a new type or initial value. The type of a
class slot can only be changed to a subclass of the type of the
superclass's slot. The new initial value must still be a constant of the
appropriate type.

   The `named_point' class, defined earlier, could have better been
defined from the point class, which began as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   The definition of the `named_point' class would then begin with

     :- class named_point =
             [public name:atom,
              public x:float=1.0] + point.

   This `named_point' class has public slots named `name', `x' and `y',
with the same types and initial values as the earlier `named_point'
definition, which did not use inheritance.  This `named_point' class
also inherits all the methods of the `point' class, which saves us from
having to write them again (and maintain them).

   A slot that was private or protected in a superclass may be defined
as public. This will cause get and put methods to be generated in the
subclass. A slot that was public in a superclass may be defined as
protected or private, but this does not prevent it from inheriting the
get and put methods of the superclass. For that, the `uninherit/1'
directive, defined below, is needed.

Methods
-------

In SICStus Objects, by default, a class inherits all the methods of its
superclass. The programmer has more control over the inheritance of
methods than the inheritance of slots, however. In particular, methods
can be uninherited and they can be redefined.

   To prevent a method from being inherited, use the `uninherit/1'
directive. For example, suppose that the class `point' is defined as
before. That is, its definition begins as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   Because both slots are public, a put method is automatically
generated for each, which allows their values to be changed.

   The definition of a new class `fixed_point' might begin as follows:

     :- class fixed_point = point.

     :- uninherit
             point << (x/l),
             point << (y/l).

     Self <- create(X, Y) :-
             store_slot(x, X),
             store_slot(y, Y).

   The parentheses are necessary because of the precedences of the `<<'
and `/' operators.

   Because the put methods from `point' are not inherited, no instance
of the `fixed_point' class can change its `x' and `y' values once
created--unless the class definition contains another method for doing
so. The get methods are inherited from `point', however.

   To redefine a method, simply include method clauses for its message
within a class's definition. The new method clauses replace, or shadow,
the inherited method clauses for this class.

   Another way to prevent the `x' and `y' slots of the `fixed_point'
class from being modified would be to shadow the put methods. For
example, they might be redefined as

     Self << x(_) :-
             format(user_error, "cannot modify x slot value.~n.", []),
             fail.

     Self << y(_) :-
             format(user_error, "cannot modify y slot value.~n", []),
             fail.

   Now attempts to modify the `x' or `y' values of a fixed point object
generate a specific error message and fail.  A more complicated version
would raise an appropriate exception.

Send Super
----------

Even when a superclass's method is shadowed or uninherited, it is
possible to use the superclass's method inside a method clause for the
new class. This makes it possible to define a "wrapper" for the
superclass's method, which invokes the superclass's method without
having to duplicate its code. This technique works with all message
types.

   Sending a message to a superclass is done with a command of the form

     `super' MESSAGEOP MESSAGE

where MESSAGEOP is one of the message operators (`<<', `>>' or `<-')
and MESSAGE is a message defined for the superclass.  A generalization
of this syntax may be used to specify which superclass to send the
message to.  This is discussed in *note obj-inh-mih::.

   Sending a message to a class's superclass can only be done within a
message clause.


File: sicstus.info,  Node: obj-inh-mih,  Next: obj-inh-ask,  Prev: obj-inh-sih,  Up: obj-inh

10.13.3.2 Multiple Inheritance
..............................

It is possible for a class to be defined with more than one superclass.
Because the class inherits properties from multiple superclasses, this
is referred to as multiple inheritance.

   Multiple inheritance is a complex and controversial topic. What
should be done about conflicting slot or method definitions? (This is
sometimes called a "name clash.") What should be done about slots that
are inherited from two or more superclasses, but that originate with a
common ancestor class? (This is sometimes called "repeated
inheritance".) Different systems take different approaches.

   SICStus Objects supports multiple inheritance in a limited but still
useful way. It does not allow repeated inheritance, and it places all
the responsibility for resolving name clashes on the programmer. This
section describes the multiple inheritance features of SICStus Objects.

Class Definitions
-----------------

The definition of a class with multiple superclasses begins with a
`class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] + SUPERCLASS + ....

   The list of slot descriptions and the superclasses to the right of
the `=' can appear in any order, without changing the class being
defined. In fact, the slot descriptions can be partitioned into more
than one list, without changing the class. However, it is best to adopt
a fairly simple style of writing class definition and use it
consistently.

   Just as the slot names in a list of slot descriptions must be
distinct, superclass names should not be repeated.

Slots
-----

In SICStus Objects, the programmer has no control over multiple
inheritance of slots. All slots from all superclasses are inherited.
And, the superclasses should have no slot names in common.

   As a consequence, in SICStus Objects no superclasses of a class
should have a common ancestor. The only exception would be the unusual
case where that common ancestor has no slots.

Methods
-------

By default, all methods are inherited from all superclasses. Any of the
superclasses' methods can be uninherited, as described earlier, by
using the `uninherit/1' directive.

   If the same message is defined for more than one superclass, however,
you must choose at most one method to inherit for the message. You may
choose none. You may do this by defining a new method for the message
(shadowing the superclasses' methods), or by using the `uninherit/1'
directive, or by using the `inherit/1' directive.

   The following is considered a classic example of multiple
inheritance.

     :- class toy.             % no slots in this class

     Self >> size(small).

     Self >> rolls(false).

     :- end_class toy.

     :- class truck.         % no slots in this class

     Self >> size(large).

     Self >> rolls(true).

     :- end_class truck.

   The idea expressed in these definitions is that most toys are small
and don't roll.  On the other hand, most trucks are large, but they do
roll. A toy truck shares one feature with each class, but we can hardly
expect a compiler to choose the correct one.

   The definition of a new class, toy_truck, might begin with

     :- class toy_truck = toy + truck.

   Rather than redefine the get methods for `size' and `rolls', we can
specify which to inherit in two ways. One way is positive, stating
which to inherit, and the other way is negative, stating which not to
inherit.

   The positive version would be

     :- inherit
             toy >> (size/1),
             truck >> (rolls/1).

   This is more convenient when a message is defined in several
superclasses, because all but the chosen method are uninherited. And,
it is probably easier to understand.

   The negative version would be

     :- uninherit
             toy >> (rolls/1),
             truck >> (size/1).

   The `toy_truck' class would exhibit the same behavior with either
definition.

   It is possible to define methods that access the shadowed or
uninherited methods of the superclasses, by sending the message to the
superclasses. In the case of multiple inheritance, however, it may be
necessary to specify which superclass to send the message to.

   The `toy_truck' class, for example, might define these methods:

     Self >> uninherited_size(S) :-
             super(truck) >> size(S).

     Self >> uninherited_rolls(R) :-
             super(toy) >> rolls(R).

   They provide access to the unchosen methods from `toy_truck''s
superclasses.

   While these examples with the toy_truck class are clearly "toy"
examples, the same techniques can be used in more realistic cases.

Abstract and Mixin Classes
--------------------------

While SICStus Objects only supports a limited form of multiple
inheritance, its facilities are sufficient for working with so-called
"mixin classes".

   The idea is to construct similar classes by first defining a class
that contains the things the desired classes have in common. Typically,
this will be an "abstract class", which will have no instances itself.
Then, provide the features that differentiate the desired classes with
a set of mixin classes

   Mixin classes that have nothing in common can safely be mixed
together, to build the desired classes. The mixin classes will usually
be abstract classes, also, because they are too specialized for their
instances to be useful on their own.

   The date_stamp class defined earlier would make a good mixin class. A
similar `time_stamp' class might be (partially) defined as follows:

     :- class time_stamp =
             [hour:integer,
              minute:integer,
              second:integer].

     Self <- create :-
             time(time(Hour, Minute, Second)),
             store_slot(hour, Hour),
             store_slot(minute, Minute),
             store_slot(second, Second).

   Another mixin class might be used to "register" objects in the Prolog
database.

     :- class registry = [name:atom].

     Self <- create(Name) :-
             Self << name(Name),
             assert(registered(Name, Self)).

     Self <- destroy :-
             Self >> name(Name),
             retract(registered(Name, Self)).

   The `registry' mixin class could have been used with the `point'
class to define the `named_point' class, which was an example from an
earlier section.

   The ability to send a message to an object's superclass is useful
when working with mixin classes. Suppose the definition of a new class
begins with

     :- NEWCLASS = OLDCLASS + date + time + registry.

where OLDCLASS is some previously defined class that lacks the features
provided by the `date', `time' and `registry' classes. (In fact, they
should not have any slot names in common.)  Then its create method can
be defined by

     Self <- create(Name) :-
             super(OldClass) <- create,
             super(date) <- create,
             super(time) <- create,
             super(registry) <- create(Name).

   This avoids the need to duplicate the code in the create methods of
OldClass and all three mixin classes.


File: sicstus.info,  Node: obj-inh-ask,  Prev: obj-inh-mih,  Up: obj-inh

10.13.3.3 Asking About Classes and Objects
..........................................

It is possible to determine, at run time, what classes are defined, how
they are related by inheritance, what class an object belongs to, etc.
This section describes the predicates used for those purposes. Most of
the predicates involve the class hierarchy, so they are properly
described in the section on inheritance. But, several can be useful
even in programs that use only simple classes.

   Most of these predicates come in pairs, where one predicate involves
one class or its direct superclasses, and the other predicate involves
all ancestors. For example, the `class_superclass/2' and
`class_ancestor/2' predicates connect a currently defined class to its
superclass(es) and to all its ancestors, respectively.

   In all of these predicates, the ancestors of a class include not only
superclasses and their ancestors, but also the class itself. A class
cannot be a superclass of itself, by the rules of defining classes.
However, it is convenient to consider every class an ancestor of
itself, because then we may say that every property of a class is
defined in one of its ancestors, without having to say "the class
itself or a superclass or a superclass of a superclass, etc."

Objects
-------

The `class_of/2' predicate is used to test whether an object is of a
particular type or to determine the type of an object. Similarly, the
`descendant_of/2' predicate relates an object to all ancestors of its
class. (Remember that the object's class is, itself, an ancestor class
of the object.)

   Both require the first argument (the object) to be instantiated. That
is, the predicates cannot be used to find objects of a given class. If
you need to search among all the objects of a class, you must provide a
way to do it. One way to do this is to assert a fact connecting the
class name to every object, when it is created. The named_point example
of the previous section took that idea a step further by allowing each
object to have a different name.

   The `pointer_object/2' predicate relates an object's address (a
pointer) to the object. Remember that an instance of CLASS is
represented by a term of the form

     CLASS(ADDRESS)

   The `pointer_object/2' predicate requires that one of its arguments
be instantiated, but it may be either one. Hence, just by knowing the
address of an object (which possibly was returned by a foreign
function) it is possible to determine the object's type.

   Most Prolog programmers can safely ignore the `pointer_object/2'
predicate, unless they are using SICStus Objects with foreign functions
or with the Structs package.

Classes
-------

The `current_class/1' predicate is used to ask whether a class is
currently defined or to get the names of all currently defined classes.

   The `class_superclass/2' predicate is used to test whether one class
is a superclass of another, or to find a class's superclasses, or to
find a class's subclasses, or to find all subclass-superclass pairs.
The `class_ancestor/2' predicate is used in the same ways for the
ancestor relation between currently defined classes.

   As an example, the following goal finds all the ancestors of each
currently defined class.

     | ?- setof(C-As,
     	   (current_class(C),
     	    setof(A, class_ancestor(C,A), As)),
     	   L).

   It binds `L' to a list of terms of the form CLASS-ANCESTORLIST, with
one term for each currently defined class.

   Arguably, this predicate violates the principle of information
hiding, by letting you ask about how a class is defined.  Therefore, you
should generally avoid it.  It may be useful, however, in debugging and
in building programmer support tools.

Messages
--------

The `message/4' predicate is used to ask whether a message is defined
for a class or to find what messages are defined for a class, etc. It
does not distinguish between messages whose methods are defined in the
class itself and those that are inherited from a superclass.

   The `direct_message/4' predicate is used to ask whether a message is
not only defined for a class, but whether the method for that message
is defined in the class itself. It can also be used to determine which
methods are defined in a class. This ability to look inside a class
definition makes `direct_message/4' an egregious violator of the
principle of information hiding.  Thus it, like `class_ancestor/2',
should mainly be confined to use in programmer support applications.

   Both `message/4' and `direct_message/4' take the message operator as
an argument, along with the class, message name and arity. Hence it is
possible to use these predicates to ask about get, put or send messages.

   It is not possible to ask about a class's slots, nor should it be.
However, it is possible (and quite reasonable) to ask about the get and
put messages that are defined for a class. For example, the following
goal finds all the 1-argument messages that are defined for both the
get and put message operators in the class CLASS.

     | ?- setof(Message,
     	   (message(CLASS, <<, Msg, 1),
     	    message(CLASS, >>, Msg, 1)),
     	   L).

   There may or may not be slots corresponding to these messages; that
detail is hidden in the definition of CLASS. However, it should be
possible to use CLASS as if the slots were there.

   As an example, recall the polar coordinate interface to the point
class, which defined get and put methods for `r' and `theta', even
though data was represented inside an object by rectangular coordinates
`x' and `y'.


File: sicstus.info,  Node: obj-tcl,  Next: obj-tech,  Prev: obj-inh,  Up: lib-objects

10.13.4 Term Classes
--------------------

* Menu:

* obj-tcl-stcl::                        Simple Term Classes
* obj-tcl-rtrm::                        Restricted Term Classes
* obj-tcl-tce::                         Specifying a Term Class Essence

   Sometimes it is convenient to be able to send messages to ordinary
Prolog terms as if they were objects.  Prolog terms are easier to
create than objects, and unlike objects, they are automatically garbage
collected (see *note obj-tech-lim::).  Of course, unlike objects,
Prolog terms cannot be modified.  However, when a particular class of
objects never needs to be dynamically modified, and doesn't need to be
subclassed, it may be appropriate to define it as a "term class".

   A term class is defined much like an ordinary class:  it begins with
a `:- class' directive defining the class and its slots, follows with
clauses defining the methods for this class, and ends with an `:-
end_class' directive, the end of the file, or another `:- class'
directive.  The only difference is in the form of the `:- class'
directive introducing a term class definition.


File: sicstus.info,  Node: obj-tcl-stcl,  Next: obj-tcl-rtrm,  Up: obj-tcl

10.13.4.1 Simple Term Classes
.............................

The simplest sort of term class declaration has the following form:
     :- class CLASSNAME = term(TERM).

   This declares that any term that unifies with TERM is an instance of
class CLASSNAME.  For example, you might declare:
     :- class rgb_color = term(color(_Red,_Green,_Blue)).

     color(R,_G,_B) >> red(R).
     color(_R,G,_B) >> green(G).
     color(_R,_G,B) >> blue(B).

     :- end_class rgb_color.

   This would declare any term whose principal functor is `color' and
arity is three to be an object of class `rgb_color'.  Given this
declaration, entering the goal
     color(0.5, 0.1, 0.6) >> blue(B)

would bind `B' to 0.6.

   Note that you cannot use `create/2' to create a term class instance.
Since they are just ordinary terms, you can create them the same way
you'd create any ordinary Prolog term.  Similarly, you cannot modify an
existing term class instance.

   You may specify a term class as the type of a slot of an ordinary
class.  This is effectively the same as specifing the type to be
`term'.  In particular, fetching and storing term class slots is not
very efficient.  Also, the default value for slots of term class type
is `'''; this is because not enough is known about a simple term class
to determine a better default.  For an explanation of how to avoid
these pitfalls, see *note obj-tcl-tce::.


File: sicstus.info,  Node: obj-tcl-rtrm,  Next: obj-tcl-tce,  Prev: obj-tcl-stcl,  Up: obj-tcl

10.13.4.2 Restricted Term Classes
.................................

The intention of the `rgb_color' class presented above is to represent a
color as a triple of floating point numbers between 0.0 and 1.0.  But
the above definition does not restrict the arguments of the `color'
term in any way:  _any_ `color/3' term is considered to be an instance
of the `rgb_color' class.

   The second form of term class declaration allows you to specify
constraints on instances of a term class.  The form of such a
declaration is as follows:
     :- class CLASSNAME = term(TERM, CONSTRAINT).

   This declares that any term that unifies with TERM and satisfies
CONSTRAINT is an instance of class CLASSNAME.  The CONSTRAINT term is
an ordinary Prolog goal, which will usually share variables with TERM.

   To extend our `rgb_color' class example so that only `color/3' terms
whose arguments are all floats between 0.0 and 1.0 are instances of
`rgb_color', we would instead begin the definition as follows:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0)).

   Note the parentheses around the constraint in this example.  Whenever
the constraint contains multiple goals separated by commas, you will
need to surround the goal with parentheses.

   With this definition of the `rgb_color' class, only `color/3' terms
whose arguments are all floating point numbers between 0 and 1
inclusive will be considered to be instances of `rgb_color'.


File: sicstus.info,  Node: obj-tcl-tce,  Prev: obj-tcl-rtrm,  Up: obj-tcl

10.13.4.3 Specifying a Term Class Essence
.........................................

As mentioned above, it is possible to specify a term class as the type
of a slot of some other object.  For example, we might declare

     :- class colored_rectangle = [
             public origin:point,
             public size:size,
             public color:rgb_color].

   This will store an `rgb_color' object (i.e., a `color/3' term) in
the `color' slot of each `colored_rectangle' object.  Unfortunately,
though, SICStus Objects cannot tell what is the best way to store a
term object, and therefore it stores it the same way it stores a slot
declared to be of `term' type: using the Prolog database.  This has all
the efficiency disadvantages of `term' slots.  In this case, however,
we know that all that really needs to be saved in order to save an
`rgb_color' object is the three arguments.  We also know that each of
these arguments is a floating point number, and because precision isn't
terribly critical in representating colors, each of these numbers can
be stored as a `float', rather than a `double'.  In effect, we know
that the _essence_ of a `rgb_color' object is these three numbers; if
we have them, we can easily construct the `color/3' term.  If we
provide this information in the declaration of the `rgb_color' class,
SICStus Objects can store instances of the `rgb_color' class as 3
separate floats, rather than as a term, significantly improving the
performance of creating or destroying a `colored_rectangle' object, as
well as accessing or modifying its `color' slot.

   The essence of a term class is specified with the following form of
`class' declaration:
     :- class CLASSNAME = term(TERM, CONSTRAINT, ESSENCE).

where ESSENCE is of the form
     [NAME1:TYPE1=i[Variable1], NAME2:TYPE2=i[Variable2], ...]

and each NAME is a distinct atom naming a slot, each TYPE is a slot
type as specified in *note obj-scl-slt::, and each VARIABLE is an
unbound variable appering in TERM.  Providing a term essence not only
makes storage of terms in ordinary object slots more efficient, it also
gives a name to each "essential" slot of the term class.  This allows
you to use `fetch_slot' to fetch the slots of this class.

   To extend our `rgb_color' example, we might introduce the `rgb_color'
class with this declaration:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0),
                   [red:float=Red, green:float=Green, blue:float=Blue]).

   This declaration defines the `rgb_color' class exactly as the
example declaration of the previous section: every `color/3' term whose
arguments are all floating point numbers between 0.0 and 1.0 inclusive
are instances of `rgb_color'.  The difference is that with this
declaration, ordinary classes that have slots of type `rgb_color', such
as the `colored_rectangle' example above, will be stored more
efficiently, and their `rgb_color' slots will be accessed and modified
much more efficiently.  Also, it will be possible to use
`fetch_slot(red, Red)' in the methods of the `rgb_color' class to fetch
to red component of the message recipient, and similarly for `green'
and `blue'.


File: sicstus.info,  Node: obj-tech,  Prev: obj-tcl,  Up: lib-objects

10.13.5 Technical Details
-------------------------

* Menu:

* obj-tech-syn::                        Syntax of Class Definitions
* obj-tech-lim::                        Limitations

   This section will be expanded in future versions of SICStus Objects.
For now, it provides a BNF grammar for the syntax of class definitions
and a short list of some limitations of SICStus Objects.


File: sicstus.info,  Node: obj-tech-syn,  Next: obj-tech-lim,  Up: obj-tech

10.13.5.1 Syntax of Class Definitions
.....................................

The following BNF grammar gives a concise description of the syntax of
class definitions. It assumes an understanding of Prolog syntax for the
following items: "variable", "atom", "compound_term", and "constant".
Slot types, particularly the `address', `class' and `pointer' types,
were discussed in an earlier section.


CLASS_DEF          ::= CLASS_BEGIN { CLAUSE | METHOD } CLASS_END

CLASS_BEGIN        ::= `:- class' CLASS_NAME OPT_CLASS_SPEC `.'

OPT_CLASS_SPEC     ::= EMPTY | `=' CLASS_SPEC

CLASS_SPEC         ::= MULTI_PARENT_OR_SLOTS | TERM_CLASS_SPEC

CLAUSE             ::= HEAD OPT_BODY `.'

HEAD               ::= ATOM | COMPOUND_TERM `.'

METHOD             ::= MESSAGE_HEAD OPT_BODY `.'

MESSAGE_HEAD       ::= MESSAGE_GOAL

CLASS_END          ::= `:- end_class' OPT_CLASS_NAME `.'
                   | EMPTY /* if followed by CLASS_BEGIN or EOF */

MESSAGE            ::= ATOM | COMPOUND_TERM

MULTI_PARENT_OR_SLOTS::= PARENT_OR_SLOTS { `+' PARENT_OR_SLOTS }

PARENT_OR_SLOTS    ::= CLASS_NAME | `[]' | `[' SLOT_DEF {`,' SLOT_DEF }
                   `]'

SLOT_DEF           ::= OPT_VISIBILITY SLOT_NAME `:' SLOT_TYPE
                   OPT_INIT_VALUE

OPT_VISIBILITY     ::= EMPTY | `private' | `protected' | `public'

OPT_INIT_VALUE     ::= EMPTY | `=' CONSTANT

TERM_CLASS_SPEC    ::= `term('TERM OPT_GOAL_ESSENCE`)'

OPT_GOAL_ESSENCE   ::= EMPTY | `,' GOAL OPT_ESSENCE

OPT_ESSENCE        ::= EMPTY | `,' ESSENCE

ESSENCE            ::= `['  VARIABLE `:' SLOT_TYPE { `,' VARIABLE `:'
                   SLOT_TYPE } `]'

OPT_BODY           ::= EMPTY | `:-' BODY

BODY               ::= MESSAGE_OR_GOAL { `,' MESSAGE_OR_GOAL }

MESSAGE_OR_GOAL    ::= MESSAGE_GOAL | GOAL

MESSAGE_GOAL       ::= VARIABLE MESSAGE_OPERATOR MESSAGE

MESSAGE_OPERATOR   ::= `<<' | `>>' | `<-'

OPT_CLASS_NAME     ::= EMPTY | CLASS_NAME

CLASS_NAME         ::= ATOM

SLOT_NAME          ::= ATOM

SLOT_TYPE          ::= `integer'
                   | `short'
                   | `char'
                   | `unsigned_short'
                   | `unsigned_char'
                   | `float'
                   | `double'
                   | `atom'
                   | `address'
                   | `term'
                   | CLASS_NAME
                   | `pointer(ATOM)'



File: sicstus.info,  Node: obj-tech-lim,  Prev: obj-tech-syn,  Up: obj-tech

10.13.5.2 Limitations
.....................

This section summarizes the current limitations of SICStus Objects.

Debugging
---------

When you debug SICStus Objects programs that were compiled using the
`obj_decl' module, you are tracing the translated version of your code.
This includes all method clauses and (some) message sending commands.

   The source-linked debugger cannot connect compiled SICStus Objects
code with the source code.

Garbage Collection
------------------

There is no garbage collection of objects. It is the responsibility of
the programmer to keep track of unused objects. In particular, avoid
doing the following:

     | ?- create(CLASS, OBJECT).

   Unless the create message for CLASS made some provision for finding
the new object again, it is now lost. It cannot be used, and it cannot
be destroyed.

Multiple Inheritance
--------------------

The provisions for multiple inheritance in this version of SICStus
Objects are limited. In particular, there is no control over the
inheritance of slots, which makes repeated inheritance impossible.
However, it does support the mixin style of multiple inheritance.

Persistence
-----------

While objects are more persistent than Prolog variables, there is no
automatic way to save objects from one execution of your program to the
next. Hence they are less persistent than the clauses in the Prolog
database.

   If you need to save a set of objects from one Prolog session to
another, copy the objects to the Prolog database as terms, and save
them to a QOF file. Then, after you reload the QOF file, rebuild the
objects. Keep in mind that addresses are not valid from one session to
another.

   In short, there is no way to avoid initializing objects at run time.


File: sicstus.info,  Node: obj-exp,  Next: obj-glo,  Up: lib-objects

10.13.6 Exported Predicates
---------------------------

* Menu:

* obj-exp-send::                        <-/2
* obj-exp-put::                         <</2
* obj-exp-get::                         >>/2
* obj-exp-class::                       class/1
* obj-exp-class_ancestor::              class_ancestor/2
* obj-exp-class_method::                class_method/1
* obj-exp-class_superclass::            class_superclass/2
* obj-exp-class_of::                    class_of/2
* obj-exp-create::                      create/2
* obj-exp-current_class::               current_class/1
* obj-exp-debug_message::               debug_message/0
* obj-exp-define_method::               define_method/3
* obj-exp-descendant_of::               descendant_of/2
* obj-exp-destroy::                     destroy/1
* obj-exp-direct_message::              direct_message/4
* obj-exp-end_class::                   end_class/[0,1]
* obj-exp-fetch_slot::                  fetch_slot/2
* obj-exp-inherit::                     inherit/1
* obj-exp-instance_method::             instance_method/1
* obj-exp-message::                     message/4
* obj-exp-nodebug_message::             nodebug_message/0
* obj-exp-pointer_object::              pointer_object/2
* obj-exp-store_slot::                  store_slot/2
* obj-exp-undefine_method::             undefine_method/3
* obj-exp-uninherit::                   uninherit/1

   The following reference pages, alphabetically arranged, describe the
exported SICStus Objects predicates.  They can be imported by an
embedded command:

     :- use_module(library(objects)).


File: sicstus.info,  Node: obj-exp-send,  Next: obj-exp-put,  Up: obj-exp

10.13.6.1 `<-/2'
................

Synopsis
--------

+OBJ `<-' +MESG

Arguments
---------

OBJ
     "object"

MESG
     "term"


Description
-----------

Sends MESG to OBJ. A send message. The class of OBJ must have a method
defined for this message.

   A clause with `<-/2' as the principal functor of its head is a
method definition clause. Such clauses only occur within the scope of a
class definition. They are expanded at compile time.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`domain_error'
     MESG is not "callable" or OBJ is not a valid object.

`existence_error'
     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error will only be raised if
the code that sends the message is compiled with debugging enabled (see
`debug_message'), or if the message is not determined at compile-time.
In other circumstances, the message will simply fail.

   Calls to the `<-/2' predicate will be compiled into more efficient
code if the `obj_decl' module is loaded at compile time.

See Also
--------

`<</2', `>>/2', `direct_message/4', `message/4'


File: sicstus.info,  Node: obj-exp-put,  Next: obj-exp-get,  Prev: obj-exp-send,  Up: obj-exp

10.13.6.2 `<</2'
................

Synopsis
--------

+OBJ `<<' +ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"


Description
-----------

Sends a message to `Obj' to store the value of `Att' in the object. A
put message. `Att' must be an attribute that can be stored in objects
of `Obj''s class.

   A clause with `<</2' as the principal functor of its head is a
method definition clause. Such clauses only occur within the scope of a
class definition. They are expanded at compile time.

   Put methods are automatically generated for public slots.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`domain_error'
     MESG is not "callable" or OBJ is not a valid object.

`existence_error'
     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see `debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the `<</2' predicate will be compiled into more efficient
code if the `obj_decl' module is loaded at compile time.

See Also
--------

`<-/2', `>>/2', `direct_message/4', `message/4', `store_slot/2'


File: sicstus.info,  Node: obj-exp-get,  Next: obj-exp-class,  Prev: obj-exp-put,  Up: obj-exp

10.13.6.3 `>>/2'
................

Synopsis
--------

+OBJ `>>' +-ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"


Description
-----------

Sends a message to OBJ that fetches the value of ATT from the object. A
get message. ATT must be an attribute to fetch from OBJ's class.

   A clause with `>>/2' as the principal functor of its head is a
method definition clause. Such clauses only occur within the scope of a
class definition. They are expanded at compile time.

   Get methods are automatically generated for public slots.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`domain_error'
     MESG is not "callable" or OBJ is not a valid object.

`existence_error'
     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see `debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the `>>/2' predicate will be compiled into more efficient
code if the `obj_decl' module is loaded at compile time.

See Also
--------

`<-/2', `<</2', `direct_message/4', `message/4', `fetch_slot/2'


File: sicstus.info,  Node: obj-exp-class,  Next: obj-exp-class_ancestor,  Prev: obj-exp-get,  Up: obj-exp

10.13.6.4 `class/1'  "declaration"
..................................

Synopsis
--------

`:- class CLASSNAME.'

   `:- class CLASSNAME = [SLOTDEF, ...].'

   `:- class CLASSNAME = SUPER.'

   `:- class CLASSNAME = [SLOTDEF, ...] + SUPER + ....'

   `:- class CLASSNAME = term(TERM).'

   `:- class CLASSNAME = term(TERM, GOAL).'

   `:- class CLASSNAME = term(TERM, GOAL, ESSENCE).'

Arguments
---------

CLASSNAME
     "atom"

SLOTDEF
     "term"

SUPER
     "atom"


Description
-----------

The definition of class CLASSNAME begins with this `class/1' directive
and ends with the next `class/1' directive, the next `end_class/[0,1]'
directive, or the end of the file, whichever comes first.  All clauses
that look like method definitions within the scope of the class
definition (that is, which have one of `<-/2', `<</2' or `>>/2' as the
principal functors of their heads) are considered method definitions of
the class.

   You may provide as many slot definitions (SLOTDEF) and superclasses
(SUPER) as you like. All superclasses must be previously defined
classes.

   A slot definition (SlotDef) has the form

     VISIBILITY SLOTNAME:TYPE = INITIALVALUE

where VISIBILITY and `= INITIALVALUE' are optional.

   VISIBILITY is either `public', `protected', or `private'. If it is
omitted, the slot is private.

   SLOTNAME must be an atom.

   SLOTTYPE must be one of the following:

`integer'
     signed integer, large enough to hold a pointer

`integer_64   "since release 4.3"'
     64-bit signed integer

`integer_32'
     32-bit signed integer

`integer_16'
     16-bit signed integer

`integer_8'
     8-bit signed integer

`unsigned'
     unsigned integer, large enough to hold a pointer

`unsigned_64   "since release 4.3"'
     64-bit unsigned integer

`unsigned_32'
     32-bit unsigned integer

`unsigned_16'
     16-bit unsigned integer

`unsigned_8'
     8-bit unsigned integer

`float'
     64-bit floating point number

`float_32'
     32-bit floating point number

`atom'
     Prolog atom

`address'
     pointer

`term'
     Prolog term

`CLASS'
     pointer to an instance of CLASS, which must be a previously
     defined class

`pointer(TYPE)'
     like `address', except that access to this slot yields, and update
     of this slot expects, a unary term whose functor is TYPE

   INITIALVALUE may be any constant appropriate for the slot's type.

   TERM, if specified, is any compound Prolog term.  Class declarations
of any of the last three forms introduce a "term class", which defines
any term that unifies with TERM as an instance of the class being
defined.

   GOAL, if specified, is any Prolog goal.  This goal may be used to
restrict which terms that unify with TERM will be considered to be
instance of the class being defined.  The default GOAL is `true'.
Other than when it is `true', GOAL will usually share variables with
TERM.

   ESSENCE, if specified, is a list of terms of the form
     VARIABLE:TYPE

where VARIABLE is a variable apprearing somewhere in TERM and TYPE is
one of the possible SLOTTYPE types listed above.  There should be a
VARIABLE`:'TYPE pair for every variable in TERM.  By specifying an
essence, you permit much more space- and time-efficient storage of and
access to term slots.

Caveat
------

Note that every class for which you want to be able to create instances
must define at least one create method.

Examples
--------

The following class definition is for a class named `point', with two
public slots, named `x' and `y'. Both slots are of type `integer' and
have initial values of 1 and 2, respectively.

     :- class point =
             [public x:integer=1,
              public y:integer=2].

     Self <- create.
     :- end_class point.

   Because the slots are public, they have get and put methods
generated automatically. Because the class has a create method defined,
it is possible to create an instance with the command

     | ?- create(point, PointObj).

which creates a `point' object and binds the variable `PointObj' to it.

   Using the `point' class, we could create a class, `named_point',
which has an extra public slot, `name'.

     :- class named_point =
             [public name:atom] + point.

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y).

     :- end_class named_point.

   The only way to create a `named_point' object requires specifying
values for all three slots.

See Also
--------

`end_class/[0,1]'

   *note obj-scl::, *note obj-tcl::.


File: sicstus.info,  Node: obj-exp-class_ancestor,  Next: obj-exp-class_method,  Prev: obj-exp-class,  Up: obj-exp

10.13.6.5 `class_ancestor/2'
............................

Synopsis
--------

`class_ancestor(?CLASS, ?ANC)'

Arguments
---------

CLASS
     "atom"

ANC
     "atom"


Description
-----------

ANC is CLASS or an ancestor class of CLASS.

See Also
--------

`class_superclass/2'


File: sicstus.info,  Node: obj-exp-class_method,  Next: obj-exp-class_superclass,  Prev: obj-exp-class_ancestor,  Up: obj-exp

10.13.6.6 `class_method/1'  "declaration"
.........................................

Synopsis
--------

`:- class_method +NAME/+ARITY, ... .'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"


Description
-----------

Declares that a class's method for send message NAME/ARITY is an
ordinary method, not an instance method.

   Used when the class being defined inherits an instance method from a
superclass, to allow the class to define a non-instance method for the
message. A descendent class may still declare this to be an instance
method, so the same message may be an instance method for some classes
and an ordinary class method for others.

   Must occur within the scope of the class definition. Only applies to
send messages.

See Also
--------

`instance_method/1'


File: sicstus.info,  Node: obj-exp-class_superclass,  Next: obj-exp-class_of,  Prev: obj-exp-class_method,  Up: obj-exp

10.13.6.7 `class_superclass/2'
..............................

Synopsis
--------

`class_superclass(?CLASS, ?SUPER)'

Arguments
---------

CLASS
     "atom"

SUPER
     "atom"


Description
-----------

CLASS is an immediate subclass of SUPER.

See Also
--------

`class_ancestor/2'


File: sicstus.info,  Node: obj-exp-class_of,  Next: obj-exp-create,  Prev: obj-exp-class_superclass,  Up: obj-exp

10.13.6.8 `class_of/2'
......................

Synopsis
--------

`class_of(+OBJ, -CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"


Description
-----------

CLASS is the class of OBJ.

Exceptions
----------

`instantiation_error'
     OBJ is unbound.

`type_error'
     OBJ is not a valid object.

See Also
--------

`pointer_object/2'


File: sicstus.info,  Node: obj-exp-create,  Next: obj-exp-current_class,  Prev: obj-exp-class_of,  Up: obj-exp

10.13.6.9 `create/2'
....................

Synopsis
--------

`create(+DESCRIPTOR,-OBJ)'

Arguments
---------

DESCRIPTOR
     "term"

OBJ
     "object"


Description
-----------

OBJ is a newly created and initialized object. Descriptor is a term
describing the object to create. After memory is allocated and any slot
initializations are performed, a create message is sent to the object.

   The functor of DESCRIPTOR indicates the class to create. The
arguments of the create message are the arguments of DESCRIPTOR.

Exceptions
----------

`instantiation_error'
     DESCRIPTOR is unbound.

`domain_error'
     DESCRIPTOR is not a valid `create' descriptor.

`resource_error'
     unable to allocate enough memory for object.

Caveat
------

You must have a `create/N' method for every arity N you want to be able
to use in creating instances of a class.  This includes arity 0.  If no
such method exists, a domain error will be raised.

Examples
--------

Given the class definition

     :- class point =
                     [public x:integer=1,
                      public y:integer=2].

     Self <- create.
     Self <- create(X, Y) :-
                     Self << x(X),
                     Self << y(Y).
     :- end_class point.

the command

     | ?- create(point, Point1).

creates a `point' object, with the default slot values for `x' and `y',
and binds variable `Point1' to the new object. The command

     | ?- create(point(10,15), Point2).

creates a `point' object with values 10 and 15 for slots `x' and `y',
respectively, and binds variable `Point2' to the new object.

See Also
--------

`destroy/1'


File: sicstus.info,  Node: obj-exp-current_class,  Next: obj-exp-debug_message,  Prev: obj-exp-create,  Up: obj-exp

10.13.6.10 `current_class/1'
............................

Synopsis
--------

`current_class(*CLASS)'

Arguments
---------

CLASS
     "atom"


Description
-----------

`Class' is the name of a currently defined class.


File: sicstus.info,  Node: obj-exp-debug_message,  Next: obj-exp-define_method,  Prev: obj-exp-current_class,  Up: obj-exp

10.13.6.11 `debug_message/0'  "declaration"
...........................................

Synopsis
--------

`:- debug_message.'

Description
-----------

Prolog clauses following this directive will be compiled to send
messages "carefully."

   That is, a message sent to an object that does not understand the
message will raise an exception, which describes both the message and
the object receiving it. This also catches attempts to send an unbound
message, to send a message to an unbound object, and similar errors.

See Also
--------

`nodebug_message/0'


File: sicstus.info,  Node: obj-exp-define_method,  Next: obj-exp-descendant_of,  Prev: obj-exp-debug_message,  Up: obj-exp

10.13.6.12 `define_method/3'
............................

Synopsis
--------

`define_method(+OBJ, +MESSAGE, +BODY)'

Arguments
---------

OBJ
     "object"

MESSAGE
     "term"

BODY
     "callable"


Description
-----------

Installs BODY as the method for MESSAGE in the instance OBJ.  Following
the execution of this goal, sending MESSAGE to OBJ will execute BODY,
rather than the default method or a method previously defined with
`define_method/3'.

   MESSAGE must have been declared to be an instance method for the
class of OBJ.

Exceptions
----------

`instantiation_error'
     any argument is unbound.

`type_error'
     OBJ is not a compound term, or MESSAGE or BODY is not "callable".

`domain_error'
     MESSAGE does not specify an instance method for the class of OBJ,
     or BODY include a goal to fetch or store a non-existent slot.

See Also
--------

`instance_method/1', `undefine_method/3'


File: sicstus.info,  Node: obj-exp-descendant_of,  Next: obj-exp-destroy,  Prev: obj-exp-define_method,  Up: obj-exp

10.13.6.13 `descendant_of/2'
............................

Synopsis
--------

`descendant_of(+OBJ, ?CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"


Description
-----------

OBJ is an instance of CLASS or of a descendant of CLASS.

Exceptions
----------

`instantiation_error'
     OBJ is unbound.

`type_error'
     OBJECT is not a valid object.

See Also
--------

`class_ancestor/2', `class_of/2', `class_superclass/2'


File: sicstus.info,  Node: obj-exp-destroy,  Next: obj-exp-direct_message,  Prev: obj-exp-descendant_of,  Up: obj-exp

10.13.6.14 `destroy/1'
......................

Synopsis
--------

`destroy(+OBJ)'

Arguments
---------

OBJ
     "object"


Description
-----------

First, sends a `destroy' message to OBJ, if such a message is defined
for its class. A `destroy' message takes no argument.  Unlike
`create/2', it is possible to destroy instances of a class even if it
defines no `destroy' methods.  Finally, disposes of OBJ.

Exceptions
----------

`instantiation_error'
     OBJ is unbound.

`type_error'
     OBJECT is not a valid object.

See Also
--------

`create/2'


File: sicstus.info,  Node: obj-exp-direct_message,  Next: obj-exp-end_class,  Prev: obj-exp-destroy,  Up: obj-exp

10.13.6.15 `direct_message/4'
.............................

Synopsis
--------

`direct_message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

NAME/ARITY is an OP message directly understood (defined rather than
inherited) by instances of CLASS.  This predicate is used to test
whether a message is defined for a class.

   OP is one of `<-', `>>', or `<<', specifying the kind of message.

   This predicate violates the principle of information hiding by
telling whether the method for a message is defined within a class or
inherited. Hence its use in ordinary programs is discouraged.  It may
be useful, however, during debugging or in developing programming
support tools.

See Also
--------

`<-/2', `<</2', `>>/2', `message/4'


File: sicstus.info,  Node: obj-exp-end_class,  Next: obj-exp-fetch_slot,  Prev: obj-exp-direct_message,  Up: obj-exp

10.13.6.16 `end_class/[0,1]'  "declaration"
...........................................

Synopsis
--------

`:- end_class.'

   `:- end_class +CLASSNAME.'

Arguments
---------

CLASSNAME
     "atom"


Description
-----------

A class definition continues until the next `end_class/[0,1]'
directive, the next `class/1' directive, or the end of the file,
whichever comes first.

   It is not possible to nest one class definition within another.

   All clauses that look like method definitions (that is, which have
one of `<-/2', `<</2' or `>>/2' as the principal functors of their
heads) are considered to be method definitions for the class.

Caveat
------

The argument to `end_class/1', if specified, must match the class name
of the preceding `class/1' directive.

See Also
--------

`class/1'


File: sicstus.info,  Node: obj-exp-fetch_slot,  Next: obj-exp-inherit,  Prev: obj-exp-end_class,  Up: obj-exp

10.13.6.17 `fetch_slot/2'
.........................

Synopsis
--------

`fetch_slot(+SLOTNAME, -VALUE)'

Arguments
---------

SLOTNAME
     "atom"

VALUE
     "term"


Description
-----------

Fetches VALUE from the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent. It cannot
be used to directly access the slots of another object.

Exceptions
----------

`instantiation_error'
     SLOT is unbound.

`domain_error'
     SLOT is not the name of a slot of the current class.

`permission_error'
     SLOT is a private slot of a superclass.

See Also
--------

`>>/2', `store_slot/2'


File: sicstus.info,  Node: obj-exp-inherit,  Next: obj-exp-instance_method,  Prev: obj-exp-fetch_slot,  Up: obj-exp

10.13.6.18 `inherit/1'  "declaration"
.....................................

Synopsis
--------

`:- inherit +CLASSNAME +OP +NAME/+ARITY, ....'

Arguments
---------

CLASSNAME
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

CLASSNAME names the class from which the message should be inherited,
OP indicates which kind of message it is, and NAME and ARITY indicate
the name and arity of the message to be inherited. You may include
several inheritance specifications in one directive.

Caveat
------

Be careful of the precedences of the message operator and the `/'
operator. You may need to use parentheses.

Examples
--------

Suppose classes `toy' and `truck' are defined as follows:

     :-class toy.
     Self <- create.
     Self >> size(small).
     Self >> rolls(false).
     :- end_class toy.

     :- class truck.
     Self <- create.
     Self >> size(small).
     Self >> rolls(true).
     :- end_class truck.

   Then `toy_truck' inherits its size from `toy' and the fact that it
rolls from `truck':

     :- class toy_truck = toy + truck.
     :- inherit
             toy <- (create/O),
             toy <- (size/1),
             truck <- (rolls/1).
     :- end_class toy_truck.

   Note that this is just a toy example.

See Also
--------

`uninherit/1'


File: sicstus.info,  Node: obj-exp-instance_method,  Next: obj-exp-message,  Prev: obj-exp-inherit,  Up: obj-exp

10.13.6.19 `instance_method/1'  "declaration"
.............................................

Synopsis
--------

`:- instance_method +NAME/+ARITY.'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"


Description
-----------

The message NAME/ARITY is declared to support instance methods in a
class. This means that instances of this class, and its descendants,
may each define their own methods for this message.

   A method defined for this message by the class is considered the
default method for the message. An instance that does not define its
own method uses the default. Defining a new method overrides this
default method; there is no need to explicitly remove it.

   An instance method is installed in an instance of the class with the
`define_method/3' predicate. An instance method is removed from an
instance of the class, reverting to the default method, with the
`undefine_method/3' predicate.

   Must occur within the scope of the class definition. Only applies to
send messages.

See Also
--------

`class_method/1', `define_method/3', `undefine_method/3'


File: sicstus.info,  Node: obj-exp-message,  Next: obj-exp-nodebug_message,  Prev: obj-exp-instance_method,  Up: obj-exp

10.13.6.20 `message/4'
......................

Synopsis
--------

`message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

NAME/ARITY is an OP message understood by instances of CLASS.  This
predicate is used to test whether a message is either defined for or
inherited by a class.

   OP is one of `<-', `>>', or `<<', specifying the kind of message.

See Also
--------

`<-/2', `<</2', `>>/2', `direct_message/4'


File: sicstus.info,  Node: obj-exp-nodebug_message,  Next: obj-exp-pointer_object,  Prev: obj-exp-message,  Up: obj-exp

10.13.6.21 `nodebug_message/0'  "declaration"
.............................................

Synopsis
--------

`:- nodebug_message.'

Description
-----------

Prolog clauses following this directive are no longer compiled to send
messages "carefully."

See Also
--------

`debug_message/0'


File: sicstus.info,  Node: obj-exp-pointer_object,  Next: obj-exp-store_slot,  Prev: obj-exp-nodebug_message,  Up: obj-exp

10.13.6.22 `pointer_object/2'
.............................

Synopsis
--------

`pointer_object(+ADDR,-OBJ)'

   `pointer_object(-ADDR,+OBJ)'

Arguments
---------

ADDR
     "integer"

OBJ
     "object"


Description
-----------

ADDR is the address of object OBJ. This can be used to get the address
of an object or to get an object given its address.

   *Please note*: This is a low level operation, passing an invalid
address may crash the system.

Exceptions
----------

`instantiation_error'
     both OBJ and ADDR are unbound.

`type_error'
     ADDR is not an integer.


File: sicstus.info,  Node: obj-exp-store_slot,  Next: obj-exp-undefine_method,  Prev: obj-exp-pointer_object,  Up: obj-exp

10.13.6.23 `store_slot/2'
.........................

Synopsis
--------

`store_slot(+SLOTNAME, +NEWVALUE)'

Arguments
---------

SLOTNAME
     "atom"

NEWVALUE
     "term"


Description
-----------

Stores NEWVALUE in the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent. It cannot
be used to directly modify the slots of another object.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`type_error'
     NEWVALUE is not of the appropriate type for SLOTNAME.

`domain_error'
     SLOTNAME is not the name of a slot of the current class.

`permission_error'
     SLOTNAME is a private slot of a superclass.

See Also
--------

`<</2', `fetch_slot/2'


File: sicstus.info,  Node: obj-exp-undefine_method,  Next: obj-exp-uninherit,  Prev: obj-exp-store_slot,  Up: obj-exp

10.13.6.24 `undefine_method/3'
..............................

Synopsis
--------

`undefine_method(+OBJ, +NAME, +ARITY)'

Arguments
---------

OBJ
     "object"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

Removes OBJ's current instance method for the NAME/ARITY message. After
executing this goal, sending this message to OBJ executes the class's
default method for the message.

   NAME/ARITY must have been declared to be an instance method for the
class of OBJ.

   If OBJ has no current instance method for the NAME/ARITY message,
the predicate has no effect.

Exceptions
----------

`instantiation_error'
     any argument is unbound.

`type_error'
     OBJ is not a compound term, NAME is not an atom, or ARITY is not
     an integer.

`domain_error'
     MESSAGE does not specify an instance method for the class of OBJ.

See Also
--------

`define_method/3', `instance_method/1'


File: sicstus.info,  Node: obj-exp-uninherit,  Prev: obj-exp-undefine_method,  Up: obj-exp

10.13.6.25 `uninherit/1'  "declaration"
.......................................

Synopsis
--------

`:- uninherit +CLASS +OP +NAME/+ARITY, ... .'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

This prevents the class within whose scope this directive appears from
inheriting the NAME/ARITY method of type OP from ancestor CLASS.

   If CLASS is unbound, the specified message is uninherited from all
ancestors that define it.

Caveat
------

Note that if you define a message for your class, you don't need to
uninherit that message from its superclasses: it will automatically be
shadowed.

   Be careful of the precedences of the message operator and the `/'
operator. You may need to use parentheses.

Examples
--------

     :- uninherit someclass << (foo/1),
                  someclass >> (foo/1).

This prevents the get and put methods for the slot `foo' from being
inherited from any ancestors of class `someclass'. In effect, it makes
the `foo' slot a protected slot for this class.

See Also
--------

`inherit/1'


File: sicstus.info,  Node: obj-glo,  Next: obj-bas,  Prev: obj-exp,  Up: lib-objects

10.13.7 Glossary
----------------

"abstract class"
     A class that cannot have instances. Abstract classes are helpful
     in designing a class hierarchy, to contain the common parts of
     several concrete classes.

"ancestor"
     One of a class's superclasses, one of its superclasses's
     superclasses, etc. Sometimes, for convenience, ancestor includes
     the class itself, along with its proper ancestors.

"child"
     A synonym for subclass.

"class"
     A class is defined by a description of the information its
     instances contain and the messages they respond to.  Every object
     is an instance of one and only one class.

"concrete class"
     A class that can have instances. Most classes are concrete.

"create method"
     Specifies what actions should be taken when an instance of a class
     is created. A create method frequently provides initial slot
     values or specifies an action to be performed by the new object. A
     create message is sent to each new object by the `create/2'
     predicate. A create message is a kind of send message.

"descendant"
     One of a class's subclasses, one of its subclasses's subclasses,
     etc. Sometimes the word descendant includes the class itself,
     along with its proper descendants.

"destroy method"
     Specifies what actions should be taken when an instance of a class
     is destroyed. A destroy message is sent to an object by the
     `destroy/1' predicate. A destroy message is a kind of send message.

"direct slot access"
     Fetching or storing a slot value without sending a message to the
     object. This should be used with care!

     SICStus Objects allows direct access to a class's slots only
     within its method definitions, via the `fetch_slot/2' and
     `store_slot/2' predicates.

"get message"
     A message that inquires about some aspect of an object.  Typically
     used to fetch slot values. Get methods are automatically generated
     for public slots. Get messages are written with the `>>' operator.

"inheritance"
     The process by which a class's slots and methods are determined
     from an ancestor.

"initial value"
     The value a slot is initialized to when an object is created.
     Every slot has a default initial value, which depends upon its
     type. You may specify different initial values in a class
     definition.

"instance"
     Another word for object. The word instance draws attention to the
     class of which the object is an instance.

"instance method"
     A method that may be defined differently for each instance of a
     class. The class may have a default method for this message, which
     is overridden by installing an instance method for a particular
     object.

"message"
     A command to an object to perform an operation or to modify
     itself, or an inquiry into some aspect of the object.  In SICStus
     Objects, a message is either a get message, a put message or a
     send message. The syntax for sending a message to an object is

          OBJECT OPERATOR MESSAGE


     where OPERATOR is one of the following:

    `>>'
          get message

    `<<'
          put message

    `<-'
          send message

"method"
     A class's implementation of a particular message. You send
     messages to an object, but you define methods for a class.

"method clause"
     A Prolog clause used to define a method for a class. A method
     clause has one of `<-/2', `<</2' or `>>/2' as the principal
     functor of its head, and it can only appear within the scope of
     its class's definition. A method's definition may contain more
     than one message clause.

"mixin class"
     A class that is intended to be combined (mixed in) with other
     classes, via multiple inheritance, to define new subclasses.

"multiple inheritance"
     When a class names more than one superclass.  Typically, it
     inherits slots and methods from each.  In SICStus Objects, two
     different superclasses should not use the same slot name. And, if
     a message is defined by more than one superclass, the class
     definition must specify which method to inherit.

"object"
     A modifiable data item that holds information and responds to
     messages. Another word for instance.

"parent class"
     A synonym for superclass.

"private slot"
     A private slot is, by default, only accessible within methods of
     the class itself.  Not even the descendants of the class may
     access its private slots, except through the class's methods. Get
     and put methods are not automatically generated for a private
     slot, so it is only accessed via the methods you define. If the
     visibility of a slot is not specified, it is private, rather than
     public or protected.

"protected slot"
     A protected slot is, by default, only accessible within methods of
     the class itself and its descendants. Get and put methods are not
     automatically generated for a protected slot, so it is only
     accessed via the methods you define. If the visibility of a slot
     is not specified, it is private, rather than public or protected.


     SICStus Objects `protected' is similar to `protected' in C++.

"public slot"
     A public slot is accessible via its own get and put methods, which
     are generated for it automatically. If no visibility is specified,
     a slot is private, rather than public or protected.

"put message"
     A message that modifies some aspect of an object.  Typically used
     to store slot values. Put methods are automatically generated for
     public slots. Put messages are written with the `<<' operator.

"send message"
     The most common sort of message. Used for performing an operation
     on an object or for performing an action that depends upon an
     object. Send messages are written with the `<-' operator.

"send super"
     When a method for a class executes a shadowed superclass's method.
     This allows a class to put a "wrapper" around its superclass's
     method, making it unnecessary to duplicate the method just to make
     a small extension to it.

"shadow"
     When a class defines its own method for a message defined by one
     of its ancestors, the new method hides or "shadows" the ancestor's
     method. The new class's descendants will inherit its method for
     that message, rather than its ancestors. That is, a class always
     inherits the "closer" of two methods for a message.

"slot"
     A part of an instance that holds an individual datum.  Like a
     member of a C struct or a field of a Pascal record.

"subclass"
     A class that is a more specific case of a particular class.  This
     is the opposite of superclass. A class does not name its
     subclasses; they are inferred.

"superclass"
     A class that is a more general case of a particular class.  Each
     class lists its superclasses.

"term class"
     A class whose instances are represented as ordinary Prolog terms.
     The functor of these objects need not be the name of the class,
     and the arity need not be one.

"term slot"
     A slot that can hold any Prolog term.

"uninherit"
     Specify that a method from a superclass should not be inherited.
     This is similar to shadowing the superclass's method, but does not
     specify a replacement for it.

"visibility"
     A slot may be defined to be either `public', `protected', or
     `private'.  By default, if no visibility is specified, a slot is
     private.



File: sicstus.info,  Node: lib-odbc,  Next: lib-ordsets,  Prev: lib-objects,  Up: The Prolog Library

10.14 The ODBC Interface Library-`library(odbc)'
================================================

This library is an interface to an ODBC database driver. For an
introduction to ODBC, see
`http://msdn.microsoft.com/en-us/library/ms715408(VS.85).aspx'
("Introduction to ODBC"; Microsoft Web Page).  ODBC 3.x is supported.

* Menu:

* ODBC Overview:: Overview
* ODBC Examples:: Examples
* ODBC Datatypes:: Datatypes
* ODBC Exceptions:: Exceptions
* ODBC Predicates:: Predicates


File: sicstus.info,  Node: ODBC Overview,  Next: ODBC Examples,  Up: lib-odbc

10.14.1 Overview
----------------

ODBC (Open Database Connectivity) is a standard API for using a DBMS
(DataBase Management System). By using ODBC you can access data from a
multitude of DBMSs without having to know the details of each DBMS.

   `library(odbc)' is a layer on top of ODBC. It has predicates for
opening the database, starting and executing a query, and retrieving
the results of a query.  The ODBC client application, i.e. this
library, accesses all ODBC functionality via a service provided by the
operating system, the ODBC Driver Manager (DM).

   Some operating systems (e.g. Mac OS X and MS Windows) usually come
with an ODBC Driver Manager preinstalled. For other, UNIX and
UNIX-like, operating systems, unixODBC (`http://www.unixodbc.org') is
the most common but Mac OS X use iODBC (`http://www.iodbc.org').

   The ODBC Driver Manager does not, in itself, provide any database
functionality. Instead the DM loads a ODBC driver specific to the
particular Database Management System (DBMS) (when
`odbc_db_open/[3,4,5]' is called).

   How to install and configure an ODBC driver is beyond the scope of
this document. Please consult the documentation for the particular DBMS
you intend to use. Some popular DBMSs are MySQL and PostgreSQL which
both provide ODBC drivers for many platforms.


File: sicstus.info,  Node: ODBC Examples,  Next: ODBC Datatypes,  Prev: ODBC Overview,  Up: lib-odbc

10.14.2 Examples
----------------

A few examples will best illustrate how to use `library(odbc)'.

* Menu:

* ODBC Example 1:: Example 1
* ODBC Example 2:: Example 2
* ODBC Example 3:: Example 3
* ODBC Example 4:: Example 4


File: sicstus.info,  Node: ODBC Example 1,  Next: ODBC Example 2,  Up: ODBC Examples

10.14.2.1 Example 1
...................

The first example just verifies that ODBC is working and that some ODBC
drivers have been configured in the ODBC Driver Manager.

     :- use_module(library(odbc)).

     example1 :-
         odbc_env_open(EnvHandle),
         odbc_list_DSN(EnvHandle, DSNs),
         odbc_env_close(EnvHandle),
         format('The known DSNs are: ~q~n', [DSNs]).

   You begin by opening an environment. This is a handle which can be
used for various calls to the ODBC Driver Manager (DM).  You then ask
the DM about the data sources, i.e. databases, it knows about. If this
list is empty you need to install and configure the ODBC drivers
appropriate for the database management system that you intend to use.


File: sicstus.info,  Node: ODBC Example 2,  Next: ODBC Example 3,  Prev: ODBC Example 1,  Up: ODBC Examples

10.14.2.2 Example 2
...................

This example is a simple SQL query using a fixed SQL string.

     :- use_module(library(odbc)).

     example_select :-
         odbc_env_open(EnvHandle),
         odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
         odbc_query_open(ConnectionHandle, StatementHandle),
         odbc_query_execute_sql(StatementHandle,
                            'SELECT cookie,soft FROM bakery order by soft',
                            ResultSet),
         show_result(ResultSet),
         odbc_query_close(ResultSet),
         odbc_db_close(ConnectionHandle),
         odbc_env_close(EnvHandle).

     show_result(ResultSet) :-
         odbc_sql_fetch(ResultSet, Row),
         show_result1(Row, ResultSet).

     show_result1([], _ResultSet) :- !.
     show_result1(Row, ResultSet) :-
         format('~w~n', [Row]),
         flush_output,
         odbc_sql_fetch(ResultSet, Row1),
         show_result1(Row1, ResultSet).

   As always, you begin by opening an environment.  You then connect to
the database with `odbc_db_open/3'.  The first argument is the
identifier for the database in the DBMS.  In this scenario, connecting
to the database does not require a username and a password.  The output
from `odbc_db_open/3' is an opaque handle on the database.

   First, `odbc_query_open/2' is used to create an SQL query, which is
straightforward.  Then, `odbc_query_execute_sql/3' is used to execute
the SQL query. By executing an SQL query a _result set_ is created.
Each consecutive call of `odbc_sql_fetch/2' will retrieve one row from
the result set.


File: sicstus.info,  Node: ODBC Example 3,  Next: ODBC Example 4,  Prev: ODBC Example 2,  Up: ODBC Examples

10.14.2.3 Example 3
...................

This example shows the use of parameter binding. The positional markers
(?) in the SQL string are bound to the elements in the list in the
third argument of odbc_query_execute_sql/5. The fourth argument is a
list of datatypes corresponding to the parameters.

     :- use_module(library(odbc)).

     example2 :-
        odbc_env_open('SQL_OV_ODBC3', EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            ['SQL_VARCHAR', 'SQL_INTEGER'],
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).


File: sicstus.info,  Node: ODBC Example 4,  Prev: ODBC Example 3,  Up: ODBC Examples

10.14.2.4 Example 4
...................

This example is similar to the second, but this time we ask the
database what the datatypes of the columns of the table are with
odbc_list_data_types/3.

     :- use_module(library(odbc)).

     example3 :-
        odbc_env_open(EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_list_data_types(StatementHandle,
                             scratch(vehicle, wheels),
                             DataTypes),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            DataTypes,
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).


File: sicstus.info,  Node: ODBC Datatypes,  Next: ODBC Exceptions,  Prev: ODBC Examples,  Up: lib-odbc

10.14.3 Datatypes
-----------------

* Menu:

* ODBC Reading:: Reading from the database
* ODBC Writing:: Writing to the database


File: sicstus.info,  Node: ODBC Reading,  Next: ODBC Writing,  Up: ODBC Datatypes

10.14.3.1 Reading from the database
...................................

When reading data from the database the following datatypes are
supported, with conversion to the corresponding prolog datatypes.
`SQL_CHAR', `SQL_VARCHAR' etc.
     A list of character codes.

`SQL_BIT'
     The integer `0' for false, or `1' for true.

`SQL_INTEGER', `SQL_TINYINT', `SQL_SMALLINT', etc.
     An integer.

`SQL_REAL', `SQL_DOUBLE', `SQL_FLOAT'
     A floating point number.

`SQL_DATE'
     A term `date(Year, Month, DayOfMonth)', with one-based   integer
     arguments. E.g. `date(2012,10,22)' means October   22, 2012.

`SQL_TIME'
     A term `time(Hour, Minute, Second)' with one-based integer
     arguments. E.g. `time(22,11,5)' means eleven minutes and   five
     seconds past ten pm.

`SQL_TIMESTAMP'
     A term `timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)' where the arguments have the same meaning as for
     `SQL_TIME' and `SQL_TIMESTAMP' and FRACTION   means fractional
     nanoseconds past, as an integer.

the SQL null value
     The atom `null'.

`SQL_BINARY' and other binary types
`SQL_INTERVAL_HOUR' and other interval types
`SQL_UTCTIME' and `SQL_UTCDATETIME'
     Currently not supported.
   Note that atoms with names that start with an upper case letter,
like `SQL_CHAR' must be quoted in Prolog, e.g. `'SQL_CHAR''.


File: sicstus.info,  Node: ODBC Writing,  Prev: ODBC Reading,  Up: ODBC Datatypes

10.14.3.2 Writing to the database
.................................

When writing data to the database the following SQL datatypes are
supported.

`SQL_CHAR', `SQL_VARCHAR' etc.
     A list of character codes, or a list of atoms.

     For backwards compatibility only, an atom is also accepted, but
     note that the atoms `null' and `[]' have special meaning  (as SQL
     null value and empty code list, respectively) and more  atoms with
     special meaning may be introduced in the future. For
     compatibility with some ODBC drivers, the integer 0 and 1 are
     allowed, meaning "0" and "1".

`SQL_BIT'
     The integer `0' for false, or `1' for true.

`SQL_INTEGER', `SQL_TINYINT', `SQL_SMALLINT', etc.
     An integer.

`SQL_REAL', `SQL_DOUBLE', `SQL_FLOAT'
     A floating point number or a small integer.

`SQL_DATE'
     A term `date(Year, Month, DayOfMonth)', as above.

`SQL_TIME'
     A term `time(Hour, Minute, Second)', as above.

`SQL_TIMESTAMP'
     A term `timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)', as above.

the SQL null value
     The atom `null'.

`SQL_BINARY' and other binary types
`SQL_INTERVAL_HOUR' and other interval types
`SQL_UTCTIME' and `SQL_UTCDATETIME'
     Currently not supported.
   if a value is out of range for the corresponding SQL  type, e.g. a
too large integer for `SQL_SMALLINT', the  result is undefined.  Note
that atoms with names that start with an upper case letter,  like
`SQL_CHAR' must be quoted in Prolog, e.g. `'SQL_CHAR''.


File: sicstus.info,  Node: ODBC Exceptions,  Next: ODBC Predicates,  Prev: ODBC Datatypes,  Up: lib-odbc

10.14.4 Exceptions
------------------

When an error in the ODBC layer occurs, predicates in `library(odbc)'
throw `error/2' exceptions. Both arguments of the `error/2' exception
are the same and has the following form `odbc_error(DETAIL, GOAL)',
where `Goal' is some goal where the error occurred, and DETAIL gives
more information about the error. The DETAIL term can have the
following form:

`data_conversion'
     Thrown in case of a error when converting to or from a SICStus data
     type from or to an ODBC data type.

`unsupported_datatype'
     Thrown when an SQL data type is unsupported when converting to or
     from a SICStus data type from or to an ODBC data type.

`unknown_datatype'
     Thrown when an unknown SQL data type is found when converting to or
     from a SICStus data type from or to an ODBC data type.

`type_error'
     Thrown when the Prolog data is of a type incompatible with the SQL
     data type when converting from a SICStus data type to an ODBC data
     type.

`native_code'
     Thrown in case of a error in the native code of `library(odbc)'.

`invalid_handle(handle_type, INVALIDHANDLE, RETURNCODE)'
     Thrown when an invalid handle type is specified.

`invalid_handle('HandleType'-HANDLETYPE, 'Handle'-HANDLE)'
     Thrown when an invalid handle is specified.

`invalid_handle(result_set, RESULTSET)'
     Thrown when a Result Set handle is invalid.

`unknown_connection_option(OPTIONS)'
     Thrown when an unknown option was given when calling
     `odbc_db_open/[3,4,5]'.

`internal_error'
     Thrown when an internal error occurs in `library(odbc)'. Please
     report this to SICStus Support.

`diag(RETURNCODE, RECS)'
     Thrown when an error occurs in the ODBC layer, e.g. a SQL syntax
     error.  RECS is bound to the diagnostic records reported from ODBC.

`out_of_memory'
     Thrown when some operation runs out of memory.
   there may be other DETAILS and new DETAILS may be added in the
future.


File: sicstus.info,  Node: ODBC Predicates,  Prev: ODBC Exceptions,  Up: lib-odbc

10.14.5 Predicates
------------------

`odbc_env_open(-ENVHANDLE)'
     Opens an ODBC environment.  Throws an exception if the environment
     could not be opened.

`odbc_db_open(+DBNAME,+ENVHANDLE,-CONNECTIONHANDLE)'
     Opens a database with the name DBNAME. The database cannot require
     a username and a password.  CONNECTIONHANDLE is an opaque handle
     for accessing the database.

`odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE)'
     Opens a database with the name DBNAME.  OPTIONS should be a list
     of zero or more of:
    `username(+USERNAME)'
          The username for connecting to the database.  The default is
          `'''.

    `password(+PASSWORD)'
          The password for connection to the database.  The default is
          `'''.

    `login_timeout(+TIMEOUT)'
          The number of seconds to wait for a login request to complete.
          If 0 is used, the login attempt will wait indefinitely.  The
          default is driver-dependent.

    `connection_timeout(+TIMEOUT)'
          The number of seconds to wait for any request on the
          connection to complete.  If the Timeout value is 0 (the
          default), there is no timeout.

    `raw(+CONNECTIONOPTIONS)'
          CONNECTIONOPTIONS should be a list of atoms. They are passed,
          terminated by `;', as extra options when opening the database.
     CONNECTIONHANDLE is an opaque handle for accessing the database.

`odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE,-CONNECTIONSTRING)'
     Like `odbc_db_open/4' but also returns the completed connection
     string returned by the ODBC driver.

`odbc_query_open(+CONNECTIONHANDLE, -STATEMENTHANDLE)'
     Creates a new database query. CONNECTIONHANDLE is a handle
     previously allocated with `odbc_db_open/[3,4,5]'.

`odbc_list_DSN(+ENVHANDLE,-DSNS)'
     ENVHANDLE is an opaque database handle.  DSNS is unified with a
     list of all DSNs (Data Source Names).  The list elements are X-Y
     where X is the DSN and Y its description.

`odbc_list_data_types(+STATEMENTHANDLE, +TABLEDESC, -DATATYPES)'
     Makes a list of the datatypes in a table.  STATEMENTHANDLE is a
     handle previously allocated with `odbc_query_open/2'.  TABLEDESC
     is a description of the table and its columns of the form
     `tablename(columnname1, columnname2, ..., columnnameN)', or of the
     form `[tablename, columnname1, columnname2, ..., columnnameN]'
     (the latter form is useful if the table has more than 255 columns).
     DATATYPES is unified with a list of the corresponding datatypes,
     i.e.  on the form `[datatype1, datatype2, ... datatypeN]'.

`odbc_current_table(+ConnectionHandle, ?TableName)   "since release 4.2"'
     Enumerate the _proper_ tables in the database, i.e. tables with
     attribute `'TABLE_TYPE'("TABLE")'.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.

     Note that `odbc_current_table/2' may exit nondeterminately even if
     all arguments are instantiated when it is called.

`odbc_current_table(+ConnectionHandle, ?TableName, ?Attribute)   "since release 4.2"'
     Enumerate database tables and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,
    `arity(VALUE)'
          The number of columns in the table, as an integer.

          This attribute is always present.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond direcly to the (non-null) values
     returned from the ODBC function `SQLTables()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     `'TABLE_CAT'("foo")' would be returned for a table in the catalog
     "foo". Note that the names of the raw attributes are in all
     uppercase so you need to surround them with single quotes to
     prevent their name from being parsed as a variable. Some of the
     raw attributes are,
    `'TABLE_CAT'(VALUE)'
          Catalog name, as a code list. This attribute corresponds to
          the `TABLE_CAT' column, called `TABLE_QUALIFIER' in ODBC 2.0,
          as returned from the ODBC function `SQLTables()'.

    `'TABLE_TYPE'(VALUE)'
          Table type, as a code list. This attribute corresponds to the
          `TABLE_TYPE' column, as returned from the ODBC function
          `SQLTables()'. The standard table types are `"TABLE"',
          `"VIEW"', `"SYSTEM TABLE"', `"GLOBAL TEMPORARY"', `"LOCAL
          TEMPORARY"', `"ALIAS"', and `"SYNONYM"', but there can be
          data-source-specific types as well.

          This attribute is always present.

    `'REMARKS'(VALUE)'
          Table descriptive text, as a code list. This attribute
          corresponds to the `REMARKS' column, as returned from the
          ODBC function `SQLTables()'.

     see the ODBC documentation for `SQLTables()' for the full list of
     raw attributes and their meaning.

     Note that `odbc_current_table/3' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.

`odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName)   "since release 4.2"'
     Enumerate database table columns.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.

`odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName, ?Attribute)   "since release 4.2"'
     Enumerate database table columns and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.
     ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,
    `nullable(VALUE)'
          `true' if the column is definitely nullable, or `false' if
          the column is definitely not nullable. The value is derived
          from the raw attributes `NULLABLE' and `IS_NULLABLE', see the
          documentation for `SQLColumns()' for details.

          This attribute is not present if it can not be determined
          whether the column is nullable.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond direcly to the (non-null) values
     returned from the ODBC function `SQLColumns()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     `'TABLE_CAT'("foo")' would be returned for a column in a table in
     the catalog "foo". Note that the names of the raw attributes are
     in all uppercase so you need to surround them with single quotes
     to prevent their name from being parsed as a variable. Some of the
     raw attributes are,
    `'REMARKS'(VALUE)'
          Column descriptive text, as a code list. This attribute
          corresponds to the `REMARKS' column, as returned from the
          ODBC function `SQLColumns()'.

    `'ORDINAL_POSITION'(VALUE)'
          The ordinal position of the column in the table, starting at
          1. This attribute corresponds to the `ORDINAL_POSITION'
          column, as returned from the ODBC function `SQLColumns()'.

          This attribute is always present.


     See the ODBC documentation for `SQLColumns()' for the full list of
     raw attributes and their meaning.

     Note that `odbc_table_column/4' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.

`odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, +PARAMDATA, +PARAMDATATYPES, -RESULTSET)'
     Executes an SQL query.  STATEMENTHANDLE is a handle previously
     allocated with `odbc_query_open/2'.  SQLSTRING is the SQL
     statement to be executed. The statement string may contain
     parameter markers.  PARAMDATA is a list of data to be bound to the
     parameter markers.  PARAMDATATYPES is a list of data types
     corresponding to the PARAMDATA list.  RESULTSET is bound to an
     opaque data structure describing the result of the query.

`odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, -RESULTSET)'
     STATEMENTHANDLE is a handle previously allocated with
     `odbc_query_open/2'.  SQLSTRING is the SQL statement to be
     executed.  RESULTSET is bound to an opaque data structure
     describing the result of the query.

`odbc_sql_fetch(+RESULTSET, -ROW)'
     Fetch the next row from the result set.  RESULTSET is the result
     set from `odbc_query_execute_sql/[3,5]'.  ROW is unified with a
     non-empty list of data constituting a row in the result set, or
     with `[]' when there are no more rows.  The elements in the ROW
     are in the same order as in the corresponding query.

`odbc_query_close(+QUERY)'
     Closes the query represented by QUERY, which can be either a
     result set, e.g. as returned from `odbc_query_execute_sql/[3,5]',
     or it can be a statement handle, as returned from
     `odbc_query_open/2'.

`odbc_db_close(+CONNECTIONHANDLE)'
     Closes the connection to the database.

`odbc_env_close(+ENVHANDLE)'
     Frees the environment handle.


File: sicstus.info,  Node: lib-ordsets,  Next: lib-process,  Prev: lib-odbc,  Up: The Prolog Library

10.15 Ordered Set Operations--`library(ordsets)'
================================================

This library module provides operations on sets represented as ordered
lists with no duplicates.  Thus `{c,r,a,f,t}' would be `[a,c,f,r,t]'.
The ordering is defined by the `@<' family of term comparison
predicates, which is the ordering used by `sort/2' and `setof/3'.

   The benefit of the ordered representation is that the elementary set
operations can be done in time proportional to the sum of the argument
sizes rather than their product.  You should use the operations defined
here in preference to those in `library(sets)' unless there is a
compelling reason why you can't.  Some of the unordered set routines,
such as `member/2', `length/2' and `select/3' can be used unchanged on
ordered sets; feel free so to use them.

   There is no `ordset_to_list/2', as an ordered set is a list already.
Exported predicates:

`is_ordset(+LIST)'
     is true when LIST is a list of terms [T1,T2,...,TN] and the terms
     are strictly increasing: T1 @< T2 @< ... @< TN.  The output of
     `sort/2' always satisfies this test.  Anything which satisfies
     this test can be given to the predicates in this file, regardless
     of where you got it.

`list_to_ord_set(+LIST, -SET)'
     is true when SET is the ordered representation of the set
     represented by the unordered representation List.  The only reason
     for giving it a name at all is that you may not have realised that
     `sort/2' could be used this way.

`ord_add_element(+SET1, +ELEMENT, -SET2)'
     Equivalent to `ord_union(SET1, [ELEMENT], SET2)', but a bit faster.

`ord_del_element(+SET1, +ELEMENT, -SET2)'
     Equivalent to `ord_subtract(SET1, [ELEMENT], SET2)', but a bit
     faster.

`ord_disjoint(+SET1, +SET2)'
     is true when the two ordered sets have no element in common.

`ord_intersect(+SET1, +SET2)'
     is true when the two ordered sets have at least one element in
     common.

`ord_intersection(+SET1, +SET2, -INTERSECTION)'
     is true when INTERSECTION is the ordered representation of SET1
     and SET2, provided that SET1 and SET2 are ordered sets.

`ord_intersection(+SET1, +SET2, ?INTERSECTION, ?DIFFERENCE)'
     is true when INTERSECTION is the intersection of SET1 and SET2,
     and DIFFERENCE is SET2 \ SET1 (like in ord_union/4), provided that
     SET1 and SET2 are ordered sets.

`ord_intersection(+LISTOFSETS, -INTERSECTION)'
     is true when LISTOFSETS is a nonempty proper list of ordered sets
     and INTERSECTION is their intersection.

`ord_member(+ELT, +SET)'
     is true when ELT is a member of SET.  Suggested by Mark Johnson.

`ord_nonmember(+ITEM, +SET)'
     is true when the given ITEM is _not_ an element of the given SET.

`ord_seteq(+SET1, +SET2)'
     is true when the two arguments represent the same set.  Since they
     are assumed to be ordered representations, they must be identical.

`ord_setproduct(+SET1, +SET2, -PRODUCT)'
     If SET1 and SET2 are ordered sets, PRODUCT will be an ordered set
     of X1-X2 pairs.  Note that we cannot solve for SET1 and SET2,
     because there are infinitely many solutions when PRODUCT is empty,
     and may be a large number in other cases.  Could be defined as:

          ord_setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).

`ord_subset(+SET1, +SET2)'
     is true when every element of the ordered set SET1 appears in the
     ordered set SET2.

`ord_subtract(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE contains all and only the elements of SET1
     which are not also in SET2.

`ord_symdiff(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2.

`ord_disjoint_union(+SET1, +SET2, -UNION)'
     is true when SET1 and SET2 (given to be ordered sets) have no
     element in common, and UNION is their union.  The meaning is the
     same as
              ord_disjoint(Set1, Set2),
              ord_union(Set1, Set2, Union)
     but it is more efficient.

`ord_union(+SET1, +SET2, -UNION)'
     is true when UNION is the union of SET1 and SET2.  Note that when
     something occurs in both sets, we want to retain only one copy.

`ord_union(+OLDSET, +NEWSET, -UNION, -REALLYNEW)'
     is true when UNION is NEWSET U OLDSET and REALLYNEW is NEWSET \
     OLDSET.  This is useful when you have an iterative problem, and
     you're adding some possibly new elements (NEWSET) to a set
     (OLDSET), and as well as getting the updated set (UNION) you would
     like to know which if any of the "new" elements didn't already
     occur in the set (REALLYNEW).

`ord_union(+LISTOFSETS, -UNION)'
     is true when LISTOFSETS is given as a proper list of ordered sets
     and UNION is their union.  Letting K be the length of LISTOFSETS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).

`ordset_order(+XS, +YS, -R)'
     is true when R is `<', `=', or `>' according as XS is a subset of
     YS, equal to YS, or a superset of YS.  XS and YS are ordered sets.


File: sicstus.info,  Node: lib-process,  Next: lib-queues,  Prev: lib-ordsets,  Up: The Prolog Library

10.16 Process Utilities--`library(process)'
===========================================

This package contains utilities for process creation.

   A process is represented by a "process reference", a ground compound
term. Both SICStus and the operating system maintain a state for each
such process reference and they must therefore be released, either
explicitly with `process_release/1' or implicitly by
`process_wait/[2,3]'. Process references are created with
`process_create/[2,3]' if explicitly requested with the `process/1'
option. Process references are required in order to obtain the exit
status of a process after `process_create/[2,3]' has returned.

   Many of the predicates can accept a numeric operating system process
id ("PID") but since process ids are subject to re-use by the OS this
is less reliable and does not work if the process has already exited.

10.16.1 Examples
----------------

The following illustrates some common tasks.  The process library is
portable and works on all supported platforms, including UNIX, Linux
and Windows.  However, the examples are by necessity platform dependent.
Unless otherwise noted, the examples will work on UNIX and similar
systems only.

   (If you are looking for something like the old SICStus 3
`system:system/1' and `system:popen/3', *Note unsafe_system::.)

  1. Run the `date' command in the standard shell `sh'.  The output of
     the command is sent to the terminal:
          | ?- process_create(path(sh),
               ['-c', date]).

  2. Run the `date' command in the standard shell `sh'.  Wait for the
     command to terminate before returning to Prolog.  Fail if the
     process gets an error.  The output of the command is sent to the
     terminal:
          | ?- process_create(path(sh),
               ['-c', date], [wait(exit(0))]).
     Using `wait/1' option in this way is a convenient way to ensure
     that the command has finished before Prolog continues.

  3. Run the `date' command in the standard shell `sh'.  The output of
     the command is received by Prolog:
          | ?- process_create(path(sh),
               ['-c', date], [stdout(pipe(S))]),
               read_line(S,L), close(S), atom_codes(Date,L).
          ...,
          Date = 'Fri Jan 24 12:59:26 CET 2014' ?

  4. Pipe the output of the `date' command to a file:
          | ?- process_create(path(sh),
               ['-c', [date, '>', file('/tmp/foo.txt')]]).

  5. Count the number of words in an atom, using the `wc' command:
          | ?- process_create(path(wc), ['-w'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               write(In, 'a b c\n'), close(In),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 3
     It may be preferable to let the input or output go via a file.
     This avoids deadlock in case the stream buffers fill up.

  6. Count the number of unique words in a file, piping the output of
     the `uniq' command to the `wc' command:
          | ?- process_create(path(sh),
               ['-c', ['uniq ', file('/tmp/foo.txt'), ' | wc -w']],
               [stdout(pipe(Out))]),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 6
     Note that quoting is a problem (and potential security issue), so
     *never* pass untrusted data, like file names, to the shell using
     `-c' (*note Quoting and Security::).

  7. Run the `make' command with the `-n' (dry run) option, discarding
     output, fail if it does not succeed:
          | ?- process_create(path(make), ['-n'],
               [stdout(null), wait(Exit)]),
               Exit = exit(0).
     By using the `wait/1' option, `process_create/3' will not return
     until the subprocess has exited and its exit status is available.

  8. Run `ls' on a home directory in a subshell using the user's
     preferred shell:
          | ?- process_create('$SHELL', ['-c', [ls, ' ', file('~/') ]]).

  9. Run a command with output piped from a file and input provided by
     Prolog.  This is similar to `popen('cat > ./myscript.sh',write,S)'
     in SICStus 3.  This example also shows one way to create a shell
     script which is useful when more advanced shell interaction is
     needed.  (The created script outputs the most common line in its
     input.  It is used in the next example.)
          | ?- process_create(path(sh),
               ['-c',
               'cat > ./myscript.sh && chmod a+x ./myscript.sh'],
               [stdin(pipe(S))]),
               write(S, '#! /bin/sh\n'),
               write(S, 'sort | uniq -c | sort -nr | head -n 1\n'),
               close(S).
     Please read *note Quoting and Security:: for problems with this
     approach.

 10. Run a shell script with input piped from a file and output read by
     Prolog.  This is similar to `popen('./myscript.sh <
     ./somefile.txt',read,S)' in SICStus 3.
          | ?- open('somefile.txt',write,OF),
               write(OF,'hello\nworld\nhello\nhello\n'),close(OF),
               process_create(path(sh),
               ['-c', './myscript.sh < ./somefile.txt'],
               read_line(S, L), atom_codes(Line, L), close(S).
          ...,
          Line = '   3 hello' ?
     Please read *note Quoting and Security:: for problems with this
     approach.

 11. Run a goal in a SICStus subprocess (UNIX and Windows):
          | ?- process_create(application(sicstus),
               ['-f', '--noinfo', '--nologo',
               '--goal', 'read(X), call(X), halt.'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               format(In,'~q .~n', [(length([h,e,l,l,o], Len),
                                     format('~q .~n', [Len]))]),
               close(In), read(Out,Answer), close(Out).
          ...,
          Answer = 5

 12. Run `notepad.exe' on a file `C:/foo.txt' under Windows:
          | ?- process_create('$SYSTEMROOT/notepad.exe',
               [file('C:/foo.txt')]).

 13. Open a command shell in a separate window under Windows:
          | ?- process_create('$COMSPEC',[],[window(true)]).

10.16.1.1 Microsoft Windows Shell
.................................

On Windows, it is not possible to pass multiple parameters to a
subprocess.  When a subprocess is started, it receives exactly one
argument and a quoting convention must be used to encode the parameters
as the single argument actually passed to the process.

   Unfortunately, there is no such universal quoting convention, every
program can interpret its (single) argument in any way it sees fit.

   Most programs use a convention established by the Microsoft C
library.  This is the convention used by `process_create/[2,3]' and it
usually works well.

   However, the command processor on Windows (`cmd.exe') does not use
the common convention and, except for very simple cases, passing
arguments to `cmd.exe' will not work reliably.

   *Please note*: Passing arguments to `cmd.exe' suffers from the same
security vulnerabilities as those described in *note Quoting and
Security::, below.

   If you want to run commands using `cmd.exe', it is best to create a
batch (`.bat') file with your commands and then tell `cmd.exe' to run
the batch file.

   The following example illustrates how to create a Windows batch file
that pipes some output to a file (`COMSPEC' is an environment variable
containing the path to `cmd.exe'):
     | ?- BatFileName='test.bat',
          open(BatFileName, write, S),
          write(S, 'date /T > "result.txt"\n'), close(S),
          process_create('$COMSPEC', ['/Q', '/C', file(BatFileName)],
          [wait(exit(0))]),
          open('result.txt', read, R),
          read_line(R,L),close(R),atom_codes(Date,L).
     ...,
     Date = '2014-01-27 ',
     ... ?

   More recent versions of Windows come with a redesigned command line
processor, `PowerShell', which solves the problems associated with the
traditional `cmd.exe' command line processor.  In particular, it has a
very general way to encode command line arguments, using `base-64'
encoding.  Currently, there is no direct support for PowerShell in this
library, but the following example shows how to get the current week
day both using a plain text command and with a base-64-encoded command

     | ?- Command = '(get-date).DayOfWeek',
          process_create(path(powershell),
          ['-Command', Command],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?

     | ?- EncodedCommand =
            'KABnAGUAdAAtAGQAYQB0AGUAKQAuAEQAYQB5AE8AZgBXAGUAZQBrAA==',
          process_create(path(powershell),
          ['-encodedCommand', EncodedCommand],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?
where the ENCODEDCOMMAND value was created by encoding the string
`'(get-date).DayOfWeek'' using Base 64. See the PowerShell
documentation for details.

10.16.2 Quoting and Security
----------------------------

It easy to get undesired, and possibly harmful, effects if arbitrary
data is passed without proper quoting to a shell.  For instance,
accepting arbitrary file names and passing them as part of a command
line to a subshell can cause the shell to execute arbitrary, possibly
malicious, code.

   The following, vulnerable, predicates suffer from this problem.
They are similar to predicates that existed in SICStus 3, and their
fragility is one of the reasons process interaction was redesigned in
SICStus 4.
     % DO NOT USE. This code is vulnerable.
     % Similar to system:system/1 in SICStus 3.
     unsafe_system(Cmd) :-
        % pass Cmd to shell, wait for exit, fail on error.
        process_create(path(sh), ['-c', Cmd], [wait(exit(0))]).

     % DO NOT USE. This code is vulnerable.
     % Similar to system:popen/3 in SICStus 3.
     unsafe_popen(Cmd, Direction, Pipe) :-
        % pass Cmd to shell, do not wait for exit,
        % connect to stdin or stdout of subprocess.
        ( Direction == read ->
          process_create(path(sh), ['-c', Cmd], [stdout(pipe(Pipe))])
        ; Direction == write ->
          process_create(path(sh), ['-c', Cmd], [stdin(pipe(Pipe))])
        ).

   Now consider the task of passing the contents of some file FILE to a
command `mycommand'.  You may think the following is a good idea (it is
not!):

     % DO NOT USE. This code is vulnerable.
     unsafe_command(File, S) :-
        atom_concat('./mycommand < ', File, Cmd),
        unsafe_popen(Cmd, read, S).

   That works as expected if the the `File' argument is a plain file
with no characters that has special meaning to the shell, e.g.
     File = './somefile.txt',
     unsafe_command(File, S), read_line(S,L),close(S).

   However, assume that the file name was obtained from some untrusted
source and consider the following example:
     File = '$(say bohoo)',
     unsafe_command(File, S), read_line(S,L),close(S).
depending on the system this can have a quite scary effect, and
illustrates how shell meta characters in the constructed command line
can lead to potentially dangerous results.

   The safest way to interact with the shell is to create shell scripts
and pass arguments to the scripts as separate arguments to the shell.
E.g.
     % A safer version
     safer_command(File, S) :-
        % pass the file as the first argument to mycommand.
        process_create(path(sh),
                       ['-c', file('./mycommand'), file(File)],
                       [stdout(pipe(S))]).
Exported predicates:

`process_create(+FILE, +ARGS)'
`process_create(+FILE, +ARGS, :OPTIONS)'
     Start a new process running the program identified by FILE and the
     arguments specified in ARGS. The standard streams of the new
     process can be redirected to prolog streams. The exit status of
     the process can be obtained with `process_wait/[2,3]'.

     FILE, is expanded as if by `absolute_file_name/2' (with arguments
     `access(execute)' and `file_type(executable)') and is used to
     locate the file to execute.

     The predefined file search path `path/1' (*note ref-fdi::) is
     especially useful here since it makes it easy to look up the names
     of an executable in the directories mentioned by the `PATH'
     environment variable. To run the Windows command shell `cmd' you
     would simply specify `path('cmd.exe')' (or `path(cmd)'), to start
     the UNIX Bash shell you would specify `path(bash)'.

     ARGS is a list of argument specifications. Each argument
     specification is either a simple argument specification, see
     below, or a non-empty list of simple argument specifications. The
     expanded value of each element of ARGS is concatenated to produce
     a single argument to the new process. A "simple argument
     specification" can be one of:

    an atom
          The atom name is used as the expanded value. Some operating
          systems only support 7-bit ASCII characters here. Even when
          some larger subset of Unicode is used it may not work
          correctly with all programs.

    `file(FILE)'
          FILE, an atom, is treated as a file name and subject to an
          operating system specific transformation to ensure file name
          syntax and character set is appropriate for the new process.
          This is especially important under Windows where it ensures
          that the full Windows Unicode character set can be used.

          *Please note*: The FILE part of `file(FILE)' is not subject
          to syntactic rewriting, the argument specification `file/1'
          only adjusts for differences in file name syntax and character
          encoding between SICStus and the operating system. You must
          explicitly call `absolute_file_name/[2,3]' if you want to
          expand file search paths etc.

     OPTIONS is a list of options:

    `stdin(SPEC)'
    `stdout(SPEC)'
    `stderr(SPEC)'
          Each SPEC specifies how the corresponding standard stream of
          the new process should be created. SPEC can be one of:
         `std'
               The new process shares the (OS level) standard stream
               with the Prolog process. This is the default.  Note
               that, especially under Windows, the Prolog process may
               not have any OS level standard streams, or the OS
               streams may not be connected to a console or terminal.
               In such a case you need to use `pipe/1' spec, see below,
               and explicitly read (write) data from (to) the process.

         `null'
               The stream is redirected to a null stream, i.e. a stream
               that discards written data and that is always at end of
               file when read.

         `pipe(STREAM)'
               A new Prolog (text) stream is created and connected to
               the corresponding stream of the new process. It is
               currently not possible to request binary streams or to
               specify a character set different from the OS default.
               This stream must be closed using `close/[1,2]', it is not
               closed automatically when the new process exits.

    `wait(-EXITSTATUS)   "since release 4.3"'
          The call will not return until the sub-process has terminated.
          EXITSTATUS will be bound to the exit status of the process,
          as described for `process_wait/2'.

    `process(PROC)'
          PROC will be bound to a process reference that can be used in
          calls to `process_wait/[2,3]' etc.. This process reference
          must be released, either explicitly with `process_release/1'
          or implicitly by `process_wait/[2,3]'.  It is often easier to
          use the `wait/1' option if you just want to wait for the
          process to terminate.

    `detached(BOOL)'
          BOOL is either `true' or `false'. Specifies whether the new
          process should be "detached", i.e. whether it should be
          notified of terminal events such as `^C' interrupts. By
          default a new process is created detached if none of the
          standard streams are specified, explicitly or implicitly, as
          `std'.

    `cwd(CWD)'
          CWD is expanded as if by `absolute_file_name/2' and is used
          as the working directory for the new process.

          By default, the working directory is the same as the Prolog
          working directory.

    `window(BOOL)'
          BOOL is either `true' or `false' (the default). Specifies
          whether the process should open in its own window.

          Specifying `window(true)' may give unexpected results if the
          standard stream options `stdin/1', `stdout/1' and `stderr/1'
          are specified with anything but their default value `std'.

          Currently only implemented on Windows.

    `environment(ENV)   "since release 4.1"'
          ENV is a list of `VAR=VALUE' for extra environment variables
          to pass to the sub-process in addition to the default process
          environment.  VAR should be an atom.  VALUE should be an
          argument specification, as described above. The VALUE is
          typically an atom but, especially on the Windows platform, it
          may be necessary to wrap file names in `file/1' to ensure
          file paths are converted to the native format.  *Note System
          Properties and Environment Variables: (sicstus)System
          Properties and Environment Variables, for more information.


`process_wait(+PROCESS, -EXITSTATUS)'
`process_wait(+PROCESS, -EXITSTATUS, +OPTIONS)'
     Wait for a process to exit and obtain the exit status.

     PROCESS is either a process reference obtained from
     `process_create/3' or an OS process identifier. Specifying a
     process identifier is not reliable. The process identifier may
     have been re-used by the operating system. Under Windows, it is not
     possible to obtain the exit status using a process identifier if
     the process has already exited.

     EXITSTATUS is one of:
    `exit(EXITCODE)'
          The process has exited with exit code EXITCODE. By convention
          processes use exit code zero to signify success and a
          (positive) non-zero value to specify failure.

    `killed(SIGNALNUMBER)'
          UNIX only, the process was killed by signal `SignalNumber' (a
          positive integer).

    `timeout'
          The `timeout/1' option was specified and the process did not
          exit within the specified interval. In this case the process
          reference is not released, even if the `release/1' option is
          specified.
     OPTIONS is a list of options:
    `timeout(SECONDS)'
          Specify a maximum time, in seconds, to wait for the process to
          terminate. SECONDS should be an integer or floating point
          number or the atom `infinite' (the default) to specify
          infinite wait. If the specified timeout interval passes
          before the process exits, `process_wait/3' exits with
          EXITSTATUS set to `timeout' and the process reference is not
          released.

          Currently the UNIX implementation supports only timeout values
          0 (zero) and `infinite'.

    `release(BOOL)'
          BOOL is either `true' (the default) or `false'. Specifies
          whether the process reference should be released when
          `process_wait/3' exits successfully.

`process_id(-PID)'
     Obtain the process identifier of the current (i.e. Prolog) process.

`process_id(+PROCESS, -PID)'
     Obtain the process identifier of the process reference PROCESS.

`is_process(+THING)'
     Returns true if THING is a process reference that has not been
     released.

`process_release(+PROCESS)'
     Release a process reference PROCESS that has previously been
     obtained from `process_create/3'. This ensures that Prolog and the
     operating system can reclaim any resources associated with the
     process reference.

     Usually you would not call this. Either do not request the process
     reference when calling `process_create/3' or let
     `process_wait/[2,3]' reclaim the process reference when the
     process terminates.

`process_kill(+PROCESS)'
`process_kill(+PROCESS, +SIGNALSPEC)'
     Send a signal to the process designated by PROCESS. The signal can
     either be a non-negative integer or a signal name as an (all
     uppercase) atom.

     The following signal names are accepted under UNIX if the platform
     defines them: `SIGABRT', `SIGALRM', `SIGBUS', `SIGCHLD',
     `SIGCONT', `SIGFPE', `SIGHUP', `SIGILL', `SIGINT', `SIGKILL' (the
     default), `SIGPIPE', `SIGPOLL', `SIGPROF', `SIGQUIT', `SIGSEGV',
     `SIGSTOP', `SIGSYS', `SIGTERM', `SIGTRAP', `SIGTSTP', `SIGTTIN',
     `SIGTTOU', `SIGURG', `SIGUSR1', `SIGUSR2', `SIGVTALRM', `SIGXCPU'
     and `SIGXFSZ'. However, many of these do not make sense to send as
     signals.

     Under Windows, which does not have the signal concept, the signal
     name `SIGKILL' (the default) is treated specially and terminates
     the process with `TerminateProcess(Process, -1)'.  *Please note*:
     Using `process_kill/[2,3]' on Windows is not recommended. Also, on
     Windows, the call may throw an error if the process has already
     exited.



File: sicstus.info,  Node: lib-queues,  Next: lib-random,  Prev: lib-process,  Up: The Prolog Library

10.17 Queue Operations --`library(queues)'
==========================================

This module provides an implementation of queues, where you can
   * create an empty queue

   * add an element at either end of a queue

   * add a list of elements at either end of a queue

   * remove an element from the front of a queue

   * remove a list of elements from the front of a queue

   * determine the length of a queue

   * enumerate the elements of a queue

   * recognise a queue

   * print a queue nicely
   The representation was invented by Mark Johnson of the Center for
the Study of Language and Information.  All operations are fast.

   Exported predicates:

`empty_queue(?QUEUE)'
     is true when QUEUE represents an empty queue.  It can be used to
     test whether an existing queue is empty or to make a new empty
     queue.

`singleton_queue(?X, ?QUEUE)'
     is true when QUEUE is a queue with just one element X.

`portray_queue(+QUEUE)'
     writes a queue out in a pretty form, as QUEUE[ELEMENTS].  This form
     cannot be read back in, it is just supposed to be readable.  While
     it is meant to be called only when `is_queue(QUEUE)' has been
     established, as by `user:portray(Q) :- is_queue(Q), !,
     portray_queue(Q)'.  it is also meant to work however it is called.

`is_queue(+QUEUE)'
     is true when QUEUE is a queue.  The elements of QUEUE do not have
     to be instantiated, and the BACK of the QUEUE may or may not be.
     It can only be used to recognise queues, not to generate them.  To
     generate queues, use `queue_length(QUEUE, _)'.

`queue_head(+QUEUE, -HEAD)'
     is true when HEAD is the first element of the given QUEUE.  It does
     not remove HEAD from QUEUE; HEAD is still there afterwards.  It can
     only be used to find HEAD, it cannot be used to make a QUEUE.

`queue_tail(?QUEUE, ?TAIL)'
     is true when QUEUE and TAIL are both queues and TAIL contains all
     the elements of QUEUE except the first.  Note that QUEUE and TAIL
     share structure, so that you can add elements at the back of only
     one of them.  It can solve for either argument given the other.

`queue_cons(?HEAD, ?TAIL, ?QUEUE)'
     is true when HEAD is the head of QUEUE and TAIL is the tail of
     QUEUE, that is, when TAIL and QUEUE are both queues, and the
     elements of the QUEUE are HEAD followed by the elements of TAIL in
     order.  It can be used in either direction, so
              queue_cons(+Head, +Q0, -Q)      adds Head to Q0 giving Q
              queue_cons(-Head, -Q, +Q0)      removes Head from Q0 giving Q

`queue_last(?LAST, ?QUEUE)'
     is true when LAST is the last element currently in QUEUE.  It does
     not remove LAST from QUEUE; it is still there.  This can be used to
     generate a non-empty QUEUE.  The cost is O(|QUEUE|).

`queue_last(+FORE, +LAST, -QUEUE)'
     is true when FORE and QUEUE are both lists and the elements of
     QUEUE are the elements of FORE in order followed by LAST.  This is
     the operation which adds an element at the end of FORE giving
     QUEUE;  it is not reversible, unlike `queue_cons/3', and it
     side-effects FORE, again unlike `queue_cons/3'.

`append_queue(?LIST, ?QUEUE0, ?QUEUE)'
     is true when QUEUE is obtained by appending the elements of LIST
     in order at the front of QUEUE0, e.g.  `append_queue([a,b,c],
     Queue[d,e], Queue[a,b,c,d,e])'.  Use
              append_queue([+X1,...,+Xn], +Q0, -Q) to add X1,...,Xn to Q0 giving Q
              append_queue([-X1,...,-Xn], -Q, +Q0) to take X1...Xn from Q0 giving Q
     The cost is O(N) and the operation is pure.

`queue_append(+QUEUE0, +LIST, -QUEUE)'
     is true when QUEUE is obtained by appending the elements of LIST
     in order at the rear end of QUEUE0, e.g.
     `append_queue(Queue[a,b,c], [d,e], Queue[a,b,c,d,e])'.  This is
     like `queue_last/3'; it side-effects QUEUE0.

`list_queue(?LIST, ?QUEUE)'
     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  `list_queue/2' and `queue_list/2'
     are the same except for argument order.

`queue_list(?QUEUE, ?LIST)'
     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  `queue_list/2' and `list_queue/2'
     are the same except for argument order.

`queue_length(?QUEUE, ?LENGTH)'
     is true when QUEUE is a queue having LENGTH elements.  It may be
     used to determine the LENGTH of a QUEUE or to make a QUEUE of
     given LENGTH.

`queue_member(?ELEMENT, +QUEUE)'
     is true when ELEMENT is an element of QUEUE.  It could be made to
     generate queues, but that would be rather inefficient.  It bears
     the name `queue_member/2' because it is prepared to enumerate
     ELEMENTS.

`queue_memberchk(+ELEMENT, +QUEUE)'
     is true when the given ELEMENT is an element of QUEUE.  Once it
     finds a member of QUEUE which unifies with ELEMENT, it commits to
     it.  Use it to check a ground ELEMENT.

`map_queue(:PRED, +QUEUE[X1,...,XN])'
     succeeds when PRED(XI) succeeds for each element XI of the QUEUE.

`map_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI,YI) succeeds for each corresponding pair of
     elements XI, YI of the two queues.

`map_queue_list(:PRED, ?QUEUE[X1,...,XN], ?[Y1,...,YN])'
     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the QUEUE and the LIST.  It may be used to
     generate either of the sequences from the other.

`map_list_queue(:PRED, ?[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the LIST and the QUEUE.  It may be used to
     generate either of the sequences from the other.

`some_queue(:PRED, +QUEUE[X1,...,XN])'
     succeeds when PRED(XI) succeeds for some XI in the QUEUE.  It will
     try all ways of proving PRED(XI) for each XI, and will try each XI
     in the QUEUE.  `somechk_queue/2' is to `some_queue/2' as
     `memberchk/2' is to `member/2'; you are more likely to want
     `somechk_queue/2'.  This acts on backtracking like `member/2';
     QUEUE should be proper.

`some_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.

`somechk_queue(:PRED, +QUEUE[X1,...,XN])'
     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like `memberchk/2').

`somechk_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').


File: sicstus.info,  Node: lib-random,  Next: lib-rem,  Prev: lib-queues,  Up: The Prolog Library

10.18 Random Number Generator--`library(random)'
================================================

This library module provides a random number generator using algorithm
AS 183 from the Journal of Applied Statistics as the basic algorithm.

   The state of the random number generator corresponds to a term
`random(X,Y,Z,B)' where X is an integer in the range [1,30268], Y is an
integer in the range [1,30306], Z is an integer in the range [1,30322],
and B is a nonzero integer.

   Exported predicates:

`getrand(-RANDOMSTATE)'
     returns the random number generator's current state

`setrand(+RANDOMSTATE)'
     sets the random number generator's state to RANDOMSTATE.
     RANDOMSTATE can either be a random state previously obtained with
     `getrand/1', or an arbitrary integer. The latter is useful when
     you want to initialize the random state to a fresh value.  If
     RANDOMSTATE is not an integer or a valid random state, it raises
     an error.

`maybe'
     succeeds determinately with probability 1/2, fails with
     probability 1/2.  We use a separate "random bit" generator for
     this test to avoid doing much arithmetic.

`maybe(+PROBABILITY)'
     succeeds determinately with probability Probability, fails with
     probability 1-PROBABILITY.  Arguments =< 0 always fail, >= 1
     always succeed.

`maybe(+P, +N)'
     succeeds determinately with probability P/N, where 0 =< P =< N and
     P and N are integers.  If this condition is not met, it fails.  It
     is equivalent to `random(0, N, X), X < P', but is somewhat faster.

`random(-UNIFORM)'
     unifies UNIFORM with a new random number in [0.0,1.0)

`random(+L, +U, -R)'
     unifies R with a random integer in [L,U) when L and U are integers
     (note that U will _never_ be generated), or to a random floating
     number in [L,U) otherwise.

`random_member(-ELEM, +LIST)'
     unifies ELEM with a random element of LIST, which must be proper.
     Takes O(N) time (average and best case).

`random_select(?ELEM, ?LIST, ?REST)'
     unifies ELEM with a random element of LIST and REST with all the
     other elements of LIST (in order).  Either LIST or REST should be
     proper, and LIST should/will have one more element than REST.
     Takes O(N) time (average and best case).

`random_subseq(+LIST, -SBSQ, -CMPL)'
     unifies SBSQ with a random sub-sequence of LIST, and CMPL with its
     complement.  After this, `subseq(List, Sbsq, Cmpl)' will be true.
     Each of the 2**|LIST| solutions is equally likely.  Like its
     name-sake `subseq/3', if you supply SBSQ and CMPL it will
     interleave them to find LIST.  Takes O(N) time.  LIST should be
     proper.

`random_permutation(?LIST, ?PERM)'
     unifies PERM with a random permutation of LIST.  Either LIST or
     PERM should be proper, and they should/will have the same length.
     Each of the N! permutations is equally likely, where `length(List,
     N)'.  This takes O(N LG N) time and is bidirectional.

`random_perm2(A,B, X,Y)'
     unifies X,Y = A,B or X,Y = B,A, making the choice at random, each
     choice being equally likely.  It is equivalent to
     `random_permutation([A,B], [X,Y])'.

`random_numlist(+P, +L, +U, -LIST)'
     where P is a probability (0..1) and L=<U are integers unifies LIST
     with a random subsequence of the integers L..U, each integer being
     included with probability P.


File: sicstus.info,  Node: lib-rem,  Next: lib-samsort,  Prev: lib-random,  Up: The Prolog Library

10.19 Rem's Algorithm--`library(rem)'
=====================================

This library module maintains equivalence classes using Rem's algorithm.
Exported predicates:

`rem_create(+SIZE, -REM)'
     creates an equivalence representation function REM which maps each
     of the nodes 1..SIZE to itself.

`rem_head(?NODE, +REM, -HEAD)'
     is true when HEAD is the representative of the equivalence class
     that NODE belongs to in the given REM.

`rem_equivalent(?NODE1, ?NODE2, +REM)'
     is true when NODE1 and NODE2 belong to the same equivalence class
     in the given REM.

`rem_add_link(?NODE1, ?NODE2, +OLDREM, -NEWREM)'
     is true when adding the equivalence NODE1===NODE2 to the partition
     represented by OLDREM yields a partition which is represented by
     NEWREM.  If NODE1 or NODE2 is uninstantiated, it will backtrack
     over all the nodes.  It's not clear how useful this is.


File: sicstus.info,  Node: lib-samsort,  Next: lib-sets,  Prev: lib-rem,  Up: The Prolog Library

10.20 Generic Sorting--`library(samsort)'
=========================================

This library module provides generic sorting.  Exported predicates:

`samsort(+RAWLIST, -SORTED)'
     is given a proper list RAWLIST and unifies SORTED with a list
     having exactly the same elements as RAWLIST but in ascending order
     according to the standard order on terms.

`merge(+LIST1, +LIST2, -MERGED)'
     is true when MERGED is the stable merge of the two given lists.
     If the two lists are not ordered, the merge doesn't mean a great
     deal.  Merging is perfectly well defined when the inputs contain
     duplicates, and all copies of an element are preserved in the
     output, e.g. merge("122357", "34568", "12233455678").

`samsort(:ORDER, +RAWLIST, -SORTEDLIST)'
     is given a proper list RAWLIST and a binary predicate ORDER (note
     that it may be an N-ARY predicate with the first N-2 arguments
     already filled in) and unifies SORTEDLIST with a sorted version of
     RAWLIST.  This is only supposed to work when Orderis transitive.

`merge(:ORDER, +LIST1, +LIST2, -MERGED)'
     is like `merge/3' except that it takes an ORDER predicate as its
     first arguments, like all the generalised ordering routines.

`samkeysort(+RAWLIST, -SORTED)'
     is given a proper list RAWLIST of KEY-VALUE pairs, and unifies
     SORTED with a list having exactly the same elements as RAWLIST but
     in ascending order according to the standard order on the keys.
     `samkeysort/2' is stable in the sense that the relative position of
     elements with the same key is maintained.

`keymerge(+LIST1, +LIST2, -MERGED)'
     is like `merge/3' except that it compares only the keys of its
     input lists.  Note that it will not work properly when MERGED is
     already instantiated.


File: sicstus.info,  Node: lib-sets,  Next: lib-sockets,  Prev: lib-samsort,  Up: The Prolog Library

10.21 Unordered Set Operations--`library(sets)'
===============================================

This library module provides operations on sets represented as
unordered lists with no repeated elements.  The ordered representation
used in `library(ordsets)' is much more efficient, but these routines
were designed before sort/2 entered the language.  Exported predicates:

`add_element(+ELEMENT, +SET1, -SET2)'
     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 U {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.

`del_element(+ELEMENT, +SET1, -SET2)'
     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 \ {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.  If SET1 does not contain ELEMENT, SET2
     will be identical to SET1 (the old version made a new copy of
     SET1).  If SET1 is not an unordered set, but contains more than
     one copy of ELEMENT, only the first will be removed.  If you want
     to delete all copies of a given element, use `lists:delete/3'.
     For a version which fails if ELEMENT is not in SET1, use
     `selectchk/3'.

`disjoint(+SET1, +SET2)'
     is true when the two given sets have no elements in common.  It is
     the opposite of `intersect/2'.  If either of the arguments is
     improper, `disjoint/2' will fail.

`is_set(+LIST)'
     is true when LIST is a proper list that contains no repeated
     elements.

`pairfrom(?SET, ?ELEMENT1, ?ELEMENT2, ?RESIDUE)'
     is true when SET is a list, ELEMENT1 occurs in list, ELEMENT2
     occurs in list after ELEMENT1, and RESIDUE is everything in SET
     bar the two ELEMENTS.  The point of this thing is to select pairs
     of elements from a set without selecting the same pair twice in
     different orders.

`intersect(+SET1, +SET2)'
     is true when the two sets have a member in common.  It assumes
     that both sets are known, and that you don't care which element it
     is that they share.

`subset(+SET1, +SET2)'
     is true when each member of SET1 occurs in SET2.  It can only be
     used to test two given sets; it cannot be used to generate subsets.
     There is no predicate for generating subsets as such, but the
     predicates `subseq/3', `subseq0/2', `subseq1/2' in
     `library(lists)' may do what you want (they preserve the order of
     elements within a list).  Could be defined as:

          subset(Set1, Set2) :-
          	(   foreach(X,Set1),
          	    param(Set2)
          	do  memberchk(X,Set2)
          	).

`set_order(+XS, +YS, -R)'
     is true when R is `<', `=', or `>' according as XS is a subset of
     YS, equivalent to YS, or a superset of YS.

`seteq(+SET1, +SET2)'
     is true when each Set is a subset of the other.

`list_to_set(+LIST, -SET)'
     is true when LIST and SET are lists, and SET has the same elements
     as LIST in the same order, except that it contains no duplicates.
     The two are thus equal considered as sets.

`power_set(+SET, -POWERSET)'
     is true when SET is a list and POWERSET is a list of lists which
     represents the power set of the set that Set represents.

`intersection(+SET1, +SET2, -INTERSECTION)'
     is true when all three arguments are lists representing sets, and
     INTERSECTION contains every element of SET1 which is also an
     element of SET2, the order of elements in INTERSECTION being the
     same as in SET1.  That is, INTERSECTION represents the
     intersection of the sets represented by SET1 and SET2.  Could be
     defined as:

          intersection(Set1, Set2, Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = [X|S] ; S0 = S)
          	).

`intersection(+LISTOFSETS, -INTERSECTION)'
     is true when INTERSECTION is the intersection of all the sets in
     LISTOFSETS.  The order of elements in INTERSECTION is taken from
     the first set in LISTOFSETS.  This has been turned inside out to
     minimise the storage turnover.  Could be defined as:

          intersection([Set1|Sets], Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Sets)
          	do  (   (   foreach(Set,Sets),
          		    param(X)
          		do  memberchk(X, Set)
          		) -> S0 = [X|S]
          	    ;   S0 = S
          	    )
          	).

`subtract(+SET1, +SET2, -DIFFERENCE)'
     is like `intersect/3', but this time it is the elements of SET1
     which _are_ in SET2 that are deleted.  Note that duplicated
     ELEMENTS of SET1 which are not in SET2 are retained in DIFFERENCE.
     Could be defined as:

          subtract(Set1, Set2, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Difference,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).

`symdiff(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2, that is, if each element of DIFFERENCE occurs in one of SET1
     and SET2 but not both.  The construction method is such that the
     answer will have no duplicates even if the SETS do.

`setproduct(+SET1, +SET2, -CARTESIANPRODUCT)'
     is true when SET1 is a set (list) and SET2 is a set (list) and
     CARTESIANPRODUCT is a set of ELT1-ELT2 pairs, with a pair for for
     each element ELT1 of SET1 and ELT2 of SET2.  Could be defined as:

          setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).

`disjoint_union(+SET1, +SET2, -UNION)'
     is true when `disjoint(Set1, Set2)' and `union(Set1, Set2, Union)',
     that is, SET1 and SET2 have no element in command and UNION is
     their union.  Could be defined as:

          disjoint_union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,[X|S],S,Set2),
          	    param(Set2)
          	do  nonmember(X, Set2)
          	).

`union(+SET1, +SET2, -UNION)'
     is true when `subtract(Set1,Set2,Diff)' and
     `append(Diff,Set2,Union)', that is, when UNION is the elements of
     SET1 that do not occur in SET2, followed by all the elements of
     SET2.  Could be defined as:

          union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).

`union(+SET1, +SET2, -UNION, -DIFFERENCE)'
     is true when `union(Set1, Set2, Union)' and `subtract(Set1, Set2,
     Difference)'.  Could be defined as:

          union(Set1, Set2, Union, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    fromto(Difference,T0,T,[]),
          	    param(Set2)
          	do  (   member(X, Set2) -> S0 = S, T0 = T
          	    ;   S0 = [X|S], T0 = [X|T]
          	    )
          	).

`union(+LISTOFSETS, -UNION)'
     is true when UNION is the union of all the sets in LISTOFSETS.  It
     has been arranged with storage turnover in mind.  Could be defined
     as:

          union(Sets, Union) :-
          	(   foreach(Set,Sets),
          	    param(Answer)
          	do  (   foreach(X,Set),
          		param(Answer)
          	    do  memberchk(X, Answer)
          	    )
          	),
          	append(Answer, [], Answer),	% cauterise it
          	!,
          	Union = Answer.

