This is info/sicstus.info, produced by makeinfo version 4.13 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 8 May 2014.


File: sicstus.info,  Node: Single Threaded Example,  Next: Multi Threaded Example,  Up: Calling Prolog from Java

10.43.3.1 Single Threaded Example
.................................

The following is a Java version of the `train' example.  *Note Train
Example:: for information about how the `train.sav' file is created.

   This code demonstrates the use of Jasper in single threaded mode. In
this mode only one thread can access the SICStus runtime via a
`SICStus' object.

                                                       _// Simple.java_
     import se.sics.jasper.SICStus;
     import se.sics.jasper.Query;
     import java.util.HashMap;

     public class Simple
     {
         public static void main(String argv[]) {

             SICStus sp;
             Query query;
             HashMap WayMap = new HashMap();

             try {
                 sp = new SICStus(argv,null);

     	    sp.restore("train.sav");

                 query = sp.openPrologQuery("connected('Örebro', 'Stockholm',
                                            Way, Way).",
                                      WayMap);

                 try {
                     while (query.nextSolution()) {
                         System.out.println(WayMap);
                     }
                 } finally {
                     query.close();
                 }
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }
     }

   It is assumed that the reader has read the section on *note Getting
Started::, which describes how to get the basics up and running.

   This is how the example works:

  1. Before any predicates can be called, the SICStus runtime system
     must be initialized. This is done by instantiating the `SICStus'
     class. Each SICStus object correspond to one independent copy of
     the SICStus runtime system (a rather heavy-weight entity).

     In this example, we have specified `null' as the second argument
     to `SICStus'. This instructs SICStus to search for `sprt.sav'
     using its own internal methods.

  2. Queries are made through method `query'. The arguments to this
     method are a string specifying a Prolog goal, and a `Map', which
     will contain a mapping of variable names to bindings. This method
     is for finding a single solution.  Note that the string is read by
     the Prolog reader, so it must conform to the syntax rules for
     Prolog, including the terminating period.  There are two more
     methods for making queries: `queryCutFail', for side-effects only,
     and `openQuery' to produce several solutions through backtracking.

  3. The next step is to load the Prolog code. This is done by the
     method `restore'. Corresponds to `SP_restore()' in the
     C-interface. *Note Loading Prolog Code::. Note that this method
     must be called before any other SICStus method is called. See the
     HTML Jasper documentation for details.

  4. The `openQuery' method returns a reference to a query, an object
     implementing the `Query' interface. To obtain solutions, the
     method `nextSolution' is called with no arguments. `nextSolution'
     returns `true' as long as there are more solutions, and the
     example above will print the value of the Map `WayMap' until there
     are no more solutions. Note that the query must be closed, even if
     `nextSolution' has indicated that there are no more solutions.



File: sicstus.info,  Node: Multi Threaded Example,  Next: Another Multi Threaded Example (Prolog Top-Level),  Prev: Single Threaded Example,  Up: Calling Prolog from Java

10.43.3.2 Multi Threaded Example
................................

Following is a Java version of the `train' example.

   This is a multi threaded version of the `train' example.  In this
mode several threads can access the SICStus runtime via a `Prolog
interface'. The static method `Jasper.newProlog()' returns an object
that implements a `Prolog interface'. A thread can make queries by
calling the query-methods of the Prolog object.  The calls will be sent
to a separate server thread that does the actual call to SICStus
runtime.

                                                  _// MultiSimple.java_
     import se.sics.jasper.Jasper;
     import se.sics.jasper.Query;
     import se.sics.jasper.Prolog;
     import java.util.HashMap;

     public class MultiSimple
     {
         class Client extends Thread
         {
             Prolog jp;
             String qs;

             Client(Prolog p,String queryString)
             {
                 jp = p;
                 qs = queryString;
             }
             public void run()
             {
                 HashMap WayMap = new HashMap();
                 try {
                     synchronized(jp) {
                         Query query = jp.openPrologQuery(qs, WayMap);
                         try {
                             while (query.nextSolution()) {
                                 System.out.println(WayMap);
                             }
                         } finally {
                             query.close();
                         }
                     }
                 } catch ( Exception e ) {
                     e.printStackTrace();
                 }
             }
         }
         {
             try {
                 Prolog jp = Jasper.newProlog(argv,null,"train.sav");

                 Client c1 =
                     new Client(jp,"connected('Örebro', 'Hallsberg',
                                Way1, Way1).");
                 c1.start();
                 // The prolog variable names are different from above
                 // so we can tell which query gives what solution.
                 Client c2 =
                     new Client(jp,"connected('Stockholm', 'Hallsberg',
                                Way2, Way2).");
                 c2.start();
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }

         public static void main(String argv[])
         {
             new MultiSimple(argv);
         }
     }

  1. The `Prolog' object `jp' is the interface to SICStus. It
     implements the methods of `interface Prolog', making it possible
     to write quite similar code for single threaded and multi threaded
     usage of Jasper.  The static method `Jasper.newProlog()' returns
     such an object.

  2. In this example, the Prolog code is loaded by the server thread
     just after creating the SICStus object (which is invisible to the
     user).  The third argument to the method `Jasper.newProlog' is the
     .sav file to restore.  Two threads are then started, which will
     make different queries with the `connected' predicate.

  3. `openPrologQuery' is not recommended in multi threaded mode, but
     if you must use it from more than one Java thread, you should
     enclose the call to `openPrologQuery' and the closing of the query
     in a single synchronized block, synchronizing on the Prolog object.
     *Note SPTerm and Memory:: for details on one of the reasons why
     this is necessary.



File: sicstus.info,  Node: Another Multi Threaded Example (Prolog Top-Level),  Prev: Multi Threaded Example,  Up: Calling Prolog from Java

10.43.3.3 Another Multi Threaded Example (Prolog Top-Level)
...........................................................

This is another multi threaded version of the `train' example (*note
Train Example::).

   In this example, Prolog is the toplevel and Java is invoked via
`library(jasper)'.

                                                 _// MultiSimple2.java_
     import se.sics.jasper.Jasper;
     import se.sics.jasper.Query;
     import se.sics.jasper.Prolog;
     import se.sics.jasper.SICStus;
     import java.util.ArrayList;
     import java.util.HashMap;
     import java.util.ListIterator;

     public class MultiSimple2
     {
         class Client extends Thread
         {
             Prolog jp;
             SICStus sp;
             String qs;

             Client(Prolog p, SICStus s, String queryString)
             {
                 jp = p;
                 sp = s;
                 qs = queryString;
             }
             public void run()
             {
                 HashMap WayMap = new HashMap();
                 try {
                     synchronized(jp) {
                         Query query = jp.openPrologQuery(qs, WayMap);
                         try {
                             while (query.nextSolution()) {
                                 System.out.println(WayMap);
                             }
                         } finally {
                             query.close();
                         }
                     }
                 } catch ( Exception e ) {
                     e.printStackTrace();
                 }
             }
         }
         class Watcher extends Thread
         {
             SICStus mySp;
             ArrayList threadList = new ArrayList(2);

             public boolean add(Client cl)
             {
                 return threadList.add((Object)cl);
             }
             boolean at_least_one_is_alive(ArrayList tl)
             {
                 ListIterator li = tl.listIterator();
                 boolean f = false;
                 while (li.hasNext()) {
                     boolean alive = ((Client)(li.next())).isAlive();
                     f = f || alive;
                 }
                 return f;
             }
             public void run()
             {
                 while (at_least_one_is_alive(threadList)) {
                     try {
                         this.sleep(1000);
                     } catch (InterruptedException ie) {
                         System.err.println("Watcher interrupted.");
                     }
                 }
                 mySp.stopServer();
             }
             Watcher(SICStus sp)
             {
                 mySp = sp;
             }
         }
         public void CallBack()
         {
             try {
                 SICStus sp = SICStus.getCaller(); // get the SICStus object
                 sp.load("train.ql");
                 Prolog jp = sp.newProlog(); // Create a new Prolog Interface
                 Client c1 =
                     new Client(jp, sp,
                                "connected('Örebro', 'Hallsberg', Way1, Way1).");
                 c1.start();
                 // The prolog variable names in the Map are different from above so
                 // we can tell which query gives what solution.
                 Client c2 =
                     new Client(jp, sp,
                                "connected('Stockholm', 'Hallsberg', Way2, Way2).");
                 c2.start();
                 Watcher w = new Watcher(sp);
                 w.add(c1);
                 w.add(c2);
                 w.start();
                 sp.startServer();   // And finally start the server. This
                                     //  method call does not return until
                                     //  some other thread calls sp.stopServer().
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }

     }

                                                    _% multisimple2.pl_
     :- use_module(library(jasper)).
     main:-
             jasper_initialize(JVM),
             jasper_new_object(JVM,
                               'MultiSimple2',
                               init,
                               init,
                               Obj),
             jasper_call(JVM,
                         method('', 'CallBack', [instance]),
                         'CallBack'(+object('')),
                         'CallBack'(Obj)).

  1. This example is similar to the previous multi threaded example
     *Note Multi Threaded Example::, but in this case Prolog is the
     top-level.

  2. Since a SICStus object already exists when the java method
     `CallBack' is called, we cannot use `Jasper.newProlog' to obtain a
     `Prolog' interface. Instead we can use the `SICStus' method
     `getCaller' to get a handle on the `SICStus' object.

  3. In this example we cannot use the `restore' method to load the
     Prolog saved-state, since it unloads all foreign resources. This
     includes `library(jasper)' from which the call to Java was made.
     Instead the method `SICStus.load' can be used to load a compiled
     Prolog file. See the HTML Jasper documentation for details on this
     method. *Note ref-lod-lod:: for how to create a `.ql' file.

  4. The rest of the example is similar to the previous multi threaded
     example with the addition of a watcher class, which is used to
     monitor the client threads. This is necessary if the method
     `startServer' is to return. See the HTML Jasper documentation on
     the methods `SICStus.startServer' and `SICStus.stopServer'.



File: sicstus.info,  Node: Jasper Package Class Reference,  Next: Java Exception Handling,  Prev: Calling Prolog from Java,  Up: lib-jasper

10.43.4 Jasper Package Class Reference
--------------------------------------

Detailed documentation of the classes in the `jasper' package can be
found in the HTML documentation installed with SICStus and also on the
SICStus documentation page (`http://www.sicstus.se/documentation.html').

     *Please note*: None of the `se.sics.jasper' methods are thread
     safe, unless explicitly mentioned, they can only be called from
     the thread that created the SICStus object. (This is different
     from how `se.sics.jasper' worked in release 3.8.)

   As of release 3.9, Jasper supports multi threaded mode. Several Java
threads can access SICStus runtime through a server thread that does
the actual calls.

   The API is defined by three `interfaces': `Prolog', `Query' and
`Term'. The methods of these `interfaces' are implemented by inner
classes of the `Jasper' server. Instances of these inner classes are
returned by methods of the class `Jasper' and can then be used from
multiple threads by the Java programmer.

   In multi threaded mode the Java programmer obtains an object
implementing the `interface Prolog'. That interface has methods similar
to the methods of the `SICStus' class described below.  `Interface
Query' and `interface Term' have the same relations to `class SPQuery'
and `class SPTerm', respectively.  In addition the `SICStus' class, the
`SPQuery' class and the `SPTerm' class all implement the above
interfaces. The methods of the interfaces are preferred over the old
methods.

   See the HTML documentation for details on the methods of the
`interfaces'.

   *Note Jasper Notes: (relnotes)Jasper Notes for limitations in multi
threaded Jasper.

 -- Method on SICStus: boolean query `(String module, String name,
          SPTerm args[])'
     Call NAME with ARGS (a vector of `SPTerm' objects). Like
     `once(Module:Name(Args...))'.

     Returns `true' if the call succeeded, `false' if the call failed,
     i.e. there were no solutions.

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean query `(String goal, Map varMap)'
     Call a goal specified as a string.
    `goal'
          The textual representation of the goal to execute, with
          terminating period.

    `varMap'
          A map from variable names to SPTerm objects. Used both for
          passing variable bindings into the goal and to obtain the
          bindings produced by the goal. May be null.

          On success, the values of variables with names that don't
          start with underscore (`_') will be added to the map.

     Returns `true' if the call succeeded, `false' if the call failed,
     i.e. there were no solutions.

          HashMap varMap = new HashMap();

          varMap.put("File", new SPTerm(sp, "datafile.txt"));

          if (sp.query("see(File),do_something(Result),seen.", varMap)) {
             System.out.println("Result==" +
                                ((SPTerm)varMap.get("Result")).toString());
          } else {
             System.out.println("Failed);
          }

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean query `(SPPredicate pred, SPTerm args[])'
     Obsolescent version of `SICStus::query()' above.


 -- Method on SICStus: boolean queryCutFail `(String module, String
          name, SPTerm args[])'
     Call NAME with ARGS for side-effect only.

     As `SICStus.query()' it only finds the first solution, and then it
     cuts away all other solutions and fails.

     It corresponds roughly to the following Prolog code:
             ( \+ call(Module:Name(Args...)) -> fail; true )
     Introduced in release 3.8.5.

 -- Method on SICStus: boolean queryCutFail `(String goal, Map varMap)'
     Call a goal specified as a string, for side-effect only. The map
     is only used for passing variable bindings _into_ the goal. See
     `query' for details

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean queryCutFail `(SPPredicate pred, SPTerm
          args[])'
     Obsolescent version of `queryCutFail' above.


 -- Method on SICStus: SPQuery openQuery `(String module, String name,
          SPTerm args[])'
     Sets up a query (an object of class `SPQuery'), which can later be
     asked to produce solutions. You must _close_ an opened query when
     no more solutions are required; see below.

     It corresponds roughly to the following Prolog code:
             ( true     % just calling openQuery does not call the predicate

             ; % failing (nextSolution) will backtrack for more solutions
               call(Module:Name(Args...))
             )

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean openQuery `(String goal, Map varMap)'
     Sets up a query specified as a string. See `openQuery' and `query'
     for details.

     Introduced in release 3.8.5.

 -- Method on SICStus: SPQuery openQuery `(SPPredicate pred, SPTerm
          args[])'
     Obsolescent version of `openQuery' above.


   The following methods are used to obtain solutions from an opened
query and to tell the SICStus runtime system that no more answers are
required.

 -- Method on SPQuery: boolean nextSolution ()
     Obtain the next solution. Returns `true' on success and `false' if
     there were no more solutions. When you are no longer interested in
     any more solutions, you should call `SPQuery.close' or
     `SPQuery.cut' to _close_ the query.

     Returns `true' if a new solution was produced, `false' if there
     were no more solutions. This corresponds roughly to `fail/0'.
     *Note SPTerm and Memory:: for additional details.

 -- Method on SPQuery: close ()
     Cut and fail away any previous solution to the query. After
     closing a query object, you should not use it anymore. This
     corresponds roughly to `!, fail'. *Note SPTerm and Memory:: for
     additional details.


 -- Method on SPQuery: cut ()
     Cut, but don't fail away, any previous solution.  After closing a
     query object with `cut', you should not use it anymore. This
     corresponds roughly to `!'.  *Note SPTerm and Memory:: for
     additional details.



File: sicstus.info,  Node: Java Exception Handling,  Next: SPTerm and Memory,  Prev: Jasper Package Class Reference,  Up: lib-jasper

10.43.5 Java Exception Handling
-------------------------------

Exceptions are handled seamlessly between Java and Prolog. This means
that exceptions can be thrown in Prolog and caught in Java and the other
way around. For example, if a predicate called from Java throws an
exception with `throw/1' and the predicate itself does not catch the
exception, the Java-method that performed the query, `queryCutFail()'
for example, will throw an exception (of class `SPException')
containing the exception term. Symmetrically, a Java-exception thrown
(and not caught) in a method called from Prolog will cause the
corresponding predicate (`simple/2' in the example above) to throw an
exception consisting of the exception object (in the internal Prolog
representation of a Java object). *Note Handling Java Exceptions:: for
examples of catching Java exceptions in Prolog.


File: sicstus.info,  Node: SPTerm and Memory,  Next: Java Threads,  Prev: Java Exception Handling,  Up: lib-jasper

10.43.6 SPTerm and Memory
-------------------------

Java and Prolog have quite different memory management policies. In
Java, memory is reclaimed when the garbage collector can determine that
no code will ever use the object occupying the memory. In Prolog, the
garbage collector additionally reclaims memory upon failure (such as
the failure implied in the use of `SPQuery.close()' and
`SPQuery::nextSolution()'). This mismatch in the notion of memory
lifetime can occasionally cause problems.

* Menu:

* Lifetime of SPTerms and Prolog Memory:: Lifetime of SPTerms and Prolog Memory
* Preventing SPTerm Memory Leaks:: Preventing SPTerm Memory Leaks


File: sicstus.info,  Node: Lifetime of SPTerms and Prolog Memory,  Next: Preventing SPTerm Memory Leaks,  Up: SPTerm and Memory

10.43.6.1 Lifetime of SPTerms and Prolog Memory
...............................................

There are three separate memory areas involved when manipulating Prolog
terms from Java using `SPTerm' objects. These areas have largely
independent life times.

  1. The `SPTerm' object itself.

  2. Creating `SPTerm' object also tells Prolog to allocate an
     SP_term_ref.  SP_term_refs have a life-time that is independent of
     the lifetime of the corresponding SPTerm object.

  3. Any Prolog terms allocated on the Prolog heap. An `SPTerm' refer
     to a Prolog term indirectly via a SP_term_ref.

   A SP_term_ref REF (created as a side-effect of creating a `SPTerm'
object) will be reclaimed if either:
   * Java returns to Prolog. This may never happen, especially if Java
     is the top-level application.

   * Assume there exists a still open query Q that was opened before
     the SP_term_ref REF was created. The SP_term_ref REF will be
     reclaimed if the query Q is closed (using `Q.close()' or
     `Q.cut()') or if `Q.nextSolution()' is called.

   An `SPTerm' object will be invalidated (and eventually reclaimed by
the garbage collector) if the corresponding SP_term_ref is reclaimed as
above.  If passed an invalidated SP_term_ref, most methods will throw
an `IllegalTermException' exception.

   A Prolog term (allocated on the Prolog heap) will be deallocated
when:
   * Assume there exists a still open query Q that was openend before
     the term was created. The memory of the term will be reclaimed if
     the query Q is closed using `Q.close()' or if `Q.nextSolution()'
     is called. The memory is not reclaimed if the query is closed with
     `Q.cut()'.


     *Please note*: it is possible to get a `SPTerm' object and its
     SP_term_ref to refer to deallocated Prolog terms, in effect
     creating "dangling" pointers in cases where the `SPTerm' would
     ordinarily still be valid. This will be detected and invalidate the
     `SPTerm':
          {
            SPTerm old = new SPTerm(sp);
            SPQuery q;

            q = sp.openQuery(....);
            ...
            old.consFunctor(...);  // allocate a Prolog term _newer_ than q
            ...
            q.nextSolution(); // or q.close()
            // *error:*
            // The SP_term_ref in q refers to an invalid part of the Prolog heap
            // the SPTerm old will be invalidated by q.nextSolution()
          }


File: sicstus.info,  Node: Preventing SPTerm Memory Leaks,  Prev: Lifetime of SPTerms and Prolog Memory,  Up: SPTerm and Memory

10.43.6.2 Preventing SPTerm Memory Leaks
........................................

Some uses of `SPTerm' will leak memory on the Prolog side. This happens
if a new `SPTerm' object is allocate, but Java neither returns to
Prolog nor backtracks (using the method `close', `cut' or
`nextSolution') into a query opened before the allocation of the
`SPTerm' object.

   As of release 3.8.5, it is possible to explicitly delete a `SPTerm'
object using the `SPTerm.delete()' method. The `delete()' method
invalidates the SPTerm object and makes the associated SP_term_ref
available for re-use.

   Another way to ensure that all SP_term_refs are deallocated is to
open a dummy query only for this purpose. The following code
demonstrates this:

     // Always synchronize over creation and closing of SPQuery objects
     synchronized (sp) {
         // Create a dummy query that invokes true/0
         SPQuery context = sp.openQuery("user","true",new SPTerm[]{});
         // All SP_term_refs created after this point will be reclaimed by
         // Prolog when doing context.close() (or context.cut())

         try {           // ensure context is always closed
             SPTerm tmp = new SPTerm(sp); // created _after_ context
             int i = 0;

             while (i++ < 5) {
                 // re-used instead of doing tmp = new SPTerm(sp,"...");
                 tmp.putString("Iteration #" + i + "\n");
                 // e.g. user:write('Iteration #1\n')
                 sp.queryCutFail("user", "write", new SPTerm[]{tmp});
             }
         }
         finally {
             // This will invalidate tmp and make Prolog
             // reclaim the corresponding SP_term_ref
             context.close(); // or context.cut() to retain variable bindings.
         }
     }


File: sicstus.info,  Node: Java Threads,  Next: The Jasper Library,  Prev: SPTerm and Memory,  Up: lib-jasper

10.43.7 Java Threads
--------------------

None of the pre-3.9 methods in `se.sics.jasper' are thread safe.  They
can only be called from the thread that created the SICStus object.
(This is different from how `se.sics.jasper' used to work in release
3.8.)

   As of 3.9 there are two ways to set up for calls to SICStus from
multiple threads.

   One way is to use the static method `newProlog' in the class
`Jasper':

 -- Method on Jasper: Prolog newProlog `(String argv[], String
          bootPath)'
     Creates a `Prolog' interface object. Starts a server thread, which
     will serve that `Prolog'. The server thread takes care of all
     interaction with the Prolog runtime, making sure that all calls to
     the Prolog runtime will be done from one and the same thread.

   See the HTML documentation on the `interface Prolog' for details on
what methods are available for a client thread.

   Another way is to create a SICStus object and use the following
methods:

 -- Method on SICStus: Prolog newProlog `()'
     Returns the `Prolog' interface for this SICStus object.  Creates a
     server and a client (`Prolog') interface for this SICStus object.
     The server may be started by calling `startServer()'

 -- Method on SICStus: startServer `()'
     Start serving requests from a Prolog client. This method does not
     return until another thread calls `stopServer()'. Before calling
     this method you should call `newProlog()' and hand the result over
     to another Thread.

 -- Method on SICStus: stopServer `()'
     Stops the server. Calling this method causes the Thread running in
     the `startServer()' method to return.

   As with the first method, the `interface Prolog' defines the methods
available for the client threads.


File: sicstus.info,  Node: The Jasper Library,  Prev: Java Threads,  Up: lib-jasper

10.43.8 The Jasper Library
--------------------------

The Jasper library module is the Prolog interface to the Java VM. It
corresponds to the `se.sics.jasper' package in Java. It is loaded by
executing the query:

     | ?- use_module(library(jasper)).

   The Jasper library fully supports multiple SICStus runtimes in a
process.

   Jasper cannot be used when the SICStus runtime is statically linked
to the executable, such as when using `spld --static'.

   The following functionality is provided:

   * Initializing the Java VM using the _JNI Invocation API_
     (`jasper_initialize/[1,2]', `jasper_deinitialize/1').

   * Creating and deleting Java objects directly from Prolog
     (`jasper_new_object/5').

   * Method calls (`jasper_call/4').

   * Global and local (object) reference management
     (`jasper_create_global_ref/3', `jasper_delete_global_ref/2',
     `jasper_delete_local_ref/2'). Global references are used to prevent
     the JVM from garbage collecting a Java object referenced from
     Prolog.

   * There is also a sub-directory containing example programs
     (`library('jasper/examples')').

* Menu:

* Jasper Method Call Example:: Jasper Method Call Example
* Jasper Library Predicates:: Jasper Library Predicates
* Conversion between Prolog Arguments and Java Types:: Conversion between Prolog Arguments and Java Types
* Global vs. Local References:: Global vs. Local References
* Handling Java Exceptions:: Handling Java Exceptions
* Deprecated Jasper API:: Deprecated Jasper API


File: sicstus.info,  Node: Jasper Method Call Example,  Next: Jasper Library Predicates,  Up: The Jasper Library

10.43.8.1 Jasper Method Call Example
....................................

We begin with a small example.

                                                       _// Simple.java_
     import se.sics.jasper.*;

     public class Simple {
       private String instanceDatum = "this is instance data";

       static int simpleMethod(int value) {
         return value*42;
       }

       public String getInstanceData(String arg) {
         return instanceDatum + arg;
       }
     }

   Compile `Simple.java' (UNIX):
     % javac -deprecation \
       -classpath <installdir>/lib/sicstus-4.3.0/bin/jasper.jar Simple.java

   Under Windows this may look like (the command should go on a single
line):
     C:\> c:\jdk1.2.2\bin\javac -deprecation
      -classpath "D:\Program Files\SICStus Prolog 4.3.0\bin\jasper.jar" Simple.java

   The option `-deprecation' is always a good idea, it makes `javac'
warn if your code use deprecated methods.

                                                          _% simple.pl_
     :- use_module(library(jasper)).
     main :-
        %% Replace '/my/java/dir' below with the path containing
        %% 'Simple.class', e.g. to look in the current directory use
        %% classpath(['.']).
        %% You can also use the CLASSPATH environment variable and call
        %% jasper_initialize(JVM)
        %% Under Windows it may look like classpath(['C:/MyTest'])
        jasper_initialize([classpath(['/my/java/dir'])],JVM),

        format('Calling a static method...~n',[]),
        jasper_call(JVM,
                    method('Simple','simpleMethod',[static]), % Which method
                    simple_method(+integer,[-integer]), % Types of arguments
                    simple_method(42,X)), % The arguments.
        format('simpleMethod(~w) = ~w~n',[42,X]),

        format('Creating an object...~n',[]),
        jasper_new_object(JVM, 'Simple', init, init, Object),

        format('Calling an instance method on ~w...~n',[Object]),
        jasper_call(JVM,
                    method('Simple','getInstanceData',[instance]),
                    %% first arg is the instance to call
                    get_instance_data(+object('Simple'), +string,[-string]),
                    get_instance_data(Object, 'foobar', X1)),
        format('getInstanceData(~w) = ~w~n',['foobar',X1]).

   Then, run SICStus:

     % echo "[simple],main." | sicstus
     SICStus 4.3.0 ...
     Licensed to SICS
     % consulting /home1/jojo/simple.pl...
     [...]
     % consulted /home1/jojo/simple.pl in module user, 100 msec 26644 bytes
     Calling a static method...
     simpleMethod(42) = 1764
     Creating an object...
     Calling and instance method on $java_object(135057576)...
     getInstanceData(foobar) = this is instance datafoobar

   This example performed three things.

   * The static method `simpleMethod' was called with argument '42',
     and returned the square of '42', '1764'.

   * An object of class `Simple' was created.

   * The method `getInstanceData' was executed on the object just
     created. The method took an atom as an argument and appended the
     atom to a string stored as a field in the object, yielding "this
     is instance datafoobar".


File: sicstus.info,  Node: Jasper Library Predicates,  Next: Conversion between Prolog Arguments and Java Types,  Prev: Jasper Method Call Example,  Up: The Jasper Library

10.43.8.2 Jasper Library Predicates
...................................

`jasper_initialize(-JVM)'
`jasper_initialize(+OPTIONS, -JVM)'
     Loads and initializes the Java VM. JVM is a reference to the Java
     VM. OPTIONS is a list of options. The options can be of the
     following types:
    `classpath(<classpath>)'
          If `<classpath>' is an atom it will be added (unmodified) to
          the Java VM's classpath.  If `<classpath>' is a list, each
          element will be expanded using `absolute_file_name/2' and
          concatenated using the Java VM's path-separator. Example:
               classpath([library('jasper/examples'),'$HOME/joe'])
          In addition to the classpaths specified here, Jasper will
          automatically add `jasper.jar' to the classpath together with
          the contents of the `CLASSPATH' environment variable.

    `if_exists(OPTION)'
          This option determines what happens if a JVM has already been
          initialized, either through a previous call to
          `jasper_initialize' or because Prolog have been called from
          Java. If a JVM already exists then the other options are
          ignored.
         `ok'
               The default. Argument JVM is bound to the existing JVM.

         `fail'
               The call to `jasper_initialize/2' fails.

         `error'
               The call to `jasper_initialize/2' throws an exception
               (`java_exception(SOME TEXT)').

    `if_not_exists(OPTION)'
          This option determines what happens if a JVM has not already
          been initialized.
         `ok'
               The default. The remaining options are used to
               initialize the JVM.

         `fail'
               The call to `jasper_initialize/2' fails.

         `error'
               The call to `jasper_initialize/2' throws an exception
               (`java_exception(SOME TEXT)').

          As an example, to access the currently running JVM and to
          give an error if there is no running JVM use
          `jasper_initialize([if_exists(ok),if_not_exists(error)],
          JVM)'.

    `OPTION'
          The option is an atom that will be passed directly to the
          Java VM as an option. This enables the user to send
          additional options to the Java VM. Example:
               jasper_initialize(['-Dkenny.is.dead=42'],JVM),
     In addition to the options specified by the user, Jasper adds a
     couple of options on its own in order for Java to find the Jasper
     classes and the Jasper native library.

     There is currently no support for creating multiple JVMs (few
     JDKs, if any, supports this).

`jasper_deinitialize(+JVM)'
     De-initialize Java. Don't call this, current versions of the JVM
     does not support deinitialization.

`jasper_call(+JVM,+METHOD,+TYPEINFO,+ARGS)'
     Calls a Java static or instance method.

    JVM
          A reference to the Java VM, as obtained by
          `jasper_initialize/[1,2]'.

    METHOD
          A term of the form `method(CLASSNAME, METHODNAME, FLAGS)'
          that identifies the method to call.

         CLASSNAME
               This is the "Fully Qualified Classname" of the class
               (for example,   `java/lang/String') of the object or
               where to look for the static   method.  Note that you
               need to surround the atom with single   quotes since it
               contains `/' characters.  The class is ignored when
               calling instance methods but should still be an atom,
               e.g.    `'''.

         NAME
               This is the name of the method, as an atom.

         FLAGS
               This is the singleton list `[instance]' for   instance
               methods and `[static]' for static methods.

    TYPEINFO
          Information about the argument types and the argument
          conversion that should be applied. *Note Conversion between
          Prolog Arguments and Java Types:: for more information on
          specifying argument types.

          Note that for an instance method the first argument must be an
          object reference (specified with `+object(CLASS)'). In this
          case the class is ignored but should still be an atom, e.g.
          `'''.

    ARGS
          A term with one position for each argument to the method. For
          an instance method the first argument is the instance.

`jasper_new_object(+JVM,+CLASSNAME,+TYPEINFO,+ARGS,-OBJECT)'
     Creates a new Java object.

     See `jasper_call/4' above for an explanation of the arguments JVM,
     CLASSNAME, TYPEINFO and ARGS.
    CLASSNAME
          An an atom containing the _fully qualified classname_

    TYPEINFO
          TYPEINFO has the same format as for a static void method.

    ARGS
          A term with one position for each argument to the constructor.

    OBJECT
          This argument is bound to a (local) reference to the created
           object. *Note Global vs. Local References::.

     As an example, the  following code creates a `java/lang/Integer'
     object initialized from a string of digits. It then calls the
     instance method `doubleValue' to obtain the floating point
     representation of the Integer.

          | ?- Chars = "4711",
               %% get existing JVM
               jasper_initialize([if_not_exists(error)], JVM),
               jasper_new_object(JVM, 'java/lang/Integer',
                                 init(+chars), init(Chars), S),
               jasper_call(JVM,
                           method('java/lang/Integer', doubleValue, [instance]),
                           to_double(+object('java/lang/Integer'), [-double]),
                           to_double(S,X)).

          S = '$java_object'(135875344),
          X = 4711.0,  % note that this is now a floating point number
          JVM = '$jvm'(1076414148),
          Chars = [52,55,49,49]  % a.k.a. "4711"

`jasper_create_global_ref(+JVM,+REF,-GLOBALREF)'
     Creates a global reference (GLOBALREF) for a (non-null) Java object
     (REF). *Note Global vs. Local References::.

`jasper_delete_global_ref(+JVM,+GLOBALREF)'
     Destroys a global reference. *Note Global vs. Local References::.

`jasper_create_local_ref(+JVM,+REF,-LOCALREF)'
     Creates a local reference (LOCALREF) for a (non-null) Java object
     (REF). *Note Global vs. Local References::. Rarely needed.

`jasper_delete_local_ref(+JVM,+GLOBALREF)'
     Destroys a local reference. *Note Global vs. Local References::.

`jasper_is_jvm(+JVM)'
     Succeeds if JVM is a reference to a Java Virtual Machine.

`jasper_is_object(+OBJECT)'
`jasper_is_object(+JVM,+OBJECT)'
     Succeeds if OBJECT is a reference to a Java object. The
     representation of Java object _will_ change so use
     `jasper_is_object/1' to recognize objects instead of relying on the
     internal representation. Currently the JVM argument is ignored.
     If, and when, multiple JVMs becomes a possibility
     `jasper_is_object/2' will verify that OBJECT is an object in a
     particular JVM.

`jasper_is_same_object(+JVM,+OBJECT1,+OBJECT2)'
     Succeeds if OBJECT1 and OBJECT2 refers to the same Java object (or
     both are null object references). The same object may be
     represented by two different terms in Prolog so `==/2' can _not_
     be used to reliably detect if two object references refer to the
     same object.

`jasper_is_instance_of(+JVM,+OBJECT,+CLASSNAME)'
     Succeeds if OBJECT is an instance of class CLASSNAME; fails
     otherwise. CLASSNAME is a fully qualified classname; see
     `jasper_call/4'.

`jasper_object_class_name(+JVM,+OBJECT,-CLASSNAME)'
     Returns the fully qualified name of the class of +OBJECT as an
     atom.

`jasper_null(+JVM,-NULLREF)'
     Create a null object reference.

`jasper_is_null(+JVM,+REF)'
     Succeeds if REF is a null object reference, fails otherwise, e.g.
     if REF is not an object reference.



File: sicstus.info,  Node: Conversion between Prolog Arguments and Java Types,  Next: Global vs. Local References,  Prev: Jasper Library Predicates,  Up: The Jasper Library

10.43.8.3 Conversion between Prolog Arguments and Java Types
............................................................

The following table lists the possible values of arguments of the
argument type specification to `jasper_call/4' and
`jasper_new_object/5' (*note Jasper Library Predicates::). The value
specifies which conversion between corresponding Prolog argument and
Java type will take place.

   There is currently no mechanism for specifying Java arrays in this
way.

   In the following the package prefix (`java/lang' or
`se/sics/jasper') has been left out for brevity.

   For several of the numerical types there is the possibility that the
target type cannot accurately represent the source type, e.g. when
converting from a Prolog integer to a Java byte. The behavior in such
cases is unspecified.

`Prolog: `+integer''
`Java:   `int''
     The argument should be a number. It is converted to a Java `int',
     a 32 bit signed integer.

`Prolog: `+byte''
`Java:   `byte''
     The argument should be a number. It is converted to a Java `byte'.

`Prolog: `+short''
`Java:   `short''
     The argument should be a number. It is converted to a Java
     `short', a 16 bit signed integer.

`Prolog: `+long''
`Java:   `long''
     The argument should be a number. It is converted to a Java `long',
     a 64-bit signed integer.

     In releases prior to 3.9.1, the value was truncated to 32 bits
     when passed between Java and Prolog. This is no longer the case.

`Prolog: `+float''
`Java:   `float''
     The argument should be a number. It is converted to a Java `float'.

`Prolog: `+double''
`Java:   `double''
     The argument should be a number. It is converted to a Java
     `double'.

`Prolog: `+term''
`Java:   `SPTerm''
     The argument can be any term. It is passed to Java as an object of
     the class `SPTerm'.

`Prolog: `+object(CLASS)''
`Java:   CLASS'
     The argument should be the Prolog representation of a Java object
     of class CLASS. Unless it is the first argument in a non-static
     method (in which case is it treated as the object on which the
     method should be invoked), it is passed to the Java method as an
     object of class `Class'.

`Prolog: `+atom'   *obsolescent*'
`Java:   `SPCanonicalAtom''
     The argument should be an atom. The Java method will be passed an
     object of class `SPCanonicalAtom'. Often `+string', see below, is
     more useful.

`Prolog: `+boolean''
`Java:   `boolean''
     The argument should be an atom in {`true',`false'}. The Java
     method will receive a `boolean'.

`Prolog: `+chars''
`Java:   `String''
     The argument should be a code-list. The Java method will receive
     an object of class `String'.

`Prolog: `+codes''
`Java:   `String''
     `+codes' is an alias for `+chars'.

`Prolog: `+string''
`Java:   `String''
     The argument should be an atom. The Java method will receive an
     object of class `String'.

`Note.'
     When using `+chars', `+codes' or `+string' the automatic type
     conversion mechanism will also create a type signature of the form
     java/lang/String. If you want to call a method that accepts a
     String object as a parameter, but has different signature, the
     method lookup will fail. A workaround is to explicitly create a
     String object and then call the method. For example:
          :- use_module(library(jasper)).

          main :-
              jasper_initialize([],JVM),
              jasper_new_object(JVM,
          		      'java/lang/String',
          		      init(+chars),
          		      init("hamburger"),
          		      H),
              Str = "urge",
              jasper_new_object(JVM,
           		      'java/lang/String',
           		      init(+chars),
           		      init(Str),
           		      S),
              jasper_call(JVM,
          		method('', contains, [instance]),
          		contains(+object(''),
          			+object('java/lang/CharSequence'),
          			[-boolean]),
          		contains(H, S, B)),
              format('Contains? ~a~n', [B]).

`Prolog: `-atom'   *obsolescent*'
`Java:   `SPTerm''
     The Java method will receive an object of class `SPTerm', which
     should be set to an atom (e.g. using `SPTerm.putString'). The
     argument will be bound to the value of the atom when the method
     returns. Often `-term', see below, is more useful.

`Prolog: `-chars''
`Java:   `StringBuffer''
     The Java method will receive an (empty) object of type
     `StringBuffer', which can be modified. The argument will be bound
     to a code-list of the `StringBuffer' object.

`Prolog: `-codes''
`Java:   `StringBuffer''
     `-codes' is an alias for `-chars'.

`Prolog: `-string''
`Java:   `StringBuffer''
     The Java method will receive an object of type `StringBuffer',
     which can be modified. The argument will be bound to an atom
     converted from the `StringBuffer' object.

`Prolog: `-term''
`Java:   `SPTerm''
     The Java method will receive an object of class `SPTerm', which can
     be set to a term (e.g. using `SPTerm.consFunctor'). The argument
     will be bound to the term when the method returns.

`Prolog: `[-integer]''
`Java:   `int' M`()''
     The Java method should return an `int'. The value will be converted
     to a Prolog integer.

`Prolog: `[-byte]''
`Java:   `byte' M`()''
     The Java method should return a `byte'. The value will be converted
     to a Prolog integer.

`Prolog: `[-short]''
`Java:   `short' M`()''
     The Java method should return a `short'. The value will be
     converted to a Prolog integer.

`Prolog: `[-long]''
`Java:   `long' M`()''
     The Java method should return a `long', a 64 bit signed integer.
     The value will be converted to a Prolog integer.

`Prolog: `[-float]''
`Java:   `float' M`()''
     The Java method should return a `float'. The value will be
     converted to a Prolog float.

`Prolog: `[-double]''
`Java:   `double' M`()''
     The Java method should return a `double'. The value will be
     converted to a Prolog float.

`Prolog: `[-term]''
`Java:   `SPTerm' M`()''
     The Java method should return an object of class `SPTerm', which
     will be converted to a Prolog term.

`Prolog: `[-object(CLASS)]''
`Java:   `SPTerm' M`()''
     The Java method should return an object of class CLASS, which will
     be converted to the internal Prolog representation of the Java
     object.

`Prolog: `[-atom]'  *obsolescent*'
`Java:   `SPTerm' M`()''
     The Java method should return an object of class `SPCanonicalAtom',
     which will be converted to a Prolog atom. Often `[-term]', see
     above, is more useful.

`Prolog: `[-boolean]''
`Java:   `boolean' M`()''
     The Java should return a `boolean'. The value will be converted to
     a Prolog atom in {`true',`false'}.

`Prolog: `[-chars]''
`Java:   `String' M`()''
     The Java method should return an object of class `String', which
     will be converted to a code-list.

`Prolog: `[-codes]''
`Java:   `String' M`()''
     `[-codes]' is an alias for `[-chars]'.

`Prolog: `[-string]''
`Java:   `String' M`()''
     The Java method should return an object of class `String', which
     will be converted to an atom.



File: sicstus.info,  Node: Global vs. Local References,  Next: Handling Java Exceptions,  Prev: Conversion between Prolog Arguments and Java Types,  Up: The Jasper Library

10.43.8.4 Global vs. Local References
.....................................

It is important to understand the rules determining the life-span of
Java object references. These are similar in spirit to the SP_term_refs
of the C-Prolog interface, but since they are used to handle Java
objects instead of Prolog terms they work a little differently.

   Java object references (_currently_ represented in Prolog as
`'$java_object'/1' terms) exist in two flavors: _local_ and _global_.
Their validity are governed by the following rules.

  1. A local reference is valid until Prolog returns to Java or the
     reference is deleted with `jasper_delete_local_ref/2'. It is only
     valid in the (native) thread in which is was created. As a rule of
     thumb a local reference can be used safely as long as it is not
     saved away using `assert/3' or similar.

     Since local references are _never_ reclaimed until Prolog returns
     to Java (which may never happen) you should typically call
     `jasper_delete_local_ref/2' when your code is done with an object.

  2. A global reference is valid until explicitly freed. It can be used
     from any native thread.

  3. All objects returned by Java methods are converted to local
     references.

  4. Java exceptions not caught by Java are thrown as Prolog exceptions
     consisting of a _global_ reference to the exception object, see
     *note Handling Java Exceptions::.


   Local references can be converted into global references
(`jasper_create_global_ref/3'). When the global reference is no longer
needed, it should be delete using `jasper_delete_global_ref/2'.

   For a more in-depth discussion of global and local references,
consult the JNI Documentation
(http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html).

   Using a local (or global) reference that has been deleted (either
explicitly or by returning to Java) is illegal and will generally lead
to crashes. This is a limitation of the Java Native Interface used to
implement the low level interface to Java.


File: sicstus.info,  Node: Handling Java Exceptions,  Next: Deprecated Jasper API,  Prev: Global vs. Local References,  Up: The Jasper Library

10.43.8.5 Handling Java Exceptions
..................................

If a Java method throws an exception, e.g. by using `throw new
Exception("...")' and the exception is not caught by Java then it is
passed on as a Prolog exception. The thrown term is a _global_
reference to the Exception object. The following example code
illustrates how to handle Java exceptions in Prolog:

     exception_example(JVM, ...) :-
        catch(
              %% Call Java method that may raise an exception
              jasper_call(JVM, ...),
              Excp,
              (
                ( is_java_exception(JVM, Excp)
                -> print_exception_info(JVM, Excp)
                ; throw(Excp)       % pass non-Java exceptions to caller
                )
              )
             ).

     is_java_exception(_JVM, Thing) :- var(Thing), !, fail.
     is_java_exception(_JVM, Thing) :-
        Thing = java_exception(_),      % misc error in Java/Prolog glue
        !.
     is_java_exception(JVM, Thing) :-
        jasper_is_object(JVM, Thing),
        jasper_is_instance_of(JVM, Thing, 'java/lang/Throwable').
     print_exception_info(_JVM, java_exception(Message)) :- !,
        format(user_error, '~NJasper exception: ~w~n', [Message]).
     print_exception_info(JVM, Excp) :-
        /*
        // Approximate Java code
        {
           String messageChars = excp.getMessage();
        }
        */
        jasper_call(JVM,
                    method('java/lang/Throwable', 'getMessage', [instance]),
                    get_message(+object('java/lang/Throwable'), [-chars]),
                    get_message(Excp, MessageChars)),
        /* // Approximate Java code
        {
           StringWriter stringWriter = new StringWriter();
           PrintWriter printWriter =  new PrintWriter(stringWriter);
           excp.printStackTrace(printWriter);
           printWriter.close();
           stackTraceChars = StringWriter.toString();
        }
        */
        jasper_new_object(JVM, 'java/io/StringWriter',
                          init, init, StringWriter),
        jasper_new_object(JVM, 'java/io/PrintWriter',
                          init(+object('java/io/Writer')),
                          init(StringWriter), PrintWriter),
        jasper_call(JVM,
                    method('java/lang/Throwable', 'printStackTrace', [instance]),
                    print_stack_trace(+object('java/lang/Throwable'),
                                      +object('java/io/PrintWriter')),
                    print_stack_trace(Excp, PrintWriter)),
        jasper_call(JVM,
                    method('java/io/PrintWriter','close',[instance]),
                    close(+object('java/io/PrintWriter')),
                    close(PrintWriter)),
        jasper_call(JVM,
                    method('java/io/StringWriter','toString',[instance]),
                    to_string(+object('java/io/StringWriter'),[-chars]),
                    to_string(StringWriter, StackTraceChars)),
        jasper_delete_local_ref(JVM, PrintWriter),
        jasper_delete_local_ref(JVM, StringWriter),
        %% ! exceptions are thrown as global references
        jasper_delete_global_ref(JVM, Excp),
        format(user_error, '~NJava Exception: ~s\nStackTrace: ~s~n',
               [MessageChars, StackTraceChars]).


File: sicstus.info,  Node: Deprecated Jasper API,  Prev: Handling Java Exceptions,  Up: The Jasper Library

10.43.8.6 Deprecated Jasper API
...............................

* Menu:

* Deprecated Argument Conversions:: Deprecated Argument Conversions
* Deprecated Jasper Predicates:: Deprecated Jasper Predicates

   The information in this section is only of interest to those that
need to read or modify code that used `library(jasper)' before release
3.8.5.

   A different way of doing method call and creating objects was used in
versions of `library(jasper)' predating release 3.8.5. Use of these
facilities are strongly discouraged although they are still available
in the interest of backward compatibility.

   The old method call predicates are `jasper_call_static/6' and
`jasper_call_instance/6' as well as the old way of calling
`jasper_new_object/5'.


File: sicstus.info,  Node: Deprecated Argument Conversions,  Up: Deprecated Jasper API

10.43.8.7 Deprecated Argument Conversions
.........................................

The pre release 3.8.5 method call predicates in this library use a
specific form of argument lists containing conversion information so
the predicates know how to convert the input arguments from Prolog
datatypes to Java datatypes. This is similar to the (new) mechanism
described in *note Conversion between Prolog Arguments and Java
Types::. The argument lists are standard Prolog lists containing terms
on the following form:

`jboolean(X)'
     X is the atom `true' or `false', representing a Java `boolean'
     primitive type.

`jbyte(X)'
     X is an integer, which is converted to a Java `byte'.

`jchar(X)'
     X is an integer, which is converted to a Java `char'.

`jdouble(X)'
     X is a float, which is converted to a Java `double'.

`jfloat(X)'
     X is a float, which is converted to a Java `float'.

`jint(X)'
     X is an integer, which is converted to a Java `int'.

`jlong(X)'
     X is an integer, which is converted to a Java `long'.

`jshort(X)'
     X is an integer, which is converted to a Java `short'.

`jobject(X)'
     X is a reference to a Java object, as returned by
     `jasper_new_object/5' (*note Jasper Library Predicates::).

`jstring(X)'
     X is an atom, which is converted to a Java `String'.

   If the Prolog term does not fit in the corresponding Java data type
(`jbyte(4711)', for example), the result is undefined.


File: sicstus.info,  Node: Deprecated Jasper Predicates,  Up: Deprecated Jasper API

10.43.8.8 Deprecated Jasper Predicates
......................................

`jasper_new_object(+JVM,+CLASS,+TYPESIG,+ARGS,-OBJECT)   *obsolescent*'
     Creates a new Java object.
    JVM
          A reference to the Java VM, as obtained by
          `jasper_initialize/[1,2]'.

    CLASS
          An an atom containing the _fully qualified classname_ (i.e.
          package name separated with '/', followed by the class name),
          for example `java/lang/String', `se/sics/jasper/SICStus'.

    TYPESIG
          The _type signature_ of the class constructor. A type
          signature is a string that uniquely defines a method within a
          class.  For a definition of type signatures, see the JNI
          Documentation
          (http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html).

    ARGS
          A list of argument specifiers. *Note Deprecated Argument
          Conversions::.

    OBJECT
          A term on the form `'$java_object'(X)', where X is a Java
          object reference. This is the Prolog handle to the Java
          object. *Note Global vs. Local References::.



File: sicstus.info,  Node: lib-prologbeans,  Next: lib-comclient,  Prev: lib-jasper,  Up: The Prolog Library

10.44 PrologBeans Interface--`library(prologbeans)'
===================================================

* Menu:

* PB Intro:: Introduction
* PB Features:: Features
* PB First Example:: A First Example
* PB Prolog Server Interface:: Prolog Server Interface
* PB Java Client Interface:: Java Client Interface
* PB Java Examples:: Java Examples
* PB .NET Client Interface:: .NET Client Interface
* PB .NET Examples:: .NET Examples


File: sicstus.info,  Node: PB Intro,  Next: PB Features,  Up: lib-prologbeans

10.44.1 Introduction
--------------------

PrologBeans is a package for integrating Prolog with applications
written in other languages. Currently Java and .NET are supported.
PrologBeans is based on running Prolog as a separate server process,
and the other part of the application as a client process.  This makes
PrologBeans automatically distributable since the server and the client
can run on different computers anywhere on the Internet.

   PrologBeans is designed to be used when client applications need to
send queries to a Prolog server (and less intended for showing a GUI
from a Prolog program). One typical application would be to connect a
Java or .NET based web application to a Prolog server (see examples
later).

 [image src="images/prologbeansarch.png" text="" ] _PrologBeans
setup where the Prolog application serves several users accessing both
via a web application server and a .NET GUI._

   The PrologBeans package consists of two parts. The Prolog server is a
library module, `library(prologbeans)'. The client is a class library,
`prologbeans.jar' for Java and `prologbeans.dll' for .NET (MS Windows
only).


File: sicstus.info,  Node: PB Features,  Next: PB First Example,  Prev: PB Intro,  Up: lib-prologbeans

10.44.2 Features
----------------

The current version of PrologBeans is designed to be used mainly as a
connection from the client (Java or .NET) to Prolog.  Current features
are:

   * Socket based communication [Java and .NET]

   * Allows the client application and Prolog server to run on
     different machines [Java and .NET]

   * Multiple client applications can connect to same Prolog server
     [Java and .NET]

   * Client applications can make use of several Prolog servers [Java
     and .NET]

   * Allows Java Applets to access Prolog server [Java]

   * Platform independent (e.g. any platform where Prolog and Java or
     .NET exist) [Java and .NET]

   * Simplifies the use of Prolog in Java application servers (Tomcat,
     etc) [Java]

   * Prohibits unwanted use of Prolog server by host control (only
     specified hosts can access the Prolog server) [Java and .NET]

   * Supports Java servlet sessions [Java] 

   * Supports JNDI lookup (Java Naming and Directory Interface) [Java] 

   * Supports .NET server pages (ASPX). [.NET] 


File: sicstus.info,  Node: PB First Example,  Next: PB Prolog Server Interface,  Prev: PB Features,  Up: lib-prologbeans

10.44.3 A First Example
-----------------------

This section provides an example to illustrate how PrologBeans can be
used. This application has a simple Java GUI where the user can enter
expressions that will be evaluated by an expression evaluation server.

     import java.awt.*;
     import java.awt.event.*;
     import javax.swing.*;
     import se.sics.prologbeans.*;

     public class EvaluateGUI implements ActionListener {

       private JTextArea text = new JTextArea(20, 40);
       private JTextField input = new JTextField(36);
       private JButton evaluate = new JButton("Evaluate");
       private PrologSession session = new PrologSession();

       public EvaluateGUI() throws java.io.IOException
         {
         if ((Integer.getInteger("se.sics.prologbeans.debug", 0)).intValue() != 0) {
     	  session.setTimeout(0);
           }
         JFrame frame = new JFrame("Prolog Evaluator");
         Container panel = frame.getContentPane();
         panel.add(new JScrollPane(text), BorderLayout.CENTER);
         JPanel inputPanel = new JPanel(new BorderLayout());
         inputPanel.add(input, BorderLayout.CENTER);
         inputPanel.add(evaluate, BorderLayout.EAST);
         panel.add(inputPanel, BorderLayout. SOUTH);
         text.setEditable(false);
         evaluate.addActionListener(this);
         input.addActionListener(this);

         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.pack();
         frame.setVisible(true);

         session.connect();
       }

       public void actionPerformed(ActionEvent event) {
         try {
           Bindings bindings = new Bindings().bind("E",
                               input.getText() + '.');
           QueryAnswer answer =
             session.executeQuery("evaluate(E,R)", bindings);
           PBTerm result = answer.getValue("R");
           if (result != null) {
             text.append(input.getText() + " = " + result + '\n');
             input.setText("");
           } else {
             text.append("Error: " + answer.getError() + '\n');
           }
         } catch (Exception e) {
           text.append("Error when querying Prolog Server: " +
                       e.getMessage() + '\n');
           e.printStackTrace();
         }
       }

       public static void main(String[] args) throws java.io.IOException
       {
         new EvaluateGUI();
       }
     }

   The Java code above first sets up the GUI with a text area for
showing results, a text field for entering expressions, and a button for
requesting an evaluation (the constructor `EvaluateGUI()'). It will
also add itself as `ActionListener' on both the text field and the
button. The method `actionPerformed(ActionEvent event)' will be called
whenever the user has pressed <RET> or clicked on the button.
`actionPerformed' first binds the variable E to the value of the text
field, and then sends the query to the Prolog server with
`session.executeQuery("evaluate(E,R)", bindings);'. If everything goes
well, the Prolog server will return an answer (bound to R), which will
be appended to the text area.

     :- module(evaluate,[main/0,my_predicate/2]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register acceptable queries and start the server (using default port)
     main:-
         register_query(evaluate(C,P), my_predicate(C,P)),
         start.

     %% We have received a code-list
     %% which needs to be converted into an expression
     my_predicate(Chars, P) :-
         read_from_codes(Chars, X),
         P is X.

   The Prolog code above first defines the module and imports the needed
modules. Then, in the `main/0' predicate, it configures the server to
answer queries on the form `evaluate(C,P)' and starts the server. The
last few lines defines the predicate `my_predicate(Chars, P)', which is
the predicate that performs the evaluation. Note that, here, the
expression to evaluate is represented as a code-list and must be
converted into a term before evaluation.

   In general, arbitrary Prolog terms can be passed to the client via
this mechanism, including terms containing unbound variables.  However,
any unbound variables with attributes or blocked goals attached to them
will be replaced by plain, brand new variables. This is analogous to
the way attributed variables are handled in terms that are written,
copied, asserted, gathered as solutions to `findall/3' and friends, or
raised as exceptions. If the attributes must be passed to the client,
the Prolog code can obtain them by using `copy_term/3' (*note
ref-lte-cpt::).

   *Please note*: the environment variable `SP_PATH' as used here is
meant to be a shorthand (*note CPL Notes::), and does not need to be
set explicitly.

   To start the example, first start the Prolog server by going to the
`%SP_PATH%\library\prologbeans\examples\evaluate' (Windows), or
`$SP_PATH/library/prologbeans/examples/evaluate' (UNIX/Linux) directory
and type:

     % sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." EvaluateGUI (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." EvaluateGUI (UNIX)


File: sicstus.info,  Node: PB Prolog Server Interface,  Next: PB Java Client Interface,  Prev: PB First Example,  Up: lib-prologbeans

10.44.4 Prolog Server Interface
-------------------------------

The Prolog interface is based on the idea of a Prolog server that
provides its service by answering queries from external applications
(typically Java applications). The Prolog interface in PrologBeans is
defined in `library(prologbeans)', which implements the Prolog server
and exports the following predicates:

`start'
`start(+OPTIONS)'
     starts the Prolog server using the options specified.  *Please
     note*: `start/[0,1]' will not return until a server shutdown
     occurs.  OPTIONS should be a list of zero or more of:

    `port(?VAL)'
          an integer denoting the port number of the Prolog server. The
          default port, if no port option is present, is 8066. In the
          case of the default port being used, the Socket Reuse Adress
          bit will be set in the underlying sockets layer. If `VAL' is
          a variable, some unused port will be selected by the OS, the
          actual port number can be obtained with
          `get_server_property/1', typically from a `server_started'
          event listener.

    `accepted_hosts(+VAL)'
          a list of atoms denoting the hosts (in form of IP-addresses)
          that are accepted by the Prolog server (default:
          `['127.0.0.1']').

    `session_timeout(+VAL)'
          an integer denoting the duration of a session in seconds. The
          session will be removed if it has been inactive more than
          this timeout when the session garbage collect starts. If the
          session timeout is set to zero there will be no garbage
          collect on sessions (default: `0').

    `session_gc_timeout(+VAL)'
          an integer denoting the minimum time in seconds between two
          consecutive session garbage collections. If the timeout is
          set to zero there will be no garbage collect on sessions
          (default: `0').

     For example:

          :- start([port(7500),
                    accepted_hosts(['127.0.0.1','99.8.7.6'])]).

`shutdown'
`shutdown(+Mode)'
     shuts down the server and closes the sockets and the streams after
     processing all available input. There are three modes:
    `now'
          as soon as possible (default).

    `no_sessions'
          after all sessions have ended (all sessions have either been
          explicitly removed by request of the client application, or
          they have been garbage collected). *Please note*: there can
          still be connections to the Prolog server even when all
          sessions have ended.

    `no_connections'
          after all connections to the Prolog server are closed.
          *Please note*: there can still be user sessions left when all
          connections have been closed.


`register_query(+QUERY, :PREDICATETOCALL)'
`register_query(+QUERY, :PREDICATETOCALL, +SESSIONVAR)'
     registers a query and the corresponding goal. Before the
     registration, any previously registered query matching QUERY will
     be removed (as if by `unregister_query(QUERY)').  The goal
     PREDICATETOCALL will be called when a query matching QUERY is
     received.

     Typically, QUERY and PREDICATETOCALL share variables that are
     instantiated by the call, and the instantiated QUERY is passed
     back to the client. In general, variable bindings can be arbitrary
     Prolog terms, including terms containing unbound variables.
     However, any unbound variables with attributes or blocked goals
     attached to them will be replaced by plain, brand new variables.
     This is analogous to the way attributed variables are handled in
     terms that are written, copied, asserted, gathered as solutions to
     `findall/3' and friends, or raised as exceptions. If the
     attributes must be passed to the client, the Prolog code can
     obtain them by using `copy_term/3' (*note ref-lte-cpt::).

     The goal is called determinately, i.e. it is never backtracked
     into.  If it fails, the term `no' is passed to the client instead
     of the instantiated QUERY.  If it raises an exception E, the term
     `error(E)' is passed to the client instead of the instantiated
     QUERY.

     Before calling the query, the variable SESSIONVAR, if given, is
     bound to the id of the current session. Session ids are typically
     generated in web applications that track users and mark all
     consecutive web-accesses with the same session id.

`unregister_query(+QUERY)'
     unregisters all queries matching QUERY.  

`session_get(+SESSIONID, +PARAMETERNAME, +DEFAULTVALUE, -VALUE)'
     returns the value of a given parameter in a given session. If no
     value exists, it will return the default value.  Arguments:
    SESSIONID
          is the id of the session for which values have been stored

    PARAMETERNAME
          an atom, is the name of the parameter to retrieve

    DEFAULTVALUE
          is the value that will be used if no value is stored

    VALUE
          is the stored value or the default value if nothing was stored

`session_put(+SESSIONID, +PARAMETERNAME, +VALUE)'
     stores the value of the given parameter. *Please note*: any
     pre-existing value for this parameter will be overwritten. Note
     that `session_put/3' will not be undone when backtracking (the
     current implementation is based on `assert').  Arguments:

    SESSIONID
          is the id of the session for the values to store

    PARAMETERNAME
          an atom, is the name of the parameter to store

    VALUE
          the value to be stored

`register_event_listener(+EVENT, :PREDICATETOCALL)'
`register_event_listener(+EVENT, :PREDICATETOCALL, -ID)'
     Registers `PREDICATETOCALL' to be called (as if by
     `once(PREDICATETOCALL)') when the event matching `EVENT' occurs
     (event matching is on principal functor only). If the goal fails or
     raises an exception a warning is written to `user_error' but the
     failure or exception is otherwise ignored. Arguments:

    EVENT
          is the event template; see below.

    PREDICATETOCALL
          an arbitrary goal.

    ID
          becomes bound to a (ground) term that can be used with
          `unregister_event_listener/1' to remove this event listener.

     The predefined events are as follows:

    `session_started(+SESSIONID)'
          called before the first call to a query for this session

    `session_ended(+SESSIONID)'
          called before the session is about to be garbage collected
          (removed)

    `server_started'
          called when the server is about to start (enter its main loop)

    `server_shutdown'
          called  when the server is about to shut down

     Attempt to register an event listener for other events than the
     predefined events will throw an exception.

     More than one listeners can be defined for the same event. They
     will be called in some unspecified order when the event occurs.

`unregister_event_listener(+ID)'
     Unregister a previously registered event listener. The ID is the
     value returned by the corresponding call to
     `register_event_listener/3'. It is an error to attempt to
     unregister an event listener more than once.



File: sicstus.info,  Node: PB Java Client Interface,  Next: PB Java Examples,  Prev: PB Prolog Server Interface,  Up: lib-prologbeans

10.44.5 Java Client Interface
-----------------------------

The Java interface is centered around the class `PrologSession', which
represents a connection (or session) to a Prolog server.
`PrologSession' contains static methods for looking up named
`PrologSession' instances using JNDI (Java Naming and Directory
Interface) as well as methods for querying the Prolog server.  Other
important classes are: `QueryAnswer', which contains the answer for a
query sent to the Prolog server; `PBTerm', which represents a Prolog
term; and `Bindings', which supports stuffing of variable values used
in queries.

   General information about Java, Servlets and JNDI is available at the
Java Technology site: `http://java.sun.com/'

   A brief description of the provided Java classes are presented
below. More information about the Java APIs is available in the JavaDoc
files on the page `http://www.sicstus.se/documentation.html'.

`PrologSession'
     The `PrologSession' object is the connection to the Prolog server.
     The constructor `PrologSession()' creates a `PrologSession' with
     the default settings (`host = localhost, port = 8066'.

`QueryAnswer'
     The `QueryAnswer' contains the answer (new bindings) for a query
     (or the error that occurred during the query process).

`PBTerm'
     The `PBTerm' object is for representing parsed Prolog terms.

`Bindings'
     `Bindings' is used for binding variables to values in a query sent
     to the Prolog. The values will be automatically stuffed before
     they are sent to the Prolog server.



File: sicstus.info,  Node: PB Java Examples,  Next: PB .NET Client Interface,  Prev: PB Java Client Interface,  Up: lib-prologbeans

10.44.6 Java Examples
---------------------

* Menu:

* PB Ex Embedding:: Embedding Prolog in Java Applications
* PB Ex Servers:: Application Servers
* PB Ex Tomcat:: Configuring Tomcat for PrologBeans

   The PrologBeans examples for Java can be found in the directory
corresponding to the file search path `pbexamples', defined as if by a
clause:

     user:file_search_path(pbexamples, library('prologbeans/examples')).


File: sicstus.info,  Node: PB Ex Embedding,  Next: PB Ex Servers,  Up: PB Java Examples

10.44.6.1 Embedding Prolog in Java Applications
...............................................

If you have an advanced Prolog application that needs a GUI you can
write a stand-alone Java application that handles the GUI and set up
the Prolog server to call the right predicates in the Prolog
application.

   An example of how to do this can be found under the
`pbexamples(evaluate)' directory (see the example code in *note PB
First Example::).

   Another example of this is `pbexamples(pbtest)', which illustrates
several advanced features like:
   * registering several queries

   * listening to server events (`server_started')

   * shutting down the Prolog server from Java

   * starting up the Prolog server from Java

   * using dynamic (OS assigned) ports for the Java/Prolog communication

   The example is run by executing the Java program `PBTest':
     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." PBTest (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." PBTest (UNIX)


File: sicstus.info,  Node: PB Ex Servers,  Next: PB Ex Tomcat,  Prev: PB Ex Embedding,  Up: PB Java Examples

10.44.6.2 Application Servers
.............................

If you want to get your Prolog application to be accessible from an
intranet or the Internet you can use this package to embed the Prolog
programs into a Java application server such as Tomcat, WebSphere, etc.

   An example of how to do this is provided in `pbexamples(sessionsum)'.
This example uses sessions to keep track of users so that the
application can hold a state for a user session (as in the example
below, remember the sum of all expressions evaluated in the session).

     <%@ page import = "se.sics.prologbeans.*" %>
     <html>
     <head><title>Sum Calculator</title></head>
     <body bgcolor="white">
     <font size=4>Prolog Sum Calculator, enter expression to evaluate:
     <form><input type=text name=query></form>
     <%
        PrologSession pSession =
        PrologSession.getPrologSession("prolog/PrologSession", session);
        pSession.connect();

        String evQuery = request.getParameter("query");
        String output = "";
        if (evQuery != null) {
          Bindings bindings = new Bindings().bind("E",evQuery + '.');
          QueryAnswer answer =
             pSession.executeQuery("sum(E,Sum,Average,Count)", bindings);
          PBTerm average = answer.getValue("Average");
          if (average != null) {
             PBTerm sum = answer.getValue("Sum");
             PBTerm count = answer.getValue("Count");

             output = "<h4>Average =" + average + ", Sum = "
             + sum + " Count = " + count + "</h4>";
          } else {
             output = "<h4>Error: " + answer.getError() + "</h4>";
          }
       }
     %>
     <%= output  %><br></font>
     <p><hr>Powered by SICStus Prolog
     </body></html>

   The example shows the code of a JSP (Java Server Page). It makes use
of the method `PrologSession.getPrologSession(String jndiName,
HTTPSession session)', which uses JNDI to look up a registered
`PrologSession', which is connected to the Prolog server. The variable
SESSION is in a JSP bound to the current `HTTPSession', and the
variable REQUEST is bound to the current `HTTPRequest'.  Since the
`HTTPSession' object `session' is specified all queries to the Prolog
server will contain a session id. The rest of the example shows how to
send a query and output the answer.

   Example usage of sessions (from the `sessionsum' example) is shown
below, and is from `pbexamples('sessionsum/sessionsum.pl')':

     :- module(sessionsum,[main/0,sum/5]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register the acceptable queries (session based)
     main:-
         register_query(sum(C,Sum,Average,Count),
                        sum(C,Session,Sum,Average,Count),
                        Session),
         start.

     %% The sum predicate which gets the information from a session database,
     %% makes some updates and then stores it back in to the session store
     %% (and returns the information back to the application server)
     sum(ExprChars, Session, Sum, Average, Count) :-
         session_get(Session, sum, 0, OldSum),
         session_get(Session, count, 0, OldCount),
         read_from_codes(ExprChars, Expr),
         Val is Expr,
         Sum is OldSum + Val,
         Count is OldCount + 1,
         Average is Sum / Count,
         session_put(Session, sum, Sum),
         session_put(Session, count, Count).

   In this example a query `sum/4' is registered to call `sum/5' where
one of the variables, SESSION will be bound to the session id
associated to the query. The `sum/5' predicate uses the `session_get/4'
predicate to access stored information about the particular session,
and then it performs the evaluation of the expression. Finally, it
updates and stores the values for this session.


File: sicstus.info,  Node: PB Ex Tomcat,  Prev: PB Ex Servers,  Up: PB Java Examples

10.44.6.3 Configuring Tomcat for PrologBeans
............................................

This section will briefly describe how to set up a Tomcat server so
that is it possible to test the example JSPs. Some knowledge about how
to run Tomcat and how to set up your own web application is required.
Detailed information about Tomcat is available at
`http://jakarta.apache.org/tomcat/'.

   Assuming that the environment variable CATALINA_HOME is set to the
installation directory of Tomcat, do the following:

  1. Create the directory `$CATALINA_HOME/webapps/PB_example'

  2. Copy the file `pbexamples('sessionsum/sessionsum.jsp')' to
     `$CATALINA_HOME/webapps/PB_example/sessionsum.jsp'

  3. Create the directory
     `$CATALINA_HOME/webapps/PB_example/WEB-INF/lib'

  4. Copy the file `$SP_PATH/bin/prologbeans.jar' to
     `$CATALINA_HOME/webapps/PB_example/WEB-INF/lib/prologbeans.jar'

  5. Create the directory `$CATALINA_HOME/webapps/PB_example/META-INF'

  6. Create the file
     `$CATALINA_HOME/webapps/PB_example/META-INF/context.xml' with the
     following content:
          <Context docBase="PB_example">
             <Resource name="prolog/PrologSession" auth="Container"
                       type="se.sics.prologbeans.PrologSession"
          	     factory="org.apache.naming.factory.BeanFactory" />

          </Context>

  7. Create the file
     `$CATALINA_HOME/webapps/PB_example/WEB-INF/web.xml' with the
     following content:
          <?xml version="1.0" encoding="ISO-8859-1"?>
          <!DOCTYPE web-app
               PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
              "http://java.sun.com/dtd/web-app_2_3.dtd">
          <web-app>

              <resource-env-ref>
                <description>
                  Object factory for PrologSession instances.
                </description>
                <resource-env-ref-name>
                  prolog/PrologSession
                </resource-env-ref-name>
                <resource-env-ref-type>
                  se.sics.prologbeans.PrologSession
                </resource-env-ref-type>
              </resource-env-ref>

          </web-app>

  8. Start SICStus, load `sessionsum.pl' and run main.

  9. Start the Tomcat server.

 10. In a web browser, enter
     `http://localhost:8080/PB_example/sessionsum.jsp'



File: sicstus.info,  Node: PB .NET Client Interface,  Next: PB .NET Examples,  Prev: PB Java Examples,  Up: lib-prologbeans

10.44.7 .NET Client Interface
-----------------------------

The class `PrologSession' in the .NET interface represents a connection
to a Prolog server. `PrologSession' contains methods for establishing a
connection and querying the Prolog server. Other important classes are:
`QueryAnswer', which contains the answer for a query sent to the Prolog
server; `PBTerm', which represents a Prolog term; and `Bindings', which
supports stuffing of variable values used in queries.

   The `PrologSession' object is the connection to the Prolog server.
The constructor `PrologSession()' creates a `PrologSession' with the
default settings (`host = localhost, port = 8066'.

   Detailed documentation on the .NET APIs of PrologBeans is available
in the PrologBeans.NET documentation files on the page
`http://www.sicstus.se/documentation.html' or locally at
`%SP_PATH%/doc/html/prologbeans.NET' (where `SP_PATH' is the path to
your SICStus Prolog installation directory).

   *Please note*: The current version of the PB .NET Client interface
is implemented using J#, a .NET language closely resembling Java. This
allows us to use the same source code for the .NET code as for Java. J#
is now obsolete and does not work well with the latest version of the
.NET framework (.NET 4). We plan to include a new version of the PB
.NET Client, written in C#, in a future version of SICStus Prolog.


File: sicstus.info,  Node: PB .NET Examples,  Prev: PB .NET Client Interface,  Up: lib-prologbeans

10.44.8 .NET Examples
---------------------

* Menu:

* PB C# Examples:: C# Examples
* PB VB Example:: Visual Basic Example

   The PrologBeans examples for .NET can be found in the directory
corresponding to the file search path `pbnetexamples', defined as if by
a clause:

     user:file_search_path(pbnetexamples, library('prologbeans.NET/examples')).


File: sicstus.info,  Node: PB C# Examples,  Next: PB VB Example,  Up: PB .NET Examples

10.44.8.1 C# Examples
.....................

_.NET Embedding._ If you have an advanced Prolog application that needs
a GUI you can write a stand-alone .NET application that handles the GUI
and set up the Prolog server to call the right predicates in the Prolog
application.

   An example of how to do this can be found under the
`pbnetexamples('evaluate.NET')' directory. This example is the C#
version of the example shown in *note PB First Example::).

   To start the example, first start the Prolog server by going to the
`pbnetexamples('evaluate.NET')' directory and type:

     > sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > run.bat

   Another example of this is `pbnetexamples('pbtest.NET')', which
illustrates several advanced features like:

   * registering several queries

   * listening to server events (`server_started')

   * shutting down the Prolog server from .NET

   * starting up the Prolog server from .NET

   * using dynamic (OS assigned) ports for the .NET/Prolog communication

   The example is run by executing the C# program `PBTest':

     > PBTest

   _ASPX Servers Pages._ If you want to get your Prolog application to
be accessible from an intranet or the Internet you can use this package
to embed the Prolog programs into a .NET ASP page which can be served
by e.g. Internet Information Services.

   An example of how to do this is provided in
`pbnetexamples('prologasp.NET/eval.aspx')'. Consult your IIS
documentation for how to configure it for an ASPX page.  *The ASPX
example has a number of security vulnerabilites and is for illustrative
purposes only. Consult with an expert. *


File: sicstus.info,  Node: PB VB Example,  Prev: PB C# Examples,  Up: PB .NET Examples

10.44.8.2 Visual Basic Example
..............................

A Visual Basic .NET example can be found in
`pbnetexamples('vb_examples.NET/calculator')'. It is a simple
calculator similar to the first C# `EvaluateGUI' example in *note PB
First Example::. This example is in the form of a Visual Studio project.

   To run the example:

  1. Open the project files in Visual Studio .NET

  2. Add a reference in Visual Studio .NET to the installed
     `prologbeans.dll'

  3. Start sicstus with the following command:
          sicstus -l %SP_PATH%/library/prologbeans/examples/evaluate/evaluate --goal "main."

  4. Build and run the example in Visual Studio .NET


File: sicstus.info,  Node: lib-comclient,  Next: lib-plunit,  Prev: lib-prologbeans,  Up: The Prolog Library

10.45 COM Client--`library(comclient)'
======================================

This library provides rudimentary access to COM automation objects. As
an example it is possible to manipulate Microsoft Office applications
and Internet Explorer. It is not possible, at present, to build COM
objects using this library.

   Feedback is very welcome. Please contact SICStus support
(<sicstus-support@sics.se>) if you have suggestions for how this
library could be improved.

* Menu:

* Preliminaries::               Preliminaries
* Terminology::                 Terminology
* COM Client Predicates::       Predicate Reference
* COM Client Examples::         Examples


File: sicstus.info,  Node: Preliminaries,  Next: Terminology,  Up: lib-comclient

10.45.1 Preliminaries
---------------------

In most contexts both atoms and code-lists are treated as strings. With
the wide character support available in release 3.8 and later, is
should now be possible to pass UNICODE atoms and strings successfully
to the COM interface.


File: sicstus.info,  Node: Terminology,  Next: COM Client Predicates,  Prev: Preliminaries,  Up: lib-comclient

10.45.2 Terminology
-------------------

"ProgID"
     A human readable name for an object class, typically as an atom,
     e.g. `'Excel.Application''.

"CLSID (Class Identifier)"
     A globally unique identifier of a class, typically as an atom,
     e.g. `'{00024500-0000-0000-C000-000000000046}''.

     Where it makes sense a PROGID can be used instead of the
     corresponding CLSID.

"IID (Interface Identifier)"
     A globally unique identifier of an interface. Currently only the
     `'IDispatch'' interface is used so you do not have to care about
     this.

"IName (Interface Name)"
     The human readable name of an interface, e.g.  `'IDispatch''.

     Where it makes sense an INAME can be used instead of the
     corresponding IID.

"Object"
     A COM-object (or rather a pointer to an interface).

"ComValue"
     A value that can be passed from COM to SICStus Prolog. Currently
     numeric types, booleans (treated as 1 for `true', 0 for `false'),
     strings, and COM objects.

"ComInArg"
     A value that can be passed as an input argument to COM, currently
     one of:
    atom
          Passed as a string (BSTR)

    numeric
          Passed as the corresponding number

    list
          A code-list is treated as a string.

    COM object
          A compound term referring to a COM object.

    compound
          Other compound terms are presently illegal but  will be used
          to extend the permitted types.

"SimpleCallSpec"
     Denotes a single method and its arguments. As an example, to call
     the method named `foo' with the arguments `42' and the string
     `"bar"' the SIMPLECALLSPEC would be the compound term
     `foo(42,'bar')' or, as an alternative, `foo(42,"bar")'.

     The arguments of the compound term are treated as follows:
    "ComInArg"
          See above

    "variable"
          The argument is assumed to be output. The variable is bound to
          the resulting value when the method returns.

    "mutable"
          The argument is assumed to be input/output. The value of the
          mutable is passed to the method and when the method returns
          the mutable is updated with the corresponding return value.

"CallSpec"
     Either a SimpleCallSpec or a list of CallSpecs. If it is a list
     then all but the last SimpleCallSpec are assumed to denote method
     calls that return a COM-object. So for instance the VB statement
     `app.workbooks.add' can be expressed either as:
          comclient_invoke_method_proc(App, [workbooks, add])
     or as
          comclient_invoke_method_fun(App, workbooks, WorkBooks),
          comclient_invoke_method_proc(WorkBooks, add),
          comclient_release(WorkBooks)



File: sicstus.info,  Node: COM Client Predicates,  Next: COM Client Examples,  Prev: Terminology,  Up: lib-comclient

10.45.3 Predicate Reference
---------------------------

`comclient_garbage_collect'
     Release Objects that are no longer reachable from SICStus Prolog.
     To achieve this the predicate `comclient_garbage_collect/0'
     performs an atom garbage collection, i.e.
     `garbage_collect_atoms/0', so it should be used sparingly.

`comclient_is_object(+OBJECT)'
     Succeeds if OBJECT "looks like" an object. It does not check that
     the object is (still) reachable from SICStus Prolog, see
     `comclient_valid_object/1'. Currently an object looks like
     `'$comclient_object'(STUFF)' where STUFF is some prolog term. Do
     not rely on this representation!

`comclient_valid_object(+OBJECT)'
     Succeeds if OBJECT is an object that is still available to SICStus
     Prolog.

`comclient_equal(+OBJECT1, +OBJECT2)'
     Succeeds if OBJECT1 and OBJECT2 are the same object. (It succeeds
     if their `'IUnknown'' interfaces are identical)

`comclient_clsid_from_progid(+PROGID, -CLSID).'
     Obtain the CLSID corresponding to a particular PROGID. Uses the
     Win32 routine `CLSIDFromProgID'. You rarely need this since you
     can use the ProgID directly in most cases.

`comclient_progid_from_clsid(+CLSID, -PROGID).'
     Obtain the PROGID corresponding to a particular CLSID. Uses the
     Win32 routine `ProgIDFromCLSID'. Rarely needed. The PROGID
     returned will typically have the version suffix appended.

     Example, to determine what version of `Excel.Application' is
     installed:
          | ?- comclient_clsid_from_progid('Excel.Application, CLSID),
               comclient_progid_from_clsid(CLSID, ProgID).
          CLSID = '{00024500-0000-0000-C000-000000000046}',
          ProgID = 'Excel.Application.8'

`comclient_iid_from_name(+INAME, -IID)'
     Look in the registry for the IID corresponding to a particular
     Interface. Currently of little use.
          | ?- comclient_iid_from_name('IDispatch', IID).
          IID = '{00020400-0000-0000-C000-000000000046}'

`comclient_name_from_iid(+IID, -INAME)'
     Look in the registry for the name corresponding to a particular
     IID. Currently of little use.

`comclient_create_instance(+ID, -OBJECT)'
     Create an instance of the Class identified by the CLSID or ProgID
     ID.
          comclient_create_instance('Excel.Application', App)
     Corresponds to `CoCreateInstance'.

`comclient_get_active_object(+ID, -OBJECT)'
     Retrieves a running object of the Class identified by the CLSID or
     ProgID ID.
          comclient_get_active_object('Excel.Application', App)
     An exception is thrown if there is no suitable running object.
     Corresponds to `GetActiveObject'.

`comclient_invoke_method_fun(+OBJECT, +CALLSPEC, -COMVALUE)'
     Call a method that returns a value. Also use this to get the value
     of properties.

`comclient_invoke_method_proc(+OBJECT, +CALLSPEC)'
     Call a method that does not return a value.

`comclient_invoke_put(+OBJECT, +CALLSPEC, +COMINARG)'
     Set the property denoted by CALLSPEC to COMVALUE.  Example:
     `comclient_invoke_put(App, visible, 1)'

`comclient_release(+OBJECT)'
     Release the object and free the datastructures used by SICStus
     Prolog to keep track of this object. After releasing an object the
     term denoting the object can no longer be used to access the
     object (any attempt to do so will raise an exception).

          *Please note*: The same COM-object can be represented by
          different prolog terms. A COM object is not released from
          SICStus Prolog until all such representations have been
          released, either explicitly by calling `comclient_release/1'
          or by calling `comclient_garbage_collect/0'.

          You cannot use `OBJ1 == OBJ2' to determine whether two
          COM-objects are identical. Instead use `comclient_equal/2'.

`comclient_is_exception(+EXCEPTIONTERM)'
     Succeeds if EXCEPTIONTERM is an exception raised by the comclient
     module.
          catch(<some code>,
                Exception,
                ( comclient_is_exception(E) ->
                   handle_com_related_errors(E)
                ; otherwise -> % Pass other exceptions upwards
                   throw(E)
                ))

`comclient_exception_code(+EXCEPTIONTERM, -ERRORCODE)'
`comclient_exception_culprit(+EXCEPTIONTERM, -CULPRIT)'
`comclient_exception_description(+EXCEPTIONTERM, -DESCRIPTION)'
     Access the various parts of a comclient exception. The ERRORCODE
     is the `HRESULT' causing the exception. CULPRIT is a term
     corresponding to the call that gave an exception. DESCRIPTION, if
     available, is either a term `'EXCEPINFO'(...)' corresponding to an
     `EXCEPINFO' structure or `'ARGERR'(MethodName, ArgNumber)'.

     The `EXCEPINFO' has six arguments corresponding to, and in the
     same order as, the arguments of the `EXCEPINFO' struct.


File: sicstus.info,  Node: COM Client Examples,  Prev: COM Client Predicates,  Up: lib-comclient

10.45.4 Examples
----------------

The following example launches Microsoft Excel, adds a new worksheet,
fill in some fields and finally clears the worksheet and quits _Excel_
     :- use_module(library(comclient)).
     :- use_module(library(lists)).

     test :-
        test('Excel.Application').

     test(ProgID) :-
        comclient_create_instance(ProgID, App),
        %% Visuall Basic: app.visible = 1
        comclient_invoke_put(App, visible, 1),
        %% VB: app.workbooks.add
        comclient_invoke_method_proc(App, [workbooks, add]),
        %% VB: with app.activesheet
        comclient_invoke_method_fun(App, activesheet, ActiveSheet),

        Rows = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
        Cols = Rows,
        %% VB: .cells i,j . value = i+j/100
        (
          member(I, Rows),
          member(J, Cols),
          ValIJ is I+J/100,

          comclient_invoke_put(ActiveSheet, [cells(I,J),value], ValIJ),
          fail
        ; true
        ),
        (
          member(I, Rows),
          member(J, Cols),
          %% retrieve cell values
          comclient_invoke_method_fun(ActiveSheet, [cells(I,J), value],CellValue),
          format(user_error, '~nCell(~w,~w) = ~w', [I,J,CellValue]),
          fail
        ; true
        ),

        Range = 'A1:O15',
        format(user_error, '~Npress return to clear range (~w)', [Range]),
        flush_output(user_error),
        get_code(_),

        %% VB: .range A1:O15 .Clear
        comclient_invoke_method_proc(ActiveSheet, [range(Range),clear]),

        %% Avoid Excel query "do you want to save..."
        %%  VB: app.activeworkbook.saved = 1
        comclient_invoke_put(App, [activeworkbook,saved], 1),

        format(user_error, '~Npress return to quit \'~w\'', [ProgID]),
        flush_output(user_error),
        get_code(_),

        %% VB: app.quit
        comclient_invoke_method_proc(App, quit),

        comclient_release(ActiveSheet),
        comclient_release(App).


File: sicstus.info,  Node: lib-plunit,  Prev: lib-comclient,  Up: The Prolog Library

10.46 Plunit Interface--`library(plunit)'
=========================================

* Menu:

* PlUnit Introduction:: Introduction
* PlUnit A Unit Test Box:: A Unit Test Box
* PlUnit Running the Test-Suite:: Running the Test-Suite
* PlUnit Tests and Production Systems:: Tests and Production Systems


File: sicstus.info,  Node: PlUnit Introduction,  Next: PlUnit A Unit Test Box,  Up: lib-plunit

10.46.1 Introduction
--------------------

This library module provides a Prolog unit-test framework, initially
developed by Jan Wielemaker for SWI-Prolog.  The code and documentation
was subsequently adapted for SICStus Prolog by SICS.  The module is a
third-party product, and not part of SICStus Prolog proper.

   Automatic testing of software during development is probably the most
important Quality Assurance measure. Tests can validate the final
system, which is nice for your users.  However, most (Prolog) developers
forget that it is not just a burden during development.

   * Tests document how the code is supposed to be used.

   * Tests can validate claims you make on the Prolog
     implementation.  Writing a test makes the claim           explicit.

   * Tests avoid big applications saying "no" after
     modifications.  This saves time during development,           and
     it saves _a lot_ of time if you must return           to the
     application a few years later or you must           modify and
     debug someone else's application.


File: sicstus.info,  Node: PlUnit A Unit Test Box,  Next: PlUnit Running the Test-Suite,  Prev: PlUnit Introduction,  Up: lib-plunit

10.46.2 A Unit Test Box
-----------------------

Tests are written in normal Prolog.  A unit test is a named collection
of individual tests, enclosed within the directives:
     `:- begin_tests(UNIT[,OPTIONS]).'
   
and:
     `:- end_tests(UNIT).'
   
   They can be embedded inside a normal source module, or be placed in a
separate test-file that loads the files to be tested. The individual
tests are defined by rules of the form:
     `test(NAME[,OPTIONS]) :- TEST-BODY.'
   
where NAME is a ground term and OPTIONS is a list describing additional
properties of the test.  Here is a very simple example:

     :- begin_tests(lists).
     :- use_module(library(lists)).

     test(reverse) :-
             reverse([a,b], [b,a]).

     :- end_tests(lists).

   The optional second argument of the unit test declaration as well as
of the individual test-heads defines additional processing options.
The following options are available:

`blocked(REASON)'
     The test is currently disabled.   Tests are flagged as blocked if
     they cannot be run for some reason.  E.g. they crash Prolog, they
     rely on some service that is not available, they take too much
     resources, etc.  Tests that fail but don't crash, etc. should be
     flagged using `fixme(FIXME)'.  REASON should be an atom.

`fixme(REASON)'
     Similar to `blocked(FIXME)', but the test it executed anyway.  A
     summary is printed at the end of the test run.  REASON should be
     an atom.

`condition(GOAL)'
     Pre-condition for running the test.  If the condition fails, the
     test is skipped.  The condition can be used as an alternative to
     the `setup' option.  The only difference is that failure of a
     condition skips the test and is considered an error when using the
     `setup' option.  GOAL should be a callable.

`nondet'
     Available for individual test rules only.  Unless this keyword
     appears in the option list, nondeterminate success of the
     test-body is considered an error.

`forall(GENERATOR)'
     Available for individual test rules only.  Runs the same test for
     each solution of GENERATOR. Each run invokes the `setup' and
     `cleanup' handlers. This can be used to run the same test with
     different inputs.  If an error occurs, the test is reported as
     `name (forall bindings = VARS)', where VARS indicates the bindings
     of variables in GENERATOR, which should be a callable.

`setup(GOAL)'
     GOAL is run before the test-body.  Typically used together with
     the `cleanup' option to create and destroy the required execution
     environment.  GOAL should be a callable.

`cleanup(GOAL)'
     GOAL is always called after completion of the test-body,
     regardless of whether it fails, succeeds or raises an exception.
     This option or call_cleanup/2 must be used by tests that require
     side-effects that must be reverted after the test completes.  GOAL
     may share variables with a setup option and should be a callable:

     :- use_module(library(file_systems)).

     create_file(Tmp) :-
             open(temp(plunit), write, Out, [if_exists(generate_unique_name)]),
             current_stream(Tmp, write, Out),
             portray_clause(Out, hello(_World)),
             close(Out).

     test(read, [setup(create_file(Tmp)), cleanup(delete_file(Tmp))]) :-
             see(Tmp),
             read(Term),
             seen,
             Term = hello(_).

   The following options specify how to verify the result of the
test-body, and are only available for individual test rules. It is not
meaningful to specify more than one of them:

`true'
`true(TEST)'
     The test-body as well as the goal TEST must succeed.  TEST
     defaults to `true' and should be a callable that typically shares
     variables with the test-body. This is the same as inserting the
     test at the end of the conjunction, but makes the test harness
     print a "wrong answer" message as opposed to a general failure
     message:

          test(badadd, [true(A =:= 4)]) :-
                  A is 1 + 2.

     will yield the error message:

          ! /home/matsc/sicstus4/doc/foo.pl:11:
          !       test badadd: wrong answer (compared using =:=)
          !     Expected: 4
          !     Got:      3

`all(ANSWERTERM CMP INSTANCES)'
     Similar to `true(ANSWERTERM CMP INSTANCES)', but used if you want
     to collect all solutions to a nondeterminate test.  ANSWERTERM
     should share variables with the test-body.  Let ALL be the list of
     instances of ANSWERTERM for each solution.  Then the goal
     `CMP(ALL,INSTANCES)' must succeed.  The tests in the example below
     are equivalent:

          test(all1, all(X == [1,2])) :-
                  (X = 1 ; X = 2).

          test(all2, true(Xs == [1,2])) :-
                  findall(X, (X = 1 ; X = 2), Xs).

`set(ANSWERTERM CMP INSTANCES)'
     Similar to `all(ANSWERTERM CMP INSTANCES)', but sorts the
     ANSWERTERM instances before the comparison.  The tests in the
     example below are equivalent:

          test(set1, set(X == [1,2])) :-
                  (X = 2 ; X = 1 ; X = 1).

          test(set2, true(Ys == [1,2])) :-
                  findall(X, (X = 2 ; X = 1 ; X = 1), Xs),
                  sort(Xs, Ys).

`fail'
     The test-body must fail.

`exception(EXPECTED)'
`throws(EXPECTED)'
     The test-body must raise an exception RAISED that is checked wrt.
     EXPECTED using `terms:subsumeschk(EXPECTED, RAISED)'.  I.e. the
     raised exception must be more specific than the specified EXPECTED.

`error(ISO)'
`error(ISO,INFO)'
     A shorthand for `exception(error(ISO,INFO))'.  INFO defaults to an
     anonymous variable.

10.46.3 Writing the Test-Body
-----------------------------

* Menu:

* PlUnit Determinate Tests:: Determinate Tests
* PlUnit Nondeterminate Tests:: Nondeterminate Tests
* PlUnit Tests Expected to Fail:: Tests Expected to Fail
* PlUnit Tests Expected to Raise Exceptions:: Tests Expected to Raise Exceptions

   The test-body is ordinary Prolog code. Without any options, the
test-body must be designed to succeed _determinately_. Any other result
is considered a failure. One of the options `fail', `true', `exception'
or `error' can be used to specify a different expected result. In this
subsection we illustrate typical test-scenarios by testing built-in and
library predicates.


File: sicstus.info,  Node: PlUnit Determinate Tests,  Next: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.46.3.1 Determinate Tests
...........................

Determinate tests are tests that must succeed exactly once, leaving no
choicepoints behind. The test-body supplies proper values for the input
arguments and verifies the output arguments. Verification can use
test-options or be explicit in the test-body.  The tests in the example
below are equivalent.

     test(add1) :-
             A is 1 + 2,
             A =:= 3.

     test(add2, [true(A =:= 3)]) :-
             A is 1 + 2.

   The test engine verifies that the test-body does not leave a
choicepoint.  We illustrate this using the test below:

     test(member1) :-
             member(b, [a,b,c]).

   Although this test succeeds, `member/2' leaves a choicepoint behind,
which is reported by the test harness.  To make the test silent, use
one of the alternatives below.

     test(member2) :-
             memberchk(b, [a,b,c]).

     test(member3) :-
             member(b, [a,b,c]), !.

     test(member4, [nondet]) :-
             member(b, [a,b,c]).


File: sicstus.info,  Node: PlUnit Nondeterminate Tests,  Next: PlUnit Tests Expected to Fail,  Prev: PlUnit Determinate Tests,  Up: PlUnit A Unit Test Box

10.46.3.2 Nondeterminate Tests
..............................

Nondeterminate tests succeed zero or more times.  Their results can be
tested using `findall/3' followed by a value-check.  The following are
equivalent tests:

     test(member5) :-
             findall(X, member(X, [a,b,c]), Xs),
             Xs == [a,b,c].

     test(member6, true(Xs == [a,b,c])) :-
             findall(X, member(X, [a,b,c]), Xs).


File: sicstus.info,  Node: PlUnit Tests Expected to Fail,  Next: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.46.3.3 Tests Expected to Fail
................................

Tests that are expected to fail may be specified using the option
`fail' or by negating the test-body using `\+'.

     test(is_set) :-
             \+ is_set([a,a]).

     test(is_set, [fail]) :-
             is_set([a,a]).


File: sicstus.info,  Node: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Tests Expected to Fail,  Up: PlUnit A Unit Test Box

10.46.3.4 Tests Expected to Raise Exceptions
............................................

Tests that are expected to raise exceptions may be specified using the
option `exception(EXPECTED)' or one of its equivalents, or by wrapping
the test in `on_exception/3' or `catch/3'.  The following tests are
equivalent:

     :- use_module(library(terms)).
     test(div01) :-
          on_exception(Excp, A is 1/0, true),
          subsumeschk(error(evaluation_error(zero_divisor),_), Excp).

     test(div02, [error(evaluation_error(zero_divisor))]) :-
          A is 1/0.

     test(div03, [error(evaluation_error(zero_divisor),_)]) :-
          A is 1/0.

     test(div04, [exception(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.

     test(div05, [throws(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.


File: sicstus.info,  Node: PlUnit Running the Test-Suite,  Next: PlUnit Tests and Production Systems,  Prev: PlUnit A Unit Test Box,  Up: lib-plunit

10.46.4 Running the Test-Suite
------------------------------

At any time, the tests can be executed by loading the program and
running `run_tests/[0,1,2]':

`run_tests'
     Run all individual tests of all test-units.

`run_tests(SPEC)'
`run_tests(SPEC,OPTIONS)'
     Run only the specified tests.  The options `quiet' and `verbose'
     (the default) are available; see below.  SPEC should be one of:

        * a term UNIT where UNIT is the name of a test-unit, denotes
          all individual tests of the test-unit UNIT, or

        * a term UNIT:TEST where UNIT is the name of a test-unit and
          TEST is one of its individual tests, denotes the given test
          only, or

        * a term UNIT:LIST where UNIT is the name of a test-unit and
          LIST is a list of its individual tests, denotes the given
          list of tests, or

        * finally, a list of terms of one of the above forms.

   Running single tests is particularly useful for tracing a test, e.g.:

     | ?- trace, run_tests(lists:member).

   `run_tests/[0,1,2]' prints a report during execution.  The `quiet'
options suppresses informational messages; in its absence, messages are
printed in full as follows.

   First, each test-unit report begins with a header:

     `% PL-Unit: UNIT'

   Then comes a message (success or failure) for all specified tests not
marked as `blocked' or `fixme'.  Success messages are informational;
others are error or warning messages. Any errors encountered while
executing options are also reported.  To close the test-unit, a footer
is printed:

     `% done'

   After all test-units, a summary report is printed, stating:

   * how many tests passed resp. failed

   * which tests were blocked

   * details for each test marked as `fixme'


File: sicstus.info,  Node: PlUnit Tests and Production Systems,  Prev: PlUnit Running the Test-Suite,  Up: lib-plunit

10.46.5 Tests and Production Systems
------------------------------------

Most applications don't want the test-suite to end up in the final
application.  There are several ways to achieve this.  One way is to
place all tests in separate files and not to load the tests when
creating the production environment.  Another way is to wrap each unit
test box in a pair of `:- if(...)', `:- endif' directives.  For
example, the test could be whether the `plunit' module has been loaded:

     :- if(current_module(plunit)).
     :- begin_tests(UNIT[,OPTIONS]).
     ...
     :- end_tests(UNIT).
     :- endif.

   Alternatively, you can reserve a system property e.g.
`enable_unit_tests' to control whether unit tests should be enabled.
The property is enabled if you run SICStus Prolog as:

     % sicstus -Denable_unit_tests=true

   Then your Prolog source file could have the structure:

     :- use_module(library(system), [environ/2]).

     ...

     :- if(environ(enable_unit_tests, true)).
     :- use_module(library(plunit)).
     :- begin_tests(UNIT[,OPTIONS])
     ...
     :- end_tests(UNIT)
     :- endif.


File: sicstus.info,  Node: Prolog Reference Pages,  Next: C Reference Pages,  Prev: The Prolog Library,  Up: Top

11 Prolog Reference Pages
*************************

* Menu:

* mpg-ref::                             Reading the Reference Pages
* mpg-top::                             Topical List of Prolog Built-Ins
* mpg-bpr::                             Built-In Predicates


File: sicstus.info,  Node: mpg-ref,  Next: mpg-top,  Up: Prolog Reference Pages

11.1 Reading the Reference Pages
================================

* Menu:

* mpg-ref-ove::                         Overview
* mpg-ref-mod::                         Mode Annotations
* mpg-ref-cat::                         Predicate Annotations
* mpg-ref-aty::                         Argument Types
* mpg-ref-exc::                         Exceptions
* mpg-ref-oth::                         Other Fields


File: sicstus.info,  Node: mpg-ref-ove,  Next: mpg-ref-mod,  Up: mpg-ref

11.1.1 Overview
---------------

The reference pages for SICStus Prolog built-in predicates conform to
certain conventions concerning
   * mode annotations

   * predicate annotations

   * argument types

   These are particularly important in utilizing the Synopsis and
Arguments fields of each reference page.  The Synopsis field consists
of the goal template(s) with mode annotations and a brief description
of the purpose of the predicate.  For example, consider this excerpt
from the reference page for `assert/[1,2]':

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   `assert(+CLAUSE)'

   `assert(+CLAUSE, -REF)'

   It is undefined whether CLAUSE will precede or follow the clauses
already in the database.

   The Arguments field lists, for each meta-variable name in the
template, its argument type, (e.g. "callable"), a brief description
(sometimes omitted), and an indication (`:') if it does module name
expansion.  For example,

Arguments
---------

:CLAUSE
     "callable" A valid dynamic Prolog clause.

REF
     "db_reference" a database reference, which uniquely identifies the
     newly asserted CLAUSE.


File: sicstus.info,  Node: mpg-ref-mod,  Next: mpg-ref-cat,  Prev: mpg-ref-ove,  Up: mpg-ref

11.1.2 Mode Annotations
-----------------------

The mode annotations are useful to tell whether an argument is input or
output or both. They also describe formally the instantiation pattern
to the call that makes the call to the built-ins determinate.

   The mode annotations in the above example are `+' and `-'.
Following is a complete description of the mode annotations you will
find in the reference pages:

`+'
     Input argument. This argument will be inspected by the predicate,
     and affects the behavior of the predicate. An exception is raised
     if the argument isn't of the expected type. Note that an input
     argument can be an unbound variable in some cases.

`-'
     Output argument. This argument is unified with the output value of
     the predicate. An output argument is only tested to be of the same
     type as the possible output value if this is prescribed by the ISO
     standard, or if such testing is deemed helpful to the user.

`?'
     An argument that could be either input or output. This mode
     annotation is normally only used for predicates that behave as
     pure relations and don't type test their arguments.


   If the synopsis of a predicate has more than one mode declaration,
the first (the topmost) that satisfies the types (of a goal instance) is
the one to be applied (to that goal instance).

   All built-in predicates of arity zero are determinate (with the
exception of `repeat/0').

   For _input_ arguments, an exception _will_ be raised if the argument
isn't of the specified type.

   For _output_ arguments, an exception _might_ be raised if the
argument is "nonvar", and not of the specified type. The generated
_value_ of the argument _will_ be of the specified type.


File: sicstus.info,  Node: mpg-ref-cat,  Next: mpg-ref-aty,  Prev: mpg-ref-mod,  Up: mpg-ref

11.1.3 Predicate Annotation
---------------------------

This section describes the annotations of predicates and how they are
indicated in the reference pages for predicates of each given
annotation.  The annotations appear to the right of the title of the
reference page.

"hookable"
     The behavior of the predicate can be customized/redefined by
     defining one or more hooks.  The mode and type annotations of a
     hookable predicate might not be absolute, since hooks added by the
     user can change the behavior.

"hook"
     The predicate is user defined, and is called by a "hookable"
     builtin. Most hooks must be defined in module `user'. For a hook,
     the mode and type annotations should be seen as guide-lines to the
     user who wants to add his own hook; they describe how the
     predicate is used by the system.

"extendible"
     A multifile predicate, to which new clauses can be added by the
     user. For such a predicate, the mode and type annotations should
     be seen as guide-lines to the user who wants to extend the
     predicate; they describe how the predicate is used by the system.

"declaration"
     You cannot call these directly but they can appear in files as `:-
     DECLARATION' and give information to the compiler.  The goal
     template is preceded by `:-' in the Synopsis.

"development"
     A predicate that is defined in the development system only, i.e.
     not in runtime systems.

"ISO"
     A predicate that is part of the ISO Prolog Standard.

"deprecated"
     A predicate that is not recommended in new code and that could be
     withdrawn in a future release.

   "Meta-predicates" and "operators" are recognizable by the implicit
conventions described below.

   * "Meta-predicates" are predicates that need to assume some module.
     The reference pages of these predicates indicate which arguments
     are in a module expansion position by prefixing such arguments by
     `:' in the Arguments field.  That is, the argument can be preceded
     by a module prefix (an "atom" followed by a colon).  For example:
          assert(mod:a(1), Ref)
     If no module prefix is supplied, it will implicitly be set to the
     calling module.  If the module prefix is a variable, an
     instantiation error will be raised.  If it is not an atom a type
     error will be raised.  So in any meta-predicate reference page the
     following exceptions are implicit:

Exceptions
----------

    `instantiation_error'
          A module prefix is written as a variable.

    `type_error'
          A module prefix is not an atom.

   * Whenever the name of a built-in predicate is defined as
     "operator", the name is presented in the Synopsis as an operator,
     for example
          `:- initialization' +GOAL                   (A)
          +TERM1 `@>' +TERM2               (B)

     It is thus always possible to see if a name is an operator or not.
     The predicate can, of course, be written using the canonical
     representation, even when the name is an operator.  Thus (A) and
     (B) can be written as (C) and (D), respectively:
          `:- initialization(+GOAL)'                   (C)
          `@>'(+TERM1,  +TERM2)                 (D)



File: sicstus.info,  Node: mpg-ref-aty,  Next: mpg-ref-exc,  Prev: mpg-ref-cat,  Up: mpg-ref

11.1.4 Argument Types
---------------------

* Menu:

* mpg-ref-aty-sim::                     Simple Types
* mpg-ref-aty-ety::                     Extended Types

   The argument section describes the type/domain of each argument of a
_solution_ to the given predicate. That is, for a predicate to succeed,
it must be possible to instantiate the given argument to a term of the
described type/domain.

   If it is a `+' argument, the predicate always tests if the argument
is of the right type/domain. Usually, input arguments must also be
instantiated to some extent. Such details are documented for each input
argument.

   Many built-in and library predicates take an +OPTIONS argument,
which must be given as a proper list of terms specifying what the
predicate should do, typically as the last argument.  As a general rule
for such option lists, if the same option occurs more than once, the
last occurrence overrides previous ones.


File: sicstus.info,  Node: mpg-ref-aty-sim,  Next: mpg-ref-aty-ety,  Up: mpg-ref-aty

11.1.4.1 Simple Types
.....................

The simple argument types are those for which type tests are provided.
They are summarized in *note mpg-top-typ::.

   If an output argument is given the type "var", it means that that
argument is not used by the predicate in the given instantiation
pattern.


File: sicstus.info,  Node: mpg-ref-aty-ety,  Prev: mpg-ref-aty-sim,  Up: mpg-ref-aty

11.1.4.2 Extended Types
.......................

Following is a list of argument types that are defined in terms of the
simple argument types. This is a formal description of the
types/domains used in the Arguments sections of the reference pages for
the built-ins. The rules are given in BNF (Backus-Naur form).

STREAM_OBJECT      ::= TERM {as defined in *note ref-iou-sfh-sob::}

TERM               ::= {any Prolog term}

LIST OF TYPE       ::= `[]' | `[TYPE|LIST OF TYPE]'

VAR OR TYPE        ::= VAR | TYPE

ONE OF             ::= ELEMENT | ONE OF REST
[ELEMENT|REST]     

ARITY              ::= {an INTEGER X in the range 0..255}

BYTE               ::= {an INTEGER X in the range 0..255}

CHAR               ::= {an ATOM consisting of a single character}

CHARS              ::= LIST OF CHAR

CODE               ::= {an INTEGER X >= 0}

CODES              ::= LIST OF CODE

ORDER              ::= {an ATOM, one of `[<,=,>]'}

PAIR               ::= `TERM-TERM'

SIMPLE_PRED_SPEC   ::= `ATOM/ARITY'

PRED_SPEC          ::= SIMPLE_PRED_SPEC | `ATOM:PRED_SPEC'

PRED_SPEC_FOREST   ::= `[]' | PRED_SPEC
                   | `[PRED_SPEC_FOREST|PRED_SPEC_FOREST]'
                   | `PRED_SPEC_FOREST,PRED_SPEC_FOREST'

PRED_SPEC_TREE     ::= PRED_SPEC | LIST OF PRED_SPEC

FOREIGN_SPEC       ::= CALLABLE {all arguments being FOREIGN_ARG}

FOREIGN_ARG        ::= `+INTERF_ARG_TYPE' | `-INTERF_ARG_TYPE' |
                   `[-INTERF_ARG_TYPE]'

INTERF_ARG_TYPE    ::= `integer' | `float' | `atom'
                   | `term' | `codes' | `string' | `address' |
                   `address(ATOM)'
                   {see the description in *note Conversions between
                   Prolog Arguments and C Types::}

FILE_SPEC          ::= ATOM | `ATOM(FILE_SPEC)'

EXPR               ::= {everything that is accepted as second argument
                   to `is/2';
                   see the description of arithmetic expressions in
                   *note ref-ari-aex::.}


File: sicstus.info,  Node: mpg-ref-exc,  Next: mpg-ref-oth,  Prev: mpg-ref-aty,  Up: mpg-ref

11.1.5 Exceptions
-----------------

The Exceptions field of the reference page consists of a list of
exception type names, each followed by a brief description of the
situation that causes that type of exception to be raised.  The
following example comes from the reference page for `assert/[1,2]':

Exceptions
----------

`instantiation_error'
     If HEAD (in CLAUSE) or M is uninstantiated.

`type_error'
     If HEAD is not of type callable, or if M is not an atom, or if
     BODY is not a valid clause body.

   For _input_ arguments, an exception _will_ be raised if the argument
isn't of the specified type.

   For _output_ arguments, an exception _might_ be raised if the
argument is "nonvar", and not of the specified type. The generated
_value_ of the argument _will_ be of the specified type.


File: sicstus.info,  Node: mpg-ref-oth,  Prev: mpg-ref-exc,  Up: mpg-ref

11.1.6 Other Fields
-------------------

The Backtracking field, if included, describes how the predicate
behaves on backtracking. If this field is omitted, the predicate is
determinate (succeeds at most once).

   The See Also field contains cross references to related predicates
and/or manual sections.

   Reference pages may also include Comments,  Examples, and Tips
fields, when appropriate.


File: sicstus.info,  Node: mpg-top,  Next: mpg-bpr,  Prev: mpg-ref,  Up: Prolog Reference Pages

11.2 Topical List of Prolog Built-Ins
=====================================

* Menu:

* mpg-top-all::                         All Solutions
* mpg-top-ari::                         Arithmetic
* mpg-top-cio::                         Character I/O
* mpg-top-con::                         Control
* mpg-top-dat::                         Database
* mpg-top-deb::                         Debugging
* mpg-top-est::                         Errors and Exceptions
* mpg-top-fnm::                         Filename Manipulation
* mpg-top-fsh::                         File and Stream Handling
* mpg-top-fin::                         Foreign Interface
* mpg-top-gru::                         Grammar Rules
* mpg-top-hok::                         Hook Predicates
* mpg-top-lis::                         List Processing
* mpg-top-lod::                         Loading Programs
* mpg-top-mem::                         Memory
* mpg-top-msg::                         Messages and Queries
* mpg-top-mod::                         Modules
* mpg-top-sta::                         Program State
* mpg-top-eqs::                         Saving Programs
* mpg-top-tcm::                         Term Comparison
* mpg-top-tha::                         Term Handling
* mpg-top-tio::                         Term I/O
* mpg-top-typ::                         Type Tests

   Following is a complete list of SICStus Prolog built-in predicates,
arranged by topic.  A predicate may be included in more than one list.


File: sicstus.info,  Node: mpg-top-all,  Next: mpg-top-ari,  Up: mpg-top

11.2.1 All Solutions
--------------------

`?X ^ :P'
     there exists an X such that P is provable (used in `setof/3' and
     `bagof/3')

`bagof(?X,:P,-B)   "ISO"'
     B is the bag of instances of X such that P is provable

`findall(?T,:G,-L)   "ISO"'
`findall(?T,:G,?L,?R)'
     L is the list of all solutions T for the goal G, concatenated with
     R or with the empty list

`setof(?X,:P,-S)   "ISO"'
     S is the set of instances of X such that P is provable



File: sicstus.info,  Node: mpg-top-ari,  Next: mpg-top-cio,  Prev: mpg-top-all,  Up: mpg-top

11.2.2 Arithmetic
-----------------

`-Y is +X   "ISO"'
     Y is the value of arithmetic expression X

`+X =:= +Y   "ISO"'
     the results of evaluating terms X and Y as arithmetic expressions
     are equal.

`+X =\= +Y   "ISO"'
     the results of evaluating terms X and Y as arithmetic expressions
     are not equal.

`+X < +Y   "ISO"'
     the result of evaluating X as an arithmetic expression is less
     than the result of evaluating Y as an arithmetic expression.

`+X >= +Y   "ISO"'
     the result of evaluating X as an arithmetic expression is not less
     than the result of evaluating Y as an arithmetic expression.

`+X > +Y   "ISO"'
     the result of evaluating X as an arithmetic expression X is
     greater than the result of evaluating Y as an arithmetic
     expression.

`+X =< +Y   "ISO"'
     the result of evaluating X as an arithmetic expression is not
     greater than the result of evaluating Y as an arithmetic
     expression.


File: sicstus.info,  Node: mpg-top-cio,  Next: mpg-top-con,  Prev: mpg-top-ari,  Up: mpg-top

11.2.3 Character I/O
--------------------

`at_end_of_line'
`at_end_of_line(+S)'
     testing whether at end of line on input stream S

`at_end_of_stream   "ISO"'
`at_end_of_stream(+S)   "ISO"'
     testing whether end of file is reached for the input stream S

`flush_output   "ISO"'
`flush_output(+S)   "ISO"'
     flush the output buffer for stream S

`get_byte(-C)   "ISO"'
`get_byte(+S,-C)   "ISO"'
     C is the next byte on binary input stream S

`get_char(-C)   "ISO"'
`get_char(+S,-C)   "ISO"'
     C is the next character atom on text input stream S

`get_code(-C)   "ISO"'
`get_code(+S,-C)   "ISO"'
     C is the next character code on text input stream S

`nl           "ISO"'
`nl(+S)   "ISO"'
     send a newline to stream S

`peek_byte(+C)   "ISO"'
`peek_byte(+S,+C)   "ISO"'
     looks ahead for next input byte on the binary input stream S

`peek_char(+C)   "ISO"'
`peek_char(+S,+C)   "ISO"'
     looks ahead for next input character atom on the text input stream
     S

`peek_code(+C)   "ISO"'
`peek_code(+S,+C)   "ISO"'
     looks ahead for next input character code on the text input stream
     S

`put_byte(+C)   "ISO"'
`put_byte(+S,+C)   "ISO"'
     write byte C to binary stream S

`put_char(+C)   "ISO"'
`put_char(+S,+C)   "ISO"'
     write character atom C to text stream S

`put_code(+C)   "ISO"'
`put_code(+S,+C)   "ISO"'
     write character code C to text stream S

`skip_byte(+C)'
`skip_byte(+S,+C)'
     skip input on binary stream S until after byte C

`skip_char(+C)'
`skip_char(+S,+C)'
     skip input on text stream S until after char C

`skip_code(+C)'
`skip_code(+S,+C)'
     skip input on text stream S until after code C

`skip_line'
`skip_line(+S)'
     skip the rest input characters of the current line (record) on the
     input stream S



File: sicstus.info,  Node: mpg-top-con,  Next: mpg-top-dat,  Prev: mpg-top-cio,  Up: mpg-top

11.2.4 Control
--------------

`:P,:Q           "ISO"'
     prove P and Q

`:P;:Q           "ISO"'
     prove P or Q

`+M::P           "ISO"'
     call P in module M

`:P->:Q;:R           "ISO"'
     if P succeeds, prove Q; if not, prove R

`:P->:Q           "ISO"'
     if P succeeds, prove Q; if not, fail

`!           "ISO"'
     cut any choices taken in the current procedure

`\+ :P           "ISO"'
     goal P is not provable

`?X ^ :P'
     there exists an X such that P is provable (used in `setof/3' and
     `bagof/3')

`block :P   "declaration"'
     declaration that predicates specified by P should block until
     sufficiently instantiated

`call(:P)   "ISO"'
`call(:P,...)'
     execute P or `P(...)'

`call_cleanup(:GOAL,:CLEANUP)'
     Executes the procedure call GOAL.  When GOAL succeeds
     determinately, is cut, fails, or raises an exception, CLEANUP is
     executed.

`call_residue_vars(:GOAL,?VARS)'
     Executes the procedure call GOAL.  VARS is unified with the list
     of new variables created during the call that remain unbound and
     have blocked goals or attributes attached to them.

`+ITERATORS do :BODY'
     executes BODY iteratively according to ITERATORS

`fail           "ISO"'
     fail (start backtracking)

`false'
     same as `fail'

`freeze(+VAR,:GOAL)'
     Blocks GOAL until `nonvar(VAR)' holds.

`if(:P,:Q,:R)'
     for each solution of P that succeeds, prove Q; if none, prove R

`once(:P)           "ISO"'
     Find the first solution, if any, of goal P.

`otherwise'
     same as true

`repeat           "ISO"'
     succeed repeatedly on backtracking

`true           "ISO"'
     succeed

`when(+COND,:GOAL)'
     block GOAL until COND holds



File: sicstus.info,  Node: mpg-top-dat,  Next: mpg-top-deb,  Prev: mpg-top-con,  Up: mpg-top

11.2.5 Database
---------------

`abolish(:F)   "ISO"'
     abolish the predicate(s) specified by F

`abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

`assert(:C)'
`assert(:C,-R)'
     clause C is asserted; reference R is returned

`asserta(:C)   "ISO"'
`asserta(:C,-R)'
     clause C is asserted before existing clauses; reference R is
     returned

`assertz(:C)   "ISO"'
`assertz(:C,-R)'
     clause C is asserted after existing clauses; reference R is
     returned

`bb_delete(:KEY,-TERM)'
     Delete from the blackboard TERM stored under KEY.

`bb_get(:KEY,-TERM)'
     Get from the blackboard TERM stored under KEY.

`bb_put(:KEY,+TERM)'
     Store TERM under KEY on the blackboard.

`bb_update(:KEY, -OLDTERM, +NEWTERM)'
     Replace OLDTERM by NEWTERM under KEY on the blackboard.

`clause(:P,?Q)   "ISO"'
`clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

`current_key(?N, ?K)'
     N is the name and K is the key of a recorded term

`dynamic :P   "ISO,declaration"'
     predicates specified by P are dynamic

`erase(+R)'
     erase the clause or record with reference R

`instance(+R,-T)'
     T is an instance of the clause or term referenced by R

`recorda(+K,+T,-R)'
     make term T the first record under key K; reference R is returned

`recorded(?K,?T,?R)'
     term T is recorded under key K with reference R

`recordz(+K,+T,-R)'
     make term T the last record under key K; reference R is returned

`retract(:C)   "ISO"'
     erase the first dynamic clause that matches C

`retractall(:H)'
     erase every clause whose head matches H


File: sicstus.info,  Node: mpg-top-deb,  Next: mpg-top-est,  Prev: mpg-top-dat,  Up: mpg-top

11.2.6 Debugging
----------------

`add_breakpoint(+CONDITIONS, -BID)   "development"'
     Creates a breakpoint with CONDITIONS and with identifier BID.

`user:breakpoint_expansion(+MACRO, -BODY)   "hook,development"'
     defines debugger condition macros

`coverage_data(?DATA)   "since release 4.2,development"'
     DATA is the coverage data accumulated so far

`current_breakpoint(?CONDITIONS, ?BID, ?STATUS, ?KIND, ?TYPE)   "development"'
     There is a breakpoint with conditions CONDITIONS, identifier BID,
     enabledness STATUS, kind KIND, and type TYPE.

`debug   "development"'
     switch on debugging

`user:debugger_command_hook(+DCOMMAND,-ACTIONS)   "hook,development"'
     Allows the interactive debugger to be extended with user-defined
     commands.

`debugging   "development"'
     display debugging status information

`disable_breakpoints(+BIDS)   "development"'
     Disables the breakpoints specified by BIDS.

`enable_breakpoints(+BIDS)   "development"'
     Enables the breakpoints specified by BIDS.

`user:error_exception(+EXCEPTION)   "hook"'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

`execution_state(+TESTS)   "development"'
     TESTS are satisfied in the current state of the execution.

`execution_state(+FOCUSCONDITIONS, +TESTS)   "development"'
     TESTS are satisfied in the state of the execution pointed to by
     FOCUSCONDITIONS.

`leash(+M)   "development"'
     set the debugger's leashing mode to M

`nodebug   "development"'
     switch off debugging

`nospy(:P)   "development"'
     remove spypoints from the procedure(s) specified by P

`nospyall   "development"'
     remove all spypoints

`notrace   "development"'
     switch off debugging (same as `nodebug/0')

`nozip   "development"'
     switch off debugging (same as `nodebug/0')

`print_coverage   "since release 4.2,development"'
`print_coverage(?DATA)   "since release 4.2,development"'
     The coverage data DATA is displayed in a hierarchical format.
     DATA defaults to the coverage data accumulated so far.

`print_profile   "since release 4.2,development"'
`print_profile(?DATA)   "since release 4.2,development"'
     The profiling data DATA is displayed in a format similar to
     `gprof(1)'.  DATA defaults to the profiling data accumulated so
     far.

`profile_data(?DATA)   "since release 4.2,development"'
     DATA is the profiling data accumulated so far

`profile_reset   "since release 4.2,development"'
     All profiling data is reset.

`remove_breakpoints(+BIDS)   "development"'
     Removes the breakpoints specified by BIDS.

`spy(:P)   "development"'
`spy(:P,:C)'
     set spypoints on the procedure(s) specified by P with conditions C

`trace   "development"'
     switch on debugging and start tracing immediately

`unknown(-O,+N)   "development"'
     Changes action on undefined predicates from O to N.

`user:unknown_predicate_handler(+G,+M,-N)   "hook"'
     handle for unknown predicates.

`zip   "development"'
     switch on debugging in zip mode



File: sicstus.info,  Node: mpg-top-est,  Next: mpg-top-fnm,  Prev: mpg-top-deb,  Up: mpg-top

11.2.7 Errors and Exceptions
----------------------------

`abort'
     abort execution of the program; return to current break level

`break'
     start a new break-level to interpret commands from the user

`catch(:P,?E,:H)   "ISO"'
     specify a handler H for any exception E arising in the execution
     of the goal P

`user:error_exception(+EXCEPTION)   "hook,development"'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

`halt   "ISO"'
`halt(C)   "ISO"'
     exit from Prolog with exit code C

`on_exception(?E,:P,:H)'
     specify a handler H for any exception E arising in the execution
     of the goal P

`raise_exception(+E)'
     raise exception E

`throw(+E)   "ISO"'
     raise exception E

`unknown(?OLDVALUE, ?NEWVALUE)   "development"'
     access the `unknown' Prolog flag and print a message

`user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)   "hook"'
     tell Prolog to call `MODULE:NEWGOAL' if `MODULE:GOAL' is undefined



File: sicstus.info,  Node: mpg-top-fnm,  Next: mpg-top-fsh,  Prev: mpg-top-est,  Up: mpg-top

11.2.8 Filename Manipulation
----------------------------

`absolute_file_name(+R,-A)   "hookable"'
`absolute_file_name(+R,-A,+O)   "hookable"'
     expand relative filename R to absolute file name A using options
     specified in O

`user:file_search_path(+F,-D)   "hook"'
     directory D is included in file search path F

`user:library_directory(-D)   "hook"'
     D is a library directory that will be searched


File: sicstus.info,  Node: mpg-top-fsh,  Next: mpg-top-fin,  Prev: mpg-top-fnm,  Up: mpg-top

11.2.9 File and Stream Handling
-------------------------------

`byte_count(+S,-N)'
     N is the number of bytes read/written on binary stream S

`character_count(+S,-N)'
     N is the number of characters read/written on text stream S

`close(+F)   "ISO"'
`close(+F,+O)   "ISO"'
     close file or stream F with options O

`current_input(-S)   "ISO"'
     S is the current input stream

`current_output(-S)   "ISO"'
     S is the current output stream

`current_stream(?F,?M,?S)'
     S is a stream open on file F in mode M

`line_count(+S,-N)'
     N is the number of lines read/written on text stream S

`line_position(+S,-N)'
     N is the number of characters read/written on the current line of
     text stream S

`open(+F,+M,-S)   "ISO"'
`open(+F,+M,-S,+O)   "ISO"'
     file F is opened in mode M, options O, returning stream S

`open_null_stream(+S)'
     new output to text stream S goes nowhere

`prompt(-O,+N)'
     queries or changes the prompt string of the current input stream

`see(+F)'
     make file F the current input stream

`seeing(-N)'
     the current input stream is named N

`seek(+S,+O,+M,+N)'
     seek to an arbitrary byte position on the stream S

`seen'
     close the current input stream

`set_input(+S)   "ISO"'
     select S as the current input stream

`set_output(+S)   "ISO"'
     select S as the current output stream

`set_stream_position(+S,+P)   "ISO"'
     P is the new position of stream S

`stream_code(?S,?C)'
     Converts between Prolog and C representations of a stream

`stream_position(+S,-P)'
     P is the current position of stream S

`stream_position_data(?FIELD,?POSITION,?DATA)'
     The FIELD field of the stream position term POSITION is DATA.

`stream_property(?STREAM, ?PROPERTY))   "ISO"'
     Stream STREAM has property PROPERTY.

`tell(+F)'
     make file F the current output stream

`telling(-N)'
     to file N

`told'
     close the current output stream



File: sicstus.info,  Node: mpg-top-fin,  Next: mpg-top-gru,  Prev: mpg-top-fsh,  Up: mpg-top

11.2.10 Foreign Interface
-------------------------

`foreign(+F,-P)   "hook"'
`foreign(+F,-L,-P)   "hook"'
     function F in language L is attached to P

`foreign_resource(+R,-L)   "hook"'
     resource R defines foreign functions in list L

`load_foreign_resource(+R)   "hookable"'
     load foreign resource R

`stream_code(?S,?C)'
     Converts between Prolog and C representations of a stream

`unload_foreign_resource(+R)'
     unload foreign resource R



File: sicstus.info,  Node: mpg-top-gru,  Next: mpg-top-hok,  Prev: mpg-top-fin,  Up: mpg-top

11.2.11 Grammar Rules
---------------------

`:HEAD --> :BODY'
     A possible form for HEAD is BODY

`expand_term(+T,-X)   "hookable"'
     term T expands to term X using `user:term_expansion/6' or grammar
     rule expansion

`phrase(:P, -L)'
`phrase(:P, ?L, ?R)'
     R or the empty list is what remains of list L after phrase P has
     been found

`user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   "hook"'
     Overrides or complements the standard transformations to be done by
     `expand_term/2'.



File: sicstus.info,  Node: mpg-top-hok,  Next: mpg-top-lis,  Prev: mpg-top-gru,  Up: mpg-top

11.2.12 Hook Predicates
-----------------------

`user:breakpoint_expansion(+MACRO, -BODY)   "hook,development"'
     defines debugger condition macros

`user:debugger_command_hook(+DCOMMAND,-ACTIONS)   "hook,development"'
     Allows the interactive debugger to be extended with user-defined
     commands.

`user:error_exception(=EXCEPTION)   "hook"'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

`user:file_search_path(+F,-D)   "hook"'
     directory D is included in file search path F

`foreign(+F,-P)'
`foreign(+F,-L,-P)'
     Describes the interface between Prolog and the foreign ROUTINE

`foreign_resource(+R,-L)'
     resource R defines foreign functions in list L

`user:generate_message_hook(+M,?S0,?S)   "hook"'
     A way for the user to override the call to
     `'SU_messages':generate_message/3' in `print_message/2'.

`goal_expansion(+TERM1, +LAYOUT1, +MODULE, -TERM2, -LAYOUT2)   "hook"'
     Defines transformations on goals while clauses are being compiled
     or asserted, and during meta-calls.

`user:library_directory(-D)   "hook"'
     D is a library directory that will be searched

`user:message_hook(+S,+M,+L)   "hook"'
     Overrides the call to `print_message_lines/3' in `print_message/2'.

`user:portray(+T)'
     A way for the user to over-ride the default behavior of `print/1'.

`user:portray_message(+S,+M)   "hook"'
     Tells `print_message/2' what to do.

`user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   "hook"'
     Called by `ask_query/4' before processing the query.  If this
     predicate succeeds, it is assumed that the query has been
     processed and nothing further is done.

`user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

`user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

`user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.

`user:runtime_entry(+M)   "hook"'
     This predicate is called upon start-up and exit of stand alone
     applications.

`user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   "hook"'
     Overrides or complements the standard transformations to be done by
     `expand_term/2'.

`user:unknown_predicate_handler(+G,+M,-N)   "hook"'
     hook to trap calls to unknown predicates



File: sicstus.info,  Node: mpg-top-lis,  Next: mpg-top-lod,  Prev: mpg-top-hok,  Up: mpg-top

11.2.13 List Processing
-----------------------

`?T =.. ?L   "ISO"'
     the functor and arguments of term T comprise the list L

`append(?A,?B,?C)'
     the list C is the concatenation of lists A and B

`keysort(+L,-S)'
     the list L sorted by key yields S

`length(?L,?N)'
     the length of list L is N

`member(?X,?L)'
     X is a member of L

`memberchk(+X,+L)'
     X is a member of L

`nonmember(+X,+L)'
     X is not a member of L

`sort(+L,-S)'
     sorting the list L into order yields S



File: sicstus.info,  Node: mpg-top-lod,  Next: mpg-top-mem,  Prev: mpg-top-lis,  Up: mpg-top

11.2.14 Loading Programs
------------------------

`[]'
`[:F|+FS]'
     same as `load_files([F|FS])'

`block :P   "declaration"'
     predicates specified by P should block until sufficiently
     instantiated

`compile(:F)'
     load compiled clauses from files F

`consult(:F)'
`reconsult(:F)'
     load interpreted clauses from files F

`expand_term(+T,-X)   "hookable"'
     term T expands to term X using `user:term_expansion/6' or grammar
     rule expansion

`goal_expansion(+TERM1, +LAYOUT1, +MODULE, -TERM2, -LAYOUT2)   "hook"'
     Defines transformations on goals while clauses are being compiled
     or asserted, and during meta-calls.

`discontiguous :P   "declaration,ISO"'
     clauses of predicates P don't have to appear contiguously

`dynamic :P   "declaration,ISO"'
     predicates specified by P are dynamic

`elif(:GOAL   "declaration"'
     Provides an alternative branch in a sequence of conditional
     compilation directives.

`else   "declaration"'
     Provides an alternative branch in a sequence of conditional
     compilation directives.

`endif   "declaration"'
     Terminates a sequence of conditional compilation directives.

`ensure_loaded(:F)   "ISO"'
     load F if not already loaded

`if(:GOAL)   "declaration"'
     Starts a sequence of conditional compilation directives for
     conditionally including parts of a source file.

`include(+F)   "declaration,ISO"'
     include the source file(s) F verbatim

`initialization :G   "declaration,ISO"'
     declares G to be run when program is started

`load_files(:F)'
`load_files(:F,+O)'
     load files according to options O

`meta_predicate :P   "declaration"'
     declares predicates P that are dependent on the module from which
     they are called

`mode :P   "declaration"'
     NO-OP: document calling modes for predicates specified by P

`module(+M,+L)   "declaration"'
`module(+M,+L,+O)   "declaration"'
     module M exports predicates in L, options O

`multifile :P   "declaration,ISO"'
     the clauses for P are in more than one file

`public :P   "declaration"'
     NO-OP: declare predicates specified by P public

`restore(+F)'
     restore the state saved in file F

`user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   "hook"'
     Overrides or complements the standard transformations to be done by
     `expand_term/2'.

`use_module(:F)'
`use_module(:F,+I)'
     import the procedure(s) I from the module-file F

`use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary

`volatile :P   "declaration"'
     predicates specified by P are not to be included in saves


File: sicstus.info,  Node: mpg-top-mem,  Next: mpg-top-msg,  Prev: mpg-top-lod,  Up: mpg-top

11.2.15 Memory
--------------

`garbage_collect'
     force an immediate garbage collection

`garbage_collect_atoms'
     garbage collect atom space

`statistics'
     display various execution statistics

`statistics(?K,?V)'
     the execution statistic with key K has value V

`trimcore'
     reduce free stack space to a minimum



File: sicstus.info,  Node: mpg-top-msg,  Next: mpg-top-mod,  Prev: mpg-top-mem,  Up: mpg-top

11.2.16 Messages and Queries
----------------------------

`ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)   "hookable"'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.

`user:message_hook(+M,+S,+L)   "hook"'
     intercept the printing of a message

`'SU_messages':generate_message(+M,?SO,?S)   "extendible"'
     determines the mapping from a message term into a sequence of
     lines of text to be printed

`user:generate_message_hook(+M,?S0,?S)   "hook"'
     intercept message before it is given to
     `'SU_messages':generate_message/3'

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

`user:portray_message(+SEVERITY,+MESSAGE)   "hook"'
     Tells `print_message/2' what to do.

`print_message(+S,+M)   "hookable"'
     print a message M of severity S

`print_message_lines(+S,+P,+L)'
     print the message lines L to stream S with prefix P

`'SU_messages':query_abbreviation(+T,-P)   "extendible"'
     specifies one letter abbreviations for responses to queries from
     the Prolog system

`user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   "hook"'
     Called by `ask_query/4' before processing the query.  If this
     predicate succeeds, it is assumed that the query has been
     processed and nothing further is done.

`'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   "extendible"'
     Access the parameters of a given QUERYCLASS.

`user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

`'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)   "extendible"'
     Implements the input phase of query processing.

`user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

`'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   "extendible"'
     Implements the mapping phase of query processing.

`user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.



File: sicstus.info,  Node: mpg-top-mod,  Next: mpg-top-sta,  Prev: mpg-top-msg,  Up: mpg-top

11.2.17 Modules
---------------

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

`meta_predicate :P   "declaration"'
     declares predicates P that are dependent on the module from which
     they are called

`module(+M,+L)   "declaration"'
`module(+M,+L,+O)   "declaration"'
     declaration that module M exports predicates in L, options O

`save_modules(+L,+F)'
     save the modules specifed in L into file F

`set_module(+M)'
     make M the type-in module

`use_module(:F)'
     import the module-file(s) F, loading them if necessary

`use_module(:F,+I)'
     import the procedure(s) I from the module-file F

`use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary



File: sicstus.info,  Node: mpg-top-sta,  Next: mpg-top-eqs,  Prev: mpg-top-mod,  Up: mpg-top

11.2.18 Program State
---------------------

`current_atom(?A)'
     backtrack through all atoms

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

`current_predicate(:A/?N)   "ISO"'
`current_predicate(?A,:P)'
     A is the name of a predicate with most general goal P and arity N

`current_prolog_flag(?F,?V)   "ISO"'
     V is the current value of Prolog flag F

`listing'
     list all dynamic procedures in the type-in module

`listing(:P)'
     list the dynamic procedure(s) specified by P

`predicate_property(:P,?PROP)'
     PROP is a property of the loaded predicate P

`prolog_flag(?F,?V)'
     V is the current value of Prolog flag F

`prolog_flag(+F,=O,+N)'
     O is the old value of Prolog flag F; N is the new value

`prolog_load_context(?K,?V)'
     find out the context of the current load

`set_module(+M)'
     make M the type-in module

`set_prolog_flag(+F,+N)   "ISO"'
     N is the new value of Prolog flag F

`source_file(?F)'
     F is a source file that has been loaded into the database

`source_file(:P,?F)'
     P is a predicate defined in the loaded file F

`unknown(-O,+N)   "development"'
     Changes action on undefined predicates from O to N.



File: sicstus.info,  Node: mpg-top-eqs,  Next: mpg-top-tcm,  Prev: mpg-top-sta,  Up: mpg-top

11.2.19 Saving Programs
-----------------------

`initialization :G   "declaration,ISO"'
     declares G to be run when program is started

`load_files(:F)'
`load_files(:F,+O)'
     load files according to options O

`user:runtime_entry(+S)   "hook"'
     entry point for a runtime system

`save_files(+L,+F)'
     saves the modules, predicates, clauses and directives in the given
     files L into file F

`save_modules(+L,+F)'
     save the modules specifed in L into file F

`save_predicates(:L,+F)'
     save the predicates specified in L into file  F

`save_program(+F)'
`save_program(+F,:G)'
     save all Prolog data into file F with startup goal G

`volatile :P   "declaration"'
     declares predicates specified by P to not be included in saves.



File: sicstus.info,  Node: mpg-top-tcm,  Next: mpg-top-tha,  Prev: mpg-top-eqs,  Up: mpg-top

11.2.20 Term Comparison
-----------------------

`compare(-C,+X,+Y)'
     C is the result of comparing terms X and Y

`+X == +Y   "ISO"'
     terms X and Y are strictly identical

`+X \== +Y   "ISO"'
     terms X and Y are not strictly identical

`+X @< +Y   "ISO"'
     term X precedes term Y in standard order for terms

`+X @>= +Y   "ISO"'
     term X follows or is identical to term Y in standard order for
     terms

`+X @> +Y   "ISO"'
     term X follows term Y in standard order for terms

`+X @=< +Y   "ISO"'
     term X precedes or is identical to term Y in standard order for
     terms



File: sicstus.info,  Node: mpg-top-tha,  Next: mpg-top-tio,  Prev: mpg-top-tcm,  Up: mpg-top

11.2.21 Term Handling
---------------------

`?T =.. ?L   "ISO"'
     the functor and arguments of term T comprise the list L

`?X = ?Y   "ISO"'
     terms X and Y are unified

`+X \= +Y   "ISO"'
     terms X and Y no not unify

`?=(+X,+Y)'
     X and Y are either strictly identical or don't unify

`acyclic_term(+T)   "since release 4.3, ISO"'
     term T is a finite (acyclic) term

`arg(+N,+T,-A)   "ISO"'
     the Nth argument of term T is A

`atom_chars(?A,?L)   "ISO"'
     A is the atom containing the character atoms in list L

`atom_codes(?A,?L)   "ISO"'
     A is the atom containing the characters in code-list L

`atom_concat(?ATOM1,?ATOM2,?ATOM12)   "ISO"'
     Atom ATOM1 concatenated with ATOM2 gives ATOM12.

`atom_length(+ATOM,-LENGTH)   "ISO"'
     LENGTH is the number of characters of the atom ATOM.

`char_code(?CHAR,?CODE)   "ISO"'
     CODE is the character code of the one-char atom CHAR.

`copy_term(+T,-C)   "ISO"'
     C is a copy of T in which all variables have been replaced by new
     variables

`copy_term(+T,-C,-G)'
     C is a copy of T in which all variables have been replaced by new
     variables, and G is a goal for reinstating any attributes in C

`create_mutable(+DATUM,-MUTABLE)'
     MUTABLE is a new mutable term with current value DATUM.

`dif(+X,+Y)'
     X and Y are constrained to be different.

`frozen(+VAR,-GOAL)'
     The goal GOAL is blocked on the variable VAR.

`functor(?T,?F,?N)   "ISO"'
     the principal functor of term T has name F and arity N

`get_mutable(-DATUM,+MUTABLE)'
     The current value of the mutable term MUTABLE is DATUM.

`name(?A,?L)'
     the code-list of atom or number A is L

`number_chars(?N,?L)   "ISO"'
     N is the numeric representation of list of character atoms L

`number_codes(?N,?L)   "ISO"'
     N is the numeric representation of code-list L

`numbervars(+T,+M,-N)'
     number the variables in term T from M to N-1

`sub_atom(+ATOM,?BEFORE,?LENGTH,?AFTER,?SUBATOM)   "ISO"'
     The characters of SUBATOM form a sublist of the characters of
     ATOM, such that the number of characters preceding SUBATOM is
     BEFORE, the number of characters after SUBATOM is AFTER, and the
     length of SUBATOM is LENGTH.

`subsumes_term(General,Specific)   "since release 4.3, ISO"'
     SPECIFIC is an instance of GENERAL

`term_variables(+TERM,-VARIABLES)   "since release 4.3, ISO"'
     VARIABLES is the set of variables that occur in TERM

`unify_with_occurs_check(?X,?Y)   "ISO"'
     True if X and Y unify to a finite (acyclic) term.



File: sicstus.info,  Node: mpg-top-tio,  Next: mpg-top-typ,  Prev: mpg-top-tha,  Up: mpg-top

11.2.22 Term I/O
----------------

`char_conversion(+INCHAR, +OUTCHAR)   "ISO"'
     The mapping of INCHAR to OUTCHAR is added to the
     character-conversion mapping.

`current_char_conversion(?INCHAR, ?OUTCHAR)   "ISO"'
     INCHAR is mapped to OUTCHAR in the current character-conversion
     mapping.

`current_op(?P,?T,?A)   "ISO"'
     atom A is an operator of type T with precedence P

`display(+T)'
     write term T to the user output stream in prefix notation

`format(+C,:A)'
`format(+S,+C,:A)'
     write arguments A on stream S according to control string C

`op(+P,+T,+A)   "ISO"'
     make atom A an operator of type T with precedence P

`user:portray(+T)   "hook"'
     tell `print/[1,2]' and `write_term/[2,3]' what to do

`portray_clause(+C)'
`portray_clause(+S,+C)'
     write clause C to the stream S

`print(+T)   "hookable"'
`print(+S,+T)   "hookable"'
     display the term T on stream S using `user:portray/1' or `write/2'

`read(-T)   "ISO"'
`read(+S,-T)   "ISO"'
     read term T from stream S

`read_term(-T,+O)   "ISO"'
`read_term(+S,-T,+O)   "ISO"'
     read T from stream S according to options O

`write(+T)   "ISO"'
`write(+S,+T)   "ISO"'
     write term T on stream S

`write_canonical(+T)   "ISO"'
`write_canonical(+S,+T)   "ISO"'
     write term T on stream S so that it can be read back by
     `read/[1,2]'

`writeq(+T)   "ISO"'
`writeq(+S,+T)   "ISO"'
     write term T on stream S, quoting atoms where necessary

`write_term(+T,+O)   "ISO,hookable"'
`write_term(+S,+T,+O)   "ISO,hookable"'
     writes T to S according to options O


File: sicstus.info,  Node: mpg-top-typ,  Prev: mpg-top-tio,  Up: mpg-top

11.2.23 Type Tests
------------------

`atom(+T)   "ISO"'
     term T is an atom

`atomic(+T)   "ISO"'
     term T is an atom or a number

`callable(+T)'
     T is an atom or a compound term

`compound(+T)   "ISO"'
     T is a compound term

`db_reference(+X)   "since release 4.1"'
     X is a db_reference

`float(+N)   "ISO"'
     N is a floating-point number

`ground(+T)'
     term T is a nonvar, and all substructures are nonvar

`integer(+T)   "ISO"'
     term T is an integer

`mutable(+X)'
     X is a mutable term

`nonvar(+T)   "ISO"'
     term T is one of atom, number, compound (that is, T is
     instantiated)

`number(+N)   "ISO"'
     N is an integer or a float

`simple(+T)'
     T is not a compound term; it is either atomic or a var

`var(+T)   "ISO"'
     term T is a variable (that is, T is uninstantiated)



File: sicstus.info,  Node: mpg-bpr,  Prev: mpg-top,  Up: Prolog Reference Pages

11.3 Built-In Predicates
========================

The following reference pages, alphabetically arranged, describe the
SICStus Prolog built-in predicates.

   For a functional grouping of these predicates including brief
descriptions, see *note mpg-top::.

   In many cases, the heading of a reference page, as well as an entry
in a list of built-in predicates, will be annotated with keywords.
These annotations are defined in *note mpg-ref-cat::.

   Further information about categories of predicates and arguments,
mode annotations, and the conventions observed in the reference pages is
found in *note mpg-ref::.

* Menu:

* mpg-ref-cut:: !/0
* mpg-ref-and:: ,/2
* mpg-ref-if_then:: ->/2
* mpg-ref-or:: ;/2
* mpg-ref-less_than:: </2
* mpg-ref-univ:: =../2
* mpg-ref-unify:: =/2
* mpg-ref-equal_to:: =:=/2
* mpg-ref-not_greater_than:: =</2
* mpg-ref-term_equal_to:: ==/2
* mpg-ref-not_equal_to:: =\=/2
* mpg-ref-greater_than:: >/2
* mpg-ref-not_less_than:: >=/2
* mpg-ref-term_unify_decided:: ?=/2
* mpg-ref-term_less_than:: @</2
* mpg-ref-term_not_greater_than:: @=</2
* mpg-ref-term_greater_than:: @>/2
* mpg-ref-term_not_less_than:: @>=/2
* mpg-ref-not_provable:: \+/1
* mpg-ref-not_unifiable:: \=/2
* mpg-ref-term_not_equal_to:: \==/2
* mpg-ref-exists:: ^/2
* mpg-ref-abolish:: abolish/[1,2]
* mpg-ref-abort:: abort/0
* mpg-ref-absolute_file_name:: absolute_file_name/[2,3]
* mpg-ref-acyclic_term:: acyclic_term/1
* mpg-ref-add_breakpoint:: add_breakpoint/2
* mpg-ref-append:: append/3
* mpg-ref-arg:: arg/3
* mpg-ref-ask_query:: ask_query/4
* mpg-ref-assert:: assert/[1,2]
* mpg-ref-asserta:: asserta/[1,2]
* mpg-ref-assertz:: assertz/[1,2]
* mpg-ref-at_end_of_line:: at_end_of_line/[0,1]
* mpg-ref-at_end_of_stream:: at_end_of_stream/[0,1]
* mpg-ref-atom:: atom/1
* mpg-ref-atom_chars:: atom_chars/2
* mpg-ref-atom_codes:: atom_codes/2
* mpg-ref-atom_concat:: atom_concat/3
* mpg-ref-atom_length:: atom_length/2
* mpg-ref-atomic:: atomic/1
* mpg-ref-bagof:: bagof/3
* mpg-ref-bb_delete:: bb_delete/2
* mpg-ref-bb_get:: bb_get/2
* mpg-ref-bb_put:: bb_put/2
* mpg-ref-bb_update:: bb_update/3
* mpg-ref-block:: block/1
* mpg-ref-break:: break/0
* mpg-ref-breakpoint_expansion:: breakpoint_expansion/2
* mpg-ref-byte_count:: byte_count/2
* mpg-ref-call:: call/[1,2,...,255]
* mpg-ref-call_cleanup:: call_cleanup/2
* mpg-ref-call_residue_vars:: call_residue_vars/2
* mpg-ref-callable:: callable/1
* mpg-ref-catch:: catch/3
* mpg-ref-char_code:: char_code/2
* mpg-ref-char_conversion:: char_conversion/2
* mpg-ref-character_count:: character_count/2
* mpg-ref-clause:: clause/[2,3]
* mpg-ref-close:: close/[1,2]
* mpg-ref-compare:: compare/3
* mpg-ref-compile:: compile/1
* mpg-ref-compound:: compound/1
* mpg-ref-consult:: consult/1
* mpg-ref-copy_term:: copy_term/[2,3]
* mpg-ref-coverage_data:: coverage_data/1
* mpg-ref-create_mutable:: create_mutable/2
* mpg-ref-current_atom:: current_atom/1
* mpg-ref-current_breakpoint:: current_breakpoint/5
* mpg-ref-current_char_conversion:: current_char_conversion/2
* mpg-ref-current_input:: current_input/1
* mpg-ref-current_key:: current_key/2
* mpg-ref-current_module:: current_module/[1,2]
* mpg-ref-current_op:: current_op/3
* mpg-ref-current_output:: current_output/1
* mpg-ref-current_predicate:: current_predicate/[1,2]
* mpg-ref-current_prolog_flag:: current_prolog_flag/2
* mpg-ref-current_stream:: current_stream/3
* mpg-ref-db_reference:: db_reference/1
* mpg-ref-debug:: debug/0
* mpg-ref-debugger_command_hook:: debugger_command_hook/2
* mpg-ref-debugging:: debugging/0
* mpg-ref-dif:: dif/2
* mpg-ref-disable_breakpoints:: disable_breakpoints/1
* mpg-ref-discontiguous:: discontiguous/1
* mpg-ref-display:: display/1
* mpg-ref-do:: do/2
* mpg-ref-dynamic:: dynamic/1
* mpg-ref-enable_breakpoints:: enable_breakpoints/1
* mpg-ref-ensure_loaded:: ensure_loaded/1
* mpg-ref-erase:: erase/1
* mpg-ref-error_exception:: error_exception/1
* mpg-ref-execution_state:: execution_state/[1,2]
* mpg-ref-expand_term:: expand_term/2
* mpg-ref-fail:: fail/0
* mpg-ref-false:: false/0
* mpg-ref-file_search_path:: file_search_path/2
* mpg-ref-findall:: findall/[3,4]
* mpg-ref-float:: float/1
* mpg-ref-flush_output:: flush_output/[0,1]
* mpg-ref-foreign:: foreign/[2,3]
* mpg-ref-foreign_resource:: foreign_resource/2
* mpg-ref-format:: format/[2,3]
* mpg-ref-freeze:: freeze/2
* mpg-ref-frozen:: frozen/2
* mpg-ref-functor:: functor/3
* mpg-ref-garbage_collect:: garbage_collect/0
* mpg-ref-garbage_collect_atoms:: garbage_collect_atoms/0
* mpg-ref-generate_message:: generate_message/3
* mpg-ref-generate_message_hook:: generate_message_hook/3
* mpg-ref-get_byte:: get_byte/[1,2]
* mpg-ref-get_char:: get_char/[1,2]
* mpg-ref-get_code:: get_code/[1,2]
* mpg-ref-get_mutable:: get_mutable/2
* mpg-ref-goal_expansion:: goal_expansion/5
* mpg-ref-goal_source_info:: goal_source_info/3
* mpg-ref-ground:: ground/1
* mpg-ref-halt:: halt/[0,1]
* mpg-ref-if:: if/3
* mpg-ref-include:: include/1
* mpg-ref-initialization:: initialization/1
* mpg-ref-instance:: instance/2
* mpg-ref-integer:: integer/1
* mpg-ref-is:: is/2
* mpg-ref-keysort:: keysort/2
* mpg-ref-leash:: leash/1
* mpg-ref-length:: length/2
* mpg-ref-library_directory:: library_directory/1
* mpg-ref-line_count:: line_count/2
* mpg-ref-line_position:: line_position/2
* mpg-ref-listing:: listing/[0,1]
* mpg-ref-load_files:: load_files/[1,2]
* mpg-ref-load_foreign_resource:: load_foreign_resource/1
* mpg-ref-member:: member/2
* mpg-ref-memberchk:: memberchk/2
* mpg-ref-message_hook:: message_hook/3
* mpg-ref-meta_predicate:: meta_predicate/1
* mpg-ref-mode:: mode/1
* mpg-ref-module:: module/[2,3]
* mpg-ref-multifile:: multifile/1
* mpg-ref-mutable:: mutable/1
* mpg-ref-name:: name/2
* mpg-ref-nl:: nl/[0,1]
* mpg-ref-nodebug:: nodebug/0
* mpg-ref-nonmember:: nonmember/2
* mpg-ref-nonvar:: nonvar/1
* mpg-ref-nospy:: nospy/1
* mpg-ref-nospyall:: nospyall/0
* mpg-ref-notrace:: notrace/0
* mpg-ref-nozip:: nozip/0
* mpg-ref-number:: number/1
* mpg-ref-number_chars:: number_chars/2
* mpg-ref-number_codes:: number_codes/2
* mpg-ref-numbervars:: numbervars/3
* mpg-ref-on_exception:: on_exception/3
* mpg-ref-once:: once/1
* mpg-ref-op:: op/3
* mpg-ref-open:: open/[3,4]
* mpg-ref-open_null_stream:: open_null_stream/1
* mpg-ref-otherwise:: otherwise/0
* mpg-ref-peek_byte:: peek_byte/[1,2]
* mpg-ref-peek_char:: peek_char/[1,2]
* mpg-ref-peek_code:: peek_code/[1,2]
* mpg-ref-phrase:: phrase/[2,3]
* mpg-ref-portray:: portray/1
* mpg-ref-portray_clause:: portray_clause/[1,2]
* mpg-ref-portray_message:: portray_message/2
* mpg-ref-predicate_property:: predicate_property/2
* mpg-ref-print:: print/[1,2]
* mpg-ref-print_coverage:: print_coverage/[0,1]
* mpg-ref-print_message:: print_message/2
* mpg-ref-print_message_lines:: print_message_lines/3
* mpg-ref-print_profile:: print_profile/[0,1]
* mpg-ref-profile_data:: profile_data/1
* mpg-ref-profile_reset:: profile_reset/0
* mpg-ref-prolog_flag:: prolog_flag/[2,3]
* mpg-ref-prolog_load_context:: prolog_load_context/2
* mpg-ref-prompt:: prompt/2
* mpg-ref-public:: public/1
* mpg-ref-put_byte:: put_byte/[1,2]
* mpg-ref-put_char:: put_char/[1,2]
* mpg-ref-put_code:: put_code/[1,2]
* mpg-ref-query_abbreviation:: query_abbreviation/3
* mpg-ref-query_class:: query_class/5
* mpg-ref-query_class_hook:: query_class_hook/5
* mpg-ref-query_hook:: query_hook/6
* mpg-ref-query_input:: query_input/3
* mpg-ref-query_input_hook:: query_input_hook/3
* mpg-ref-query_map:: query_map/4
* mpg-ref-query_map_hook:: query_map_hook/4
* mpg-ref-raise_exception:: raise_exception/1
* mpg-ref-read:: read/[1,2]
* mpg-ref-read_line:: read_line/[1,2]
* mpg-ref-read_term:: read_term/[2,3]
* mpg-ref-reconsult:: reconsult/1
* mpg-ref-recorda:: recorda/3
* mpg-ref-recorded:: recorded/3
* mpg-ref-recordz:: recordz/3
* mpg-ref-remove_breakpoints:: remove_breakpoints/1
* mpg-ref-repeat:: repeat/0
* mpg-ref-restore:: restore/1
* mpg-ref-retract:: retract/1
* mpg-ref-retractall:: retractall/1
* mpg-ref-save_files:: save_files/2
* mpg-ref-save_modules:: save_modules/2
* mpg-ref-save_predicates:: save_predicates/2
* mpg-ref-save_program:: save_program/[1,2]
* mpg-ref-see:: see/1
* mpg-ref-seeing:: seeing/1
* mpg-ref-seek:: seek/4
* mpg-ref-seen:: seen/0
* mpg-ref-set_input:: set_input/1
* mpg-ref-set_module:: set_module/1
* mpg-ref-set_output:: set_output/1
* mpg-ref-set_prolog_flag:: set_prolog_flag/2
* mpg-ref-set_stream_position:: set_stream_position/2
* mpg-ref-setof:: setof/3
* mpg-ref-simple:: simple/1
* mpg-ref-skip_byte:: skip_byte/[1,2]
* mpg-ref-skip_char:: skip_char/[1,2]
* mpg-ref-skip_code:: skip_code/[1,2]
* mpg-ref-skip_line:: skip_line/[0,1]
* mpg-ref-sort:: sort/2
* mpg-ref-source_file:: source_file/[1,2]
* mpg-ref-spy:: spy/[1,2]
* mpg-ref-statistics:: statistics/[0,2]
* mpg-ref-stream_code:: stream_code/2
* mpg-ref-stream_position:: stream_position/2
* mpg-ref-stream_position_data:: stream_position_data/3
* mpg-ref-stream_property:: stream_property/2
* mpg-ref-sub_atom:: sub_atom/5
* mpg-ref-subsumes_term:: subsumes_term/2
* mpg-ref-tell:: tell/1
* mpg-ref-telling:: telling/1
* mpg-ref-term_expansion:: term_expansion/6
* mpg-ref-term_variables:: term_variables/2
* mpg-ref-throw:: throw/1
* mpg-ref-told:: told/0
* mpg-ref-trace:: trace/0
* mpg-ref-trimcore:: trimcore/0
* mpg-ref-true:: true/0
* mpg-ref-unify_with_occurs_check:: unify_with_occurs_check/2
* mpg-ref-unknown:: unknown/2
* mpg-ref-unknown_predicate_handler:: unknown_predicate_handler/3
* mpg-ref-unload_foreign_resource:: unload_foreign_resource/1
* mpg-ref-update_mutable:: update_mutable/2
* mpg-ref-use_module:: use_module/[1,2,3]
* mpg-ref-var:: var/1
* mpg-ref-volatile:: volatile/1
* mpg-ref-when:: when/2
* mpg-ref-write:: write/[1,2]
* mpg-ref-write_canonical:: write_canonical/[1,2]
* mpg-ref-write_term:: write_term/[2,3]
* mpg-ref-writeq:: writeq/[1,2]
* mpg-ref-zip:: zip/0


File: sicstus.info,  Node: mpg-ref-abolish,  Next: mpg-ref-abort,  Prev: mpg-ref-exists,  Up: mpg-bpr

11.3.1 `abolish/[1,2]'   "[ISO]"
--------------------------------

Synopsis
--------

`abolish(+PREDICATES)'

   `abolish(+PREDICATES, +OPTIONS)'

   Removes procedures from the Prolog database.

Arguments
---------

:PREDICATES
     "pred_spec" or "pred_spec_tree"

     A predicate specification, or a list of such.

     Note that the default is to only allow a single predicate
     specification, see `tree/1' option below.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following:

    `force(BOOLEAN)'
          Specifies whether SICStus Prolog is to abolish the predicate
          even if it is static (`true'), or only if it is dynamic
          (`false'). The latter is the default.

    `tree(BOOLEAN)'
          Specifies whether the first argument should be a
          "pred_spec_tree" (`true'), or a "pred_spec" (`false'). The
          latter is the default.

Description
-----------

Removes all procedures specified.  After this command is executed the
current program functions as if the named procedures had never existed.
That is, in addition to removing all the clauses for each specified
procedure, `abolish/[1,2]' removes any properties that the procedure
might have had, such as being dynamic or multifile.  You cannot abolish
built-in procedures.

   It is important to note that `retract/1', `retractall/1', and
`erase/1' only remove clauses, and only of dynamic procedures. They
don't remove the procedures themselves or their properties properties
(such as being dynamic or multifile).  `abolish/[1,2]', on the other
hand, remove entire procedures along with any clauses and properties.

   The procedures that are abolished do not become invisible to a
currently running procedure.

   Space occupied by abolished procedures is reclaimed.  The space
occupied by the procedures is reclaimed.

   Procedures must be defined in the source module before they can be
abolished.  An attempt to abolish a procedure that is imported into the
source module will cause a permission error.  Using a module prefix,
`M:', procedures in any module may be abolished.

   Abolishing a foreign procedure destroys only the link between that
Prolog procedure and the associated foreign code.  The foreign code
that was loaded remains in memory.  This is necessary because Prolog
cannot tell which subsequently-loaded foreign files may have links to
the foreign code.  The Prolog part of the foreign procedure is
destroyed and reclaimed.

   Specifying an undefined procedure is not an error.

Exceptions
----------

`instantiation_error'
     if one of the arguments is not instantiated enough.

`type_error'
     PREDICATES is not a valid tree of predicate specifications, or a
     NAME is not an atom or an ARITY not an integer.

`domain_error'
     if an ARITY is specified as an integer outside the range 0-255.

`permission_error'
     if a specified procedure is built-in, or imported into the source
     module, or static when `force(true)' is not in effect.

Examples
--------

     | ?- [user].
     % compiling user...
     | foo(1,2).
     | ^D
     % compiled user in module user, 10 msec -80 bytes
     yes
     | ?- abolish(foo).
     ! Type error in argument 1 of abolish/1
     ! expected pred_spec, but found foo
     ! goal:  abolish(user:foo)
     | ?- abolish(foo,[tree(true)]).
     ! Permission error: cannot abolish static user:foo/2
     ! goal:  abolish(user:foo,[tree(true)])
     | ?- abolish(foo/2).
     ! Permission error: cannot abolish static user:foo/2
     ! goal:  abolish(user:foo/2)
     | ?- abolish(foo/2,[force(true)]).
     yes
     % source_info

Comments
--------

`abolish/1' is part of the ISO Prolog standard; `abolish/2' is not.

See Also
--------

`dynamic/1', `erase/1', `retract/1', `retractall/1'.


File: sicstus.info,  Node: mpg-ref-abort,  Next: mpg-ref-absolute_file_name,  Prev: mpg-ref-abolish,  Up: mpg-bpr

11.3.2 `abort/0'
----------------

Synopsis
--------

`abort'

   Abandons the current execution and returns to the beginning of the
current break level or terminates the enclosing query, whichever is
closest.

Description
-----------

Fairly drastic predicate that is normally only used when some error
condition has occurred and there is no way of carrying on, or when
debugging.

   Often used via the debugging option `a' or the `^C' interrupt option
`a'.

   `abort/0' is implemented by raising a reserved exception, which has
handler at the top level; *note ref-ere-int::.

Tips
----

Does not close any files that you may have opened.  When using `see/1'
and `tell/1', (rather than `open/3', `set_input/1', and
`set_output/1'), close files yourself to avoid strange behavior after
your program is aborted and restarted.

Exceptions
----------

Does not throw errors, but is implemented by throwing a reserved
exception.

See Also
--------

`halt/[0,1]', `break/0', `runtime_entry/1', *note ref-ere-int::.


File: sicstus.info,  Node: mpg-ref-absolute_file_name,  Next: mpg-ref-acyclic_term,  Prev: mpg-ref-abort,  Up: mpg-bpr

11.3.3 `absolute_file_name/[2,3]'   "[hookable]"
------------------------------------------------

Synopsis
--------

`absolute_file_name'(+RELFILESPEC,
-ABSFILENAME)

   `absolute_file_name'(+RELFILESPEC,
-ABSFILENAME,                           +OPTIONS)

   Unifies ABSFILENAME with the absolute filename that corresponds to
the relative file specification RELFILESPEC.

Arguments
---------

RELFILESPEC
     "file_spec", must be ground

     A valid file specification. See below for details.

ABSFILENAME
     "atom"

     Corresponding absolute filename.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following.  The default is the empty
     list:

    `extensions(EXT)'
          Has no effect if FILESPEC contains a file extension.  EXT is
          an atom or a list of atoms, each atom representing an
          extension (e.g. `'.pl'') that should be tried when
          constructing the absolute file name.  The extensions are
          tried in the order they appear in the list.  Default value is
          EXT = ["], i.e. only the given FILESPEC is tried, no
          extension is added.  To specify `extensions('')' or
          `extensions([])' is equal to not giving any extensions option
          at all.

          When case-normalization is applied to the FILESPEC, e.g. on
          Windows, each atom in EXT will also be case-normalized before
          use.  That is, on Windows, specifying `extensions(['.pl'])'
          will typically give the same result as `extensions(['.PL'])'.
          Prior to release 4.3 the `extensions/1' option was always
          case sensitive, also on Windows.

    `file_type(TYPE)'
          Picks an adequate extension for the operating system
          currently running, which means that programs using this
          option instead of `extensions(Ext)' will be more portable
          between operating systems.  This extension mechanism has no
          effect if FILESPEC contains a file extension.  TYPE must be
          one of the following atoms:

         `text'
         `file'
               implies `extensions([''])'.  FILESPEC is a file without
               any extension.  (Default)

         `source'
               implies `extensions(['.pro','.pl',''])'.  FILESPEC is a
               Prolog source file, maybe with a `.pro' or `.pl'
               extension.

         `object'
               implies `extensions(['.po'])'.  FILESPEC is a Prolog
               object file.

         `saved_state'
               implies `extensions(['.sav',''])'.  FILESPEC is a
               saved-state, maybe with a `.sav' extension.

         `foreign_resource'
               FILESPEC is a foreign language shared object file, maybe
               with a system dependent extension.

         `executable   "since release 4.0.2"'
               FILESPEC is an executable file, maybe with a system
               dependent extension.

         `directory'
               implies `extensions([''])'.  This option has two
               effects. First, for an access option other than
               `access(none)' the file must exist and be a directory.
               Second, the returned file name will end in slash (`/').

               Only when this option is present can
               `absolute_file_name/3' return the name of an existing
               directory with an access option other than
               `access(none)' without raising an exception.


    `glob(GLOB)'
          Match file names against a pattern. RELFILESPEC will be
          expanded to a directory and ABSFILENAME will be the absolute
          path to each child that matches both the GLOB pattern and any
          other filtering option, like `access/1', `extensions/1',
          `file_type/1', .... The special children `.' and `..' will
          never be returned.

          The GLOB should be an atom specifying a "glob pattern"
          consisting of characters interpreted as follows:
             * A `*' matches any sequence of zero or more characters.

             * A `?' matches exactly one character.

             * A `{', `}', `[', `]' currently matches themself but are
               reserved for future expansion of the allowable patterns.

             * Any other character matches itself.


          With the options `solutions(all)' and `file_errors(fail)'
          this can be used to enumerate the contents of a directory.

    `access(MODE)'
          MODE must be an atom or a list of atoms.  If a list is given,
          ABSFILENAME must obey every specified option in the list.
          This makes it possible to combine a read and write, or write
          and exist check, into one call. If ABSFILENAME specifies a
          directory and an access option other than `access(none)' is
          specified then a permission error is signaled unless
          `file_type(directory)' is also specified.

          Each atom must be one of the following:

         `read'
               ABSFILENAME must be readable and exist.

         `write'
         `append'
               If ABSFILENAME exists, it must be writable.  If it
               doesn't exist, it must be possible to create.

         `exist'
               The file represented by ABSFILENAME must exist.

         `execute'
         `executable'
               The file represented by ABSFILENAME must be executable
               and exist.  This is ignored if `file_type(directory)' is
               also specified.

         `search'
         `searchable'
               The directory represented by ABSFILENAME must be
               searchable and exist.  This is ignored unless
               `file_type(directory)' is also specified.

         `none'
               The file system is not accessed to determine existence
               or access properties of ABSFILENAME.  The first absolute
               file name that is derived from FILESPEC is returned.
               Note that if this option is specified, no existence
               exceptions can be raised.  (Default)

          *Please note:* Most current file systems have complex access
          control mechanisms, such as access control lists (ACLs). These
          mechanisms makes it hard to determine the effective access
          permissions, short of actually attempting the file operations
          in question. With networked file systems it may in fact be
          impossible to determine the effective access rights.

          Therefore, a simplified access control model is used by
          `absolute_file_name/3' and elsewhere in SICStus.

          On UNIX systems only the "classical" access control
          information is used, i.e. the read/write/execute "bits" for
          owner/group/other.

          Under Windows only the "FAT" access control information is
          used, i.e.  a file may be marked as read-only.  A file is
          deemed executable if its extension is one of `.cmd', `.bat'
          or if it is classified as an executable by the Win32 API
          `GetBinaryType'.

          This may change to more faithfully reflect the effective
          permissions in a future release.

    `file_errors(VAL)'
    `fileerrors(VAL)'
          VAL is one of the following, where the default is determined
          by the current value of the `fileerrors' Prolog flag: 

         `error'
               Raise an exception if a file derived from FILESPEC has
               the wrong permissions, that is, can't be accessed at
               all, or doesn't satisfy the access modes specified with
               the `access' option.  This is the default if the Prolog
               flag `fileerrors' is set to its default value, `on'.

         `fail'
               Fail if a file derived from FILESPEC has the wrong
               permissions. Normally an exception is raised, which
               might not always be a desirable behavior, since files
               that do obey the access options might be found later on
               in the search.  When this option is given, the search
               space is guaranteed to be exhausted.  This is the
               default if the Prolog flag `fileerrors' is set to `off'.

    `solutions(VAL)'
          VAL is one of the following:

         `first'
               As soon as a file derived from FILESPEC is found, commit
               to that file. Makes `absolute_file_name/3' determinate.
               (Default)

         `all'
               Return each file derived from FILESPEC that is found.
               The files are returned through backtracking. This option
               is probably most useful in combination with the option
               `file_errors(fail)'.

    `relative_to(FILEORDIRECTORY)'
          FILEORDIRECTORY should be an atom, and controls how to
          resolve relative filenames.  If it is `''', file names will be
          treated as relative to the current working directory.  If a
          regular, existing file is given, file names will be treated
          as relative to the directory containing FILEORDIRECTORY.
          Otherwise, file names will be treated as relative to
          FILEORDIRECTORY.

          If `absolute_file_name/3' is called from a goal in a file
          being loaded, the default is the directory containing that
          file, accessible from the load context
          (`prolog_load_context/2').  Otherwise, the default is the
          current working directory.

          You can use `file_systems:current_directory/1' to obtain the
          current working directory from a goal in a file being loaded.

    `if_user(VAL)   "since release 4.3"'
          controls how to resolve the special file name `user'.  VAL is
          one of the following:

         `file'
               Treat the name `user' like any other name, e.g. like
               `open/3' does.  This is the default.

         `user'
               Unifies ABSFILENAME with the atom `user' and ignores the
               other options.  This corresponds to the behavior prior
               to SICStus Prolog 4.3.

         `error'
               Treat the name `user' as a non-existing file, subject to
               the `file_errors/1' option.



Description
-----------

If FILESPEC is `user', and the option `if_user(file)' is not in effect,
then special processing takes place, see the description of the
`if_user/1' option, above.  Otherwise (the default), unifies
ABSFILENAME with the first absolute file name that corresponds to the
relative file specification FILESPEC and that satisfies the access
modes given by OPTIONS.

   The functionality of `absolute_file_name/3' is most easily described
as multi-phase process, in which each phase gets an infile from the
preceding phase, and constructs one or more outfiles to be consumed by
the succeeding phases. The phases are:

  1. Syntactic rewriting

  2. Pattern expansion

  3. Extension expansion

  4. Access checking

   The first phase and each of the expansion phases modifies the infile
and produces variants that will be fed into the succeeding phases. The
functionality of all phases but the first are decided with the option
list. The last phase checks if the generated file exists, and if not
asks for a new variant from the preceding phases.  If the file exists,
but doesn't obey the access mode option, a permission exception is
raised. If the file obeys the access mode option,
`absolute_file_name/3' commits to that solution, subject to the
`solutions' option, and unifies ABSFILENAME with the file name.  For a
thorough description, see below.

   Note that the relative file specification FILESPEC may also be of
the form PATH(FILESPEC), in which case the absolute file name of the
file FILESPEC in one of the directories designated by PATH is returned
(see the description of each phase below).

Syntactic rewriting
     This phase translates the relative file specification given by
     FILESPEC into the corresponding absolute file name.  The rewrite is
     done wrt. the value of the `relative_to' option.  There can be
     more than one solution, in which case the outfile becomes the
     solutions in the order they are generated.  If the following
     phases fails, and there are no more solutions, an existence
     exception is raised.

     FILESPEC can be a file search path, e.g. `library('lists.pl')'. It
     can also refer to system properties, environment variables and the
     home directory of users. *Note ref-fdi-syn::, for a description of
     syntactic rewriting.

Pattern expansion
     If the `glob/1' option was specified all matching children of the
     directory will be enumerated. See the `glob' option.

Extension expansion
     See the `extensions' and `file_type' options.

Access checking
     See the `access' option.

Final stage
     As a final stage, if `file_type(directory)' is specified, the file
     is suffixed with slash. Otherwise, trailing slash will be removed
     except for root directories, such as `/' under UNIX or `c:/' under
     Windows.


Backtracking
------------

Can find multiple solutions only if the `solutions(all)' option is used.

Exceptions
----------

`instantiation_error'
     Any of the OPTIONS arguments or RELFILESPEC is not ground.

`type_error'
     In OPTIONS or in RELFILESPEC.

`domain_error'
     OPTIONS contains an undefined option.

`existence_error'
     RELFILESPEC is syntactically valid but does not correspond to any
     file and an access option other than `access(none)' was given.

`permission_error'
     RELFILESPEC names an existing file but the file does not obey the
     given access mode.

Comments
--------

If an option is specified more than once the rightmost option takes
precedence. This provides for a convenient way of adding default values
by putting these defaults at the front of the list of options.  If
`absolute_file_name/3' succeeds, and the file access option was one of
{`read', `write', `append'}, it is guaranteed(1) that the file can be
opened with `open/[3,4]'.  If the access option was `exist', the file
does exist, but might be both read and write protected.

   If `file_type(directory)' is not given, the file access option is
other than `none', and a specified file refers to a directory, then
`absolute_file_name/3' signals a permission error.

   `absolute_file_name/[2,3]' is sensitive to the `fileerrors' Prolog
flag, which determines whether the predicate should fail or raise
permission errors when encountering files with the wrong permission.
Failing has the effect that the search space always is exhausted.  

   If RELFILESPEC contains `..' components, these are resolved by
removing directory components from the pathname, not by acessing the
file system. This can give unexpected results, e.g. when soft links or
mount points are involved.

   This predicate is used for resolving file specification by built-in
predicates that open files.

Examples
--------

To check whether the file `my_text' exists in the home directory, with
one of the extensions `.text' or `.txt', and is both writable and
readable:

     | ?- absolute_file_name('~/my_text', File,
                             [extensions(['.text','.txt']),
                             access([read,write])]).

   To check whether the directory `bin' exists in the home directory:

     | ?- absolute_file_name('~/bin', Dir,
                             [file_type(directory),
                             access(exist)]).

   Here DIR would get a slash terminated value, such as `/home/joe/'.

   To list all files in the current directory:

     | ?- findall(File, absolute_file_name('.', File,
                             [glob('*'),
                             solutions(all), file_errors(fail)]), Files).

   To list all directories in the parent of the current directory
containing the string "sicstus":

     | ?- findall(File, absolute_file_name('..', File,
                             [glob('*sicstus*'),file_type(directory),
                             solutions(all), file_errors(fail)]), Files).

   To find a file `cmd.exe' in any of the "usual places" where
executables are found, i.e. by looking through the `PATH' environment
variable:

     | ?- absolute_file_name(path('cmd.exe'), File,
                             [access(exist)]).

   This uses the predefined file search path `path/1', *note ref-fdi::.

See Also
--------

`file_search_path/2', `prolog_load_context/2', *note ref-fdi::, *note
ref-lps-flg::.

   ---------- Footnotes ----------

   (1) To the extent that the access permissions can be precisely
determined. See the `access/1' option above.


File: sicstus.info,  Node: mpg-ref-acyclic_term,  Next: mpg-ref-add_breakpoint,  Prev: mpg-ref-absolute_file_name,  Up: mpg-bpr

11.3.4 `acyclic_term/1'   "[ISO]"
---------------------------------

Synopsis
--------

`acyclic_term(+TERM)'   "since release 4.3"

   TERM is currently instantiated to a finite (acyclic) term.

Arguments
---------

TERM
     "term"

Description
-----------

True if X is finite (acyclic).  Runs in linear time.

Examples
--------

     | ?- X = g(Y), acyclic_term(f(X,X)).
     X = g(Y) ?
     yes
     | ?- X = g(X), acyclic_term(X).

     no
     | ?- X = g(X), acyclic_term(f(X)).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-add_breakpoint,  Next: mpg-ref-append,  Prev: mpg-ref-acyclic_term,  Up: mpg-bpr

11.3.5 `add_breakpoint/2'   "[development]"
-------------------------------------------

Synopsis
--------

`add_breakpoint(+CONDITIONS, -BID)'

   Creates a breakpoint with CONDITIONS and with identifier BID.

Arguments
---------

:CONDITIONS
     "term".

     Breakpoint conditions.

BID
     "integer"

     Breakpoint identifier.

Exceptions
----------

`instantiation_error'
     CONDITIONS not instantiated enough.

`type_error'
     CONDITIONS not a proper list of callable term.

`domain_error'
     CONDITIONS not a proper list of valid breakpoint conditions

`context_error'
     Attempt to put a breakpoint on `true/0' or `fail/0'.

See Also
--------

*note Creating Breakpoints::, *note Breakpoint Predicates::.


File: sicstus.info,  Node: mpg-ref-and,  Next: mpg-ref-if_then,  Prev: mpg-ref-cut,  Up: mpg-bpr

11.3.6 `,/2'   "[ISO]"
----------------------

Synopsis
--------

+P `,' +Q

Arguments
---------

:P
     "callable", must be nonvar

:Q
     "callable", must be nonvar

Description
-----------

This is not normally regarded as a built-in predicate, since it is part
of the syntax of the language.  However, it is like a built-in
predicate in that you can say `call((P `,' Q))' to execute P and then Q.

Backtracking
------------

Depends on P and Q.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-append,  Next: mpg-ref-arg,  Prev: mpg-ref-add_breakpoint,  Up: mpg-bpr

11.3.7 `append/3'
-----------------

Synopsis
--------

`append(?LIST1, ?LIST2, ?LIST3)'

Arguments
---------

LIST1
     "list of term"

LIST2
     "list of term"

LIST3
     "list of term"

     A list consisting of LIST1 followed by LIST2.

Description
-----------

Appends lists LIST1 and LIST2 to form LIST3:

     | ?- append([a,b], [a,d], X).

     X = [a,b,a,d]

     | ?- append([a], [a], [a]).

     no
     | ?- append(2, [a], X).

     no

   Takes LIST3 apart:
     | ?- append(X, [e], [b,e,e]).

     X = [b,e]

     | ?- append([b|X], [e,r], [b,o,r,e,r]).

     X = [o,r]

     | ?- append(X, Y, [h,i]).

     X = [],
     Y = [h,i] ;

     X = [h],
     Y = [i] ;

     X = [h,i],
     Y = [] ;

     no

Backtracking
------------

Suppose L is bound to a proper list.  That is, it has the form
[T1,...,TN] for some N.  In that instance, the following things apply:

  1. `append(L, X, Y)' has at most one solution, whatever X and Y are,
     and cannot backtrack at all.

  2. `append(X, Y, L)' has at most N+1 solutions, whatever X and Y are,
     and though it can backtrack over these it cannot run away without
     finding a solution.

  3. `append(X, L, Y)', however, can backtrack indefinitely if X and Y
     are variables.

Examples
--------

The following examples are perfectly ordinary uses of `append/3':

   To enumerate adjacent pairs of elements from a list:
     next_to(X, Y, (*in*) List3) :-
             append(_, [X,Y|_], List3).

   To check whether Word1 and Word2 are the same except for a single
transposition.  (`append/5' in `library(lists)' would be better for
this task.)
     one_transposition(Word1, Word2) :-
             append(Prefix, [X,Y|Suffix], Word1),
             append(Prefix, [Y,X|Suffix], Word2).

     | ?- one_transposition("fred", X).
     X = "rfed" ;
     X = "ferd" ;
     X = "frde" ;
     no

   Given a list of words and commas, to backtrack through the phrases
delimited by commas:
     comma_phrase(List3, Phrase) :-
             append(F, [','|Rest], List3),
             !,
             (   Phrase = F
             ;   comma_phrase(Rest, Phrase)
             ).
     comma_phrase(List3, List3).

     | ?- comma_phrase([this,is,',',um,',',an, example], X).
     X = [this,is] ;
     X = [um] ;
     X = [an,example] ;
     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-acl::, `library(lists)'.


File: sicstus.info,  Node: mpg-ref-arg,  Next: mpg-ref-ask_query,  Prev: mpg-ref-append,  Up: mpg-bpr

11.3.8 `arg/3'   "[ISO]"
------------------------

Synopsis
--------

`arg(+ARGNUM, +TERM, -ARG)'

   unifies ARG with the ARGNUMth argument of term TERM.

Arguments
---------

ARGNUM
     "integer", must be nonvar and positive

TERM
     "compound", must be nonvar

ARG
     "term"

Description
-----------

The arguments are numbered from 1 upwards.

Exceptions
----------

`instantiation_error'
     if ARGNUM or TERM is unbound.

`type_error'
     if ARGNUM is not an integer, or TERM is not compound.

`domain_error'
     if ARGNUM is an integer less than zero.

Examples
--------

     | ?- arg(2, foo(a,b,c), X).

     X = b

See Also
--------

`functor/3', `=../2', *note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-ask_query,  Next: mpg-ref-assert,  Prev: mpg-ref-arg,  Up: mpg-bpr

11.3.9 `ask_query/4'   "[hookable]"
-----------------------------------

Synopsis
--------

`ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)'

   Prints the question QUERY, then reads and processes user input
according to QUERYCLASS, and returns the result of the processing, the
abstract answer term ANSWER.  The HELP message may be printed in case
of invalid input.

Arguments
---------

QUERYCLASS
     "term", must be nonvar

     Determines the allowed values for the atom ANSWER.

QUERY
     "term"

     A message term.

HELP
     "term"

     A message term.

ANSWER
     "term"

     See QUERYCLASS

Description
-----------

All queries made by the system are handled by calling this predicate.

   First `ask_query/4' calls `query_hook/6' with the same arguments
plus the QUERY and HELP arguments converted to format-command lines.
If this call succeeds, then it overrides all further processing done by
`ask_query/4'.  Otherwise, the query is processed in the following way:

   * Preparation phase: The parameters of the query processing, defined
     by QUERYCLASS (PROMPT, INPUTMETHOD, MAPMETHOD and FAILUREMODE) are
     retrieved using the four step procedure described above.  That is,
     the following alternatives are tried:
        - `user:query_class_hook/5';

        - `'SU_messages':query_class/5';

        - the built-in copy of `query_class/5'.

   * Input phase: The user is prompted with PROMPT, input is read
     according to INPUTMETHOD, and the result is returned in RAWINPUT.

     The four step procedure is used for performing this phase, the
     predicates tried are the following:
        - `user:query_input_hook/3';

        - `'SU_messages':query_input/3';

        - the built-in copy of `query_input/3'.

   * Mapping phase: The RAWINPUT returned by the input phase is mapped
     to the ANSWER of the query.  This mapping is defined by the
     MAPMETHOD parameter, and the result of the conversion is returned
     in RESULT, which can be:
        - `success'--the mapping was successful, ANSWER is valid;

        - `failure'--the mapping was unsuccessful, the query has to be
          repeated;

        - `failure(WARNING)'--same as `failure', but first the given
          warning message has to be printed.

     The four step procedure is used for performing this phase, the
     predicates tried are the following:
        - `user:query_map_hook/4';

        - `'SU_messages':query_map/4';

        - the built-in copy of `query_map/4'.

     If the mapping phase succeeds, then `ask_query/4' returns with the
     ANSWER delivered by this phase.

   * If the mapping does not succeed, then the query has to be
     repeated.  If the RESULT returned by the mapping contains a
     warning message, then it is printed using `print_message/2'.
     FAILUREMODE specifies whether to print the help message and
     whether to re-print the query text.  Subsequently, the input and
     mapping phases are called again, and this is repeated until the
     mapping is successful.

Exceptions
----------

`instantiation_error'
     QUERYCLASS, QUERY, or HELP uninstantiated.

`type_error'
     QUERYCLASS not an atom.

`domain_error'
     QUERYCLASS not a valid query class.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-assert,  Next: mpg-ref-asserta,  Prev: mpg-ref-ask_query,  Up: mpg-bpr

11.3.10 `assert/[1,2]'
----------------------

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   `assert(+CLAUSE)'

   `assert(+CLAUSE, -REF)'

   It is undefined whether CLAUSE will precede or follow the clauses
already in the database.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid dynamic Prolog clause.

REF
     "db_reference", must be var

     A database reference, which uniquely identifies the newly asserted
     CLAUSE.

Description
-----------

CLAUSE must be of the form:
            HEAD
     or     HEAD :- BODY
     or     M:CLAUSE

   where HEAD is of type callable and BODY is a valid clause body.  If
specified, M must be an atom.

   `assert(HEAD)' means assert the unit-clause HEAD.  The exact same
effect can be achieved by `assert((HEAD :- true))'.

   If BODY is uninstantiated it is taken to mean `call(BODY)'.  For
example, (A) is equivalent to (B):
     | ?- assert((p(X) :- X)).             (A)
     | ?- assert((p(X) :- call(X))).       (B)

   REF should be uninstantiated; a range exception is signalled if REF
does not unify with its return value.  This exception is signalled
after the assert has been completed.

   The procedure for CLAUSE must be dynamic or undefined.  If it is
undefined, it is set to be dynamic.

   When an assert takes place, the new clause is immediately seen by any
subsequent call to the procedure.  However, if there is a currently
active call of the procedure at the time the clause is asserted, the
new clause is not encountered on backtracking by that call.  See *note
ref-mdb-bas:: for further explanation of what happens when currently
running code is modified.

   Any uninstantiated variables in the CLAUSE will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

`type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a
     valid clause body.

`permission_error'
     the procedure corresponding to HEAD is not dynamic

`uninstantiation_error'
     REF is not a variable


See Also
--------

*note ref-mdb-acd::.


File: sicstus.info,  Node: mpg-ref-asserta,  Next: mpg-ref-assertz,  Prev: mpg-ref-assert,  Up: mpg-bpr

11.3.11 `asserta/[1,2]'   "[ISO]"
---------------------------------

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   `asserta(+CLAUSE)'

   `asserta(+CLAUSE, -REF)'

   CLAUSE will precede all existing clauses in the database.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid dynamic Prolog clause.

REF
     "db_reference", must be var

     A database reference, which uniquely identifies the newly asserted
     CLAUSE.

Description
-----------

CLAUSE must be of the form:
            HEAD
     or     HEAD :- BODY
     or     M:CLAUSE

   where HEAD is of type callable and BODY is a valid clause body.  If
specified, M must be an atom.

   `asserta(HEAD)' means assert the unit-clause HEAD.  The exact same
effect can be achieved by `asserta((HEAD :- true))'.

   If BODY is uninstantiated it is taken to mean `call(BODY)'.  For
example, (A) is equivalent to (B):
     | ?- asserta((p(X) :- X)).             (A)
     | ?- asserta((p(X) :- call(X))).       (B)

   REF should be uninstantiated; a range exception is signalled if REF
does not unify with its return value.  This exception is signalled
after the assert has been completed.

   The procedure for CLAUSE must be dynamic or undefined.  If it is
undefined, it is set to be dynamic.

   When an assert takes place, the new clause is immediately seen by any
subsequent call to the procedure.  However, if there is a currently
active call of the procedure at the time the clause is asserted, the
new clause is not encountered on backtracking by that call.  See *note
ref-mdb-bas:: for further explanation of what happens when currently
running code is modified.

   Any uninstantiated variables in the CLAUSE will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

`type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a
     valid clause body.

`permission_error'
     the procedure corresponding to HEAD is not dynamic

`uninstantiation_error'
     REF is not a variable


See Also
--------

*note ref-mdb-acd::.


File: sicstus.info,  Node: mpg-ref-assertz,  Next: mpg-ref-at_end_of_line,  Prev: mpg-ref-asserta,  Up: mpg-bpr

11.3.12 `assertz/[1,2]'   "[ISO]"
---------------------------------

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   `assertz(+CLAUSE)'

   `assertz(+CLAUSE, -REF)'

   CLAUSE will follow all existing clauses in the database.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid dynamic Prolog clause.

REF
     "db_reference", must be var

     A database reference, which uniquely identifies the newly asserted
     CLAUSE.

Description
-----------

CLAUSE must be of the form:
            HEAD
     or     HEAD :- BODY
     or     M:CLAUSE

   where HEAD is of type callable and BODY is a valid clause body.  If
specified, M must be an atom.

   `assertz(HEAD)' means assert the unit-clause HEAD.  The exact same
effect can be achieved by `assertz((HEAD :- true))'.

   If BODY is uninstantiated it is taken to mean `call(BODY)'.  For
example, (A) is equivalent to (B):
     | ?- assertz((p(X) :- X)).             (A)
     | ?- assertz((p(X) :- call(X))).       (B)

   REF should be uninstantiated; a range exception is signalled if REF
does not unify with its return value.  This exception is signalled
after the assert has been completed.

   The procedure for CLAUSE must be dynamic or undefined.  If it is
undefined, it is set to be dynamic.

   When an assert takes place, the new clause is immediately seen by any
subsequent call to the procedure.  However, if there is a currently
active call of the procedure at the time the clause is asserted, the
new clause is not encountered on backtracking by that call.  See *note
ref-mdb-bas:: for further explanation of what happens when currently
running code is modified.

   Any uninstantiated variables in the CLAUSE will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

`type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a
     valid clause body.

`permission_error'
     the procedure corresponding to HEAD is not dynamic

`uninstantiation_error'
     REF is not a variable


Examples
--------

     | ?- assertz(mammal(kangaroo)).
     yes
     | ?- assertz(mammal(whale), Ref).
     Ref = '$ref'(1258504,210) ? <RET>
     yes
     | ?- listing(mammal).
     mammal(kangaroo).
     mammal(whale).
     yes

See Also
--------

*note ref-mdb-acd::.


File: sicstus.info,  Node: mpg-ref-at_end_of_line,  Next: mpg-ref-at_end_of_stream,  Prev: mpg-ref-assertz,  Up: mpg-bpr

11.3.13 `at_end_of_line/[0,1]'
------------------------------

Synopsis
--------

`at_end_of_line'

   `at_end_of_line(+STREAM)'

   Test whether end of line (record) has been reached for the current
input stream or for the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream, defaults to the current input stream.

Description
-----------

Succeeds when end of line (record) is reached for the specified input
stream.  An input stream reaches end of line when all the characters
except <LFD> of the current line have been read.

   Is also true whenever `at_end_of_stream/[0,1]' is true.  

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`at_end_of_stream/[0,1]', `skip_line/[0,1]', `set_input/1'.


File: sicstus.info,  Node: mpg-ref-at_end_of_stream,  Next: mpg-ref-atom,  Prev: mpg-ref-at_end_of_line,  Up: mpg-bpr

11.3.14 `at_end_of_stream/[0,1]'   "[ISO]"
------------------------------------------

Synopsis
--------

`at_end_of_stream'

   `at_end_of_stream(+STREAM)'

   Tests whether the end has been reached for the current input stream
or for the input stream STREAM.  

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream, defaults to the current input stream.

Description
-----------

Checks if the end has been reached for the specified input stream.  An
input stream reaches the end when all items (characters or bytes)
except `EOF' (-1) of the stream have been read.  It remains at the end
after `EOF' has been read.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Comments
--------

`at_end_of_stream/[0,1]' peeks ahead for next input item if there is no
item available on the buffer of the specified input stream.

   Note that `at_end_of_stream/[0,1]' never blocks. If reading ahead
would block then `at_end_of_stream/[0,1]' will fail, even if the stream
is actually at its end. If you want to ensure that end of stream
condition is always properly detected, even if that entails blocking
until further input is possible, you can use `peek_code/[1,2]' or
`peek_byte/[1,2]'.

     *Please note*: The design of `at_end_of_stream/[0,1]' makes it
     inherently unreliable. It is present only for ISO standards
     compliance. It is better to read or peek until one of the end of
     file indications is returned.

See Also
--------

`at_end_of_line/[0,1]'.


File: sicstus.info,  Node: mpg-ref-atom,  Next: mpg-ref-atom_chars,  Prev: mpg-ref-at_end_of_stream,  Up: mpg-bpr

11.3.15 `atom/1'   "[ISO]"
--------------------------

Synopsis
--------

`atom(+TERM)'

   Succeeds if TERM is currently instantiated to an atom.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- atom(pastor).

     yes
     | ?- atom(Term).

     no
     | ?- atom(1).

     no
     | ?- atom('Time').

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-atom_chars,  Next: mpg-ref-atom_codes,  Prev: mpg-ref-atom,  Up: mpg-bpr

11.3.16 `atom_chars/2'   "[ISO]"
--------------------------------

Synopsis
--------

`atom_chars(+ATOM, -CHARS)'

   `atom_chars(-ATOM, +CHARS)'

   CHARS is the "chars" comprising the printed representation of ATOM.

Arguments
---------

CHARS
     "chars"

     The "chars" comprising the printed representation of ATOM.

ATOM
     "atom"

     The atom containing exactly those characters, even if the
     characters look like the printed representation of a number.

Description
-----------

Initially, either ATOM must be instantiated to an atom, or CHARS must
be instantiated to a proper "chars".

   Any atom that can be read or written by Prolog can be constructed or
decomposed by `atom_chars/2'.

Exceptions
----------

`instantiation_error'
     ATOM is uninstantiated and CHARS is not instantiated enough.

`type_error'
     ATOM is not an atom or CHARS cannot be unified with a "chars".

`representation_error'
     CHARS is a list corresponding to an atom that can't be represented

   The check of CHARS when ATOM is instantiated was added in release
4.3 for alignment with the ISO Prolog standard. Previous releases
simply failed in this case instead of reporting an error for malformed
CHARS.

See Also
--------

`atom_codes/2'.


File: sicstus.info,  Node: mpg-ref-atom_codes,  Next: mpg-ref-atom_concat,  Prev: mpg-ref-atom_chars,  Up: mpg-bpr

11.3.17 `atom_codes/2'   "[ISO]"
--------------------------------

Synopsis
--------

`atom_codes(+ATOM, -CODES)'

   `atom_codes(-ATOM, +CODES)'

   CODES is the "codes" comprising the printed representation of ATOM.

Arguments
---------

CODES
     "codes"

     The "codes" comprising the printed representation of ATOM.

ATOM
     "atom"

     The atom containing exactly those characters, even if the
     characters look like the printed representation of a number.

Description
-----------

Initially, either ATOM must be instantiated to an atom, or CODES must
be instantiated to a proper "codes".

   Any atom that can be read or written by Prolog can be constructed or
decomposed by `atom_codes/2'.

Exceptions
----------

`instantiation_error'
     ATOM is uninstantiated and CODES is not instantiated enough

`type_error'
     ATOM is not an atom or CODES cannot be unified with a list of
     integers

`representation_error'
     An element of CODES is an invalid character code, or CODES is a
     list corresponding to an atom that can't be represented

   The check of CODES when ATOM is instantiated was added in release
4.3 for alignment with the ISO Prolog standard. Previous releases
simply failed in this case instead of reporting an error for malformed
CODES.

See Also
--------

`atom_chars/2'.


File: sicstus.info,  Node: mpg-ref-atom_concat,  Next: mpg-ref-atom_length,  Prev: mpg-ref-atom_codes,  Up: mpg-bpr

11.3.18 `atom_concat/3'   "[ISO]"
---------------------------------

Synopsis
--------

`atom_concat(+ATOM1,+ATOM2,-ATOM12)'

   `atom_concat(-ATOM1,-ATOM2,+ATOM12)'

   The characters of the atom ATOM1 concatenated with those of ATOM2
are the same as the characters of atom ATOM12.

Arguments
---------

ATOM1
     "atom"

ATOM2
     "atom"

ATOM12
     "atom"

Description
-----------

Initially, either both ATOM1 and ATOM2, or ATOM12, must be instantiated
to atoms.  If only ATOM12 is instantiated, nondeterminately enumerates
all possible atom-pairs that concatenate to the given atom, e.g.:

     | ?- atom_concat(A, B, 'ab').

     A = '',
     B = ab ? ;

     A = a,
     B = b ? ;

     A = ab,
     B = ''  ;

     no

Exceptions
----------

`instantiation_error'
     More than one argument uninstantiated.

`type_error'
     An instantiated argument is not an atom.

`representation_error'
     ATOM12 is too long to be represented.


See Also
--------

`atom_length/2', `sub_atom/5'.


File: sicstus.info,  Node: mpg-ref-atom_length,  Next: mpg-ref-atomic,  Prev: mpg-ref-atom_concat,  Up: mpg-bpr

11.3.19 `atom_length/2'   "[ISO]"
---------------------------------

Synopsis
--------

`atom_length(+ATOM, -LENGTH)'

   LENGTH is the number of characters of the atom ATOM.

Arguments
---------

ATOM
     "atom", must be nonvar

LENGTH
     "integer"

Exceptions
----------

`instantiation_error'
     ATOM is uninstantiated

`type_error'
     ATOM is not an atom, or LENGTH cannot be unified with an integer

`domain_error'
     LENGTH < 0


See Also
--------

`atom_length/2', `atom_concat/3', `sub_atom/5'.


File: sicstus.info,  Node: mpg-ref-atomic,  Next: mpg-ref-bagof,  Prev: mpg-ref-atom_length,  Up: mpg-bpr

11.3.20 `atomic/1'   "[ISO]"
----------------------------

Synopsis
--------

`atomic(+TERM)'

   Succeeds if TERM is currently instantiated to an atom or a number.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- atomic(9).

     yes
     | ?- atomic(a).

     yes
     | ?- atomic("a").

     no
     | ?- assert(foo(1), Ref), atomic(Ref).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-bagof,  Next: mpg-ref-bb_delete,  Prev: mpg-ref-atomic,  Up: mpg-bpr

11.3.21 `bagof/3'   "[ISO]"
---------------------------

Synopsis
--------

`bagof(+TEMPLATE, +GENERATOR, -SET)'

   Like `setof/3' except that the list (or alternative lists) returned
will not be ordered, and may contain duplicates.  This relaxation saves
time and space in execution.

Arguments
---------

TEMPLATE
     "term"

:GENERATOR
     "callable", must be nonvar

     A goal to be proved as if by `call/1'.

SET
     "list of term", non-empty set

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

See `findall/3' for examples that illustrate the differences among
`findall/3', `setof/3', and `bagof/3'.

See Also
--------

`findall/3', `setof/3', `^/2', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-bb_delete,  Next: mpg-ref-bb_get,  Prev: mpg-ref-bagof,  Up: mpg-bpr

11.3.22 `bb_delete/2'
---------------------

Synopsis
--------

`bb_delete(:KEY, -TERM)'

   If a term is currently stored under KEY, the term is deleted, and a
copy of it is unified with TERM.  Otherwise, `bb_delete/2' silently
fails.

Arguments
---------

:KEY
     "atomic", must be nonvar

TERM
     "term"

Exceptions
----------

`instantiation_error'
     KEY is not instantiated

`type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-bb_get,  Next: mpg-ref-bb_put,  Prev: mpg-ref-bb_delete,  Up: mpg-bpr

11.3.23 `bb_get/2'
------------------

Synopsis
--------

`bb_get(:KEY, -TERM)'

   If a term is currently stored under KEY, a copy of it is unified
with TERM.  Otherwise, `bb_get/2' silently fails.

Arguments
---------

:KEY
     "atomic", must be nonvar

TERM
     "term"

Exceptions
----------

`instantiation_error'
     KEY is not instantiated

`type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-bb_put,  Next: mpg-ref-bb_update,  Prev: mpg-ref-bb_get,  Up: mpg-bpr

11.3.24 `bb_put/2'
------------------

Synopsis
--------

`bb_put(:KEY, +TERM)'

   A copy of TERM is stored under KEY in the source module blackboard.
Any previous term stored under the same KEY is simply deleted.

Arguments
---------

:KEY
     "atomic", must be nonvar

TERM
     "term"

Description
-----------

Any uninstantiated variables in the TERM will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     KEY is not instantiated

`type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-bb_update,  Next: mpg-ref-block,  Prev: mpg-ref-bb_put,  Up: mpg-bpr

11.3.25 `bb_update/3'
---------------------

Synopsis
--------

`bb_update(:KEY, -OLDTERM, +NEWTERM)'

   If a term is currently stored under KEY and unifies with OLDTERM,
the term is replaced by a copy of NEWTERM.  Otherwise, `bb_update/3'
silently fails.  This predicate provides an atomic swap operation.

Arguments
---------

:KEY
     "atomic", must be nonvar

OLDTERM
     "term"

NEWTERM
     "term"

Description
-----------

Any uninstantiated variables in the NEWTERM will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     KEY is not instantiated

`type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-block,  Next: mpg-ref-break,  Prev: mpg-ref-bb_update,  Up: mpg-bpr

11.3.26 `block/1'   "[declaration]"
-----------------------------------

Synopsis
--------

`:- block +BLOCKSPEC'

   Specifies conditions for blocking goals of the predicates referred
to by BLOCKSPEC.

Arguments
---------

:BLOCKSPEC
     "callable", must be ground

     Goal template or list of goal templates, of the form `F(ARG1,
     ARG2,...)'.  Each ARGN is one of:

    `-'
          part of a block condition

    `?'
          otherwise

Description
-----------

When a goal for a block declared predicate is to be executed, the block
specs are interpreted as conditions for blocking the goal, and if at
least one condition evaluates to `true', the goal is blocked.

   A block condition evaluates to `true' iff all arguments specified as
`-' are uninstantiated, in which case the goal is blocked until at
least one of those variables is instantiated.  If several conditions
evaluate to `true', the implementation picks one of them and blocks the
goal accordingly.

   The recommended style is to write the block declarations in front of
the source code of the predicate they refer to.  Indeed, they are part
of the source code of the predicate, and must precede the first clause.
For example, with the definition:

     :- block merge(-,?,-), merge(?,-,-).

     merge([], Y, Y).
     merge(X, [], X).
     merge([H|X], [E|Y], [H|Z]) :- H @< E,  merge(X, [E|Y], Z).
     merge([H|X], [E|Y], [E|Z]) :- H @>= E, merge([H|X], Y, Z).

calls to `merge/3' having uninstantiated arguments in the first _and_
third position _or_ in the second _and_ third position will suspend.

   The behavior of blocking goals for a given predicate on
uninstantiated arguments cannot be switched off, except by abolishing
or redefining the predicate.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

`instantiation_error'
     BLOCKSPEC not ground.

`type_error'
     BLOCKSPEC not a valid specification.

`context_error'
     Declaration appeared in a goal.

`permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Block Declarations::.


File: sicstus.info,  Node: mpg-ref-break,  Next: mpg-ref-breakpoint_expansion,  Prev: mpg-ref-block,  Up: mpg-bpr

11.3.27 `break/0'   "[development]"
-----------------------------------

Synopsis
--------

`break'

   causes the current execution to be interrupted; enters next break
level.

Description
-----------

The first time `break/0' is called, it displays the message
     % Break level 1
     % 1
     | ?-

   The system is then ready to accept input as though it were at top
level.  If another call to `break/0' is encountered, it moves up to
level 2, and so on.  The break level is displayed on a separate line
before each top-level prompt.

   To close a break level and resume the execution that was suspended,
type `^D'.  `break/0' then succeeds, and execution of the interrupted
program is resumed.

   Changes can be made to a running program while in a break level.
Any change made to a procedure will take effect the next time that
procedure is called.  See *note ref-mdb-rcd:: for details of what
happens if a procedure that is currently being executed is redefined.
When a break level is entered, the debugger is turned off (although
leashing and spypoints are retained).  When a break level is exited, the
debugging state is restored to what it was before the break level was
entered.

   Often used via the debugging option `b'.

Exceptions
----------

Catches otherwise uncaught exceptions and issues an error message.

See Also
--------

`abort/0', `halt/[0,1]', *note Nested::.


File: sicstus.info,  Node: mpg-ref-breakpoint_expansion,  Next: mpg-ref-byte_count,  Prev: mpg-ref-break,  Up: mpg-bpr

11.3.28 `breakpoint_expansion/2'   "[development,hook]"
-------------------------------------------------------

Synopsis
--------

`:- multifile user:breakpoint_expansion/2.'

   `user:breakpoint_expansion(+MACRO, -BODY)'

   Defines debugger condition macros.

Arguments
---------

MACRO
     "term"

     Breakpoint test or action.

BODY
     "term"

     Expanded breakpoint test or action, may be composite.

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
as well.

See Also
--------

*note Breakpoint Conditions::.


File: sicstus.info,  Node: mpg-ref-byte_count,  Next: mpg-ref-call,  Prev: mpg-ref-breakpoint_expansion,  Up: mpg-bpr

11.3.29 `byte_count/2'
----------------------

Synopsis
--------

`byte_count(+STREAM, -COUNT)'

   Obtains the total number of bytes either input from or output to the
open binary stream STREAM and unifies it with COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _binary_ stream.

COUNT
     "integer"

     The resulting byte count of the stream.


Description
-----------

A freshly opened stream has a byte count of 0.  When a byte is input
from or output to a Prolog stream, the byte count of the Prolog stream
is increased by one.

   The count is reset by `set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`byte_count/2', `line_count/2', `line_position/2', `stream_position/2',
`set_stream_position/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-call,  Next: mpg-ref-call_cleanup,  Prev: mpg-ref-byte_count,  Up: mpg-bpr

11.3.30 `call/[1,2,...,255]'   "[ISO]"
--------------------------------------

Synopsis
--------

`call(+P)'

   Proves (executes) P.

   `call(+P,?Q,...)'

   Executes the goal obtained by augmenting P by the remaining
arguments.

Arguments
---------

:P
     "callable", must be nonvar

Q
     term ...

Description
-----------

If P is instantiated to an atom or compound term, then the goal
`call(P)' is executed exactly as if that term appeared textually in its
place, except that any cut (`!') occurring in P only cuts alternatives
in the execution of P.  Only `call/1..8' are required by ISO.

Backtracking
------------

Depends on P.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

`maplist/2' in `library(lists)' is defined as:

     maplist(Pred, Xs) :-
             (   foreach(X,Xs),
                 param(Pred)
             do  call(Pred, X)
             ).

See Also
--------

*note ref-sem-cal::.


File: sicstus.info,  Node: mpg-ref-call_cleanup,  Next: mpg-ref-call_residue_vars,  Prev: mpg-ref-call,  Up: mpg-bpr

11.3.31 `call_cleanup/2'
------------------------

`call_cleanup(+GOAL, +CLEANUP)'

Synopsis
--------

Executes the procedure call GOAL.  When GOAL succeeds determinately, is
cut, fails, or raises an exception, CLEANUP is executed.

Arguments
---------

:GOAL
     "callable", must be nonvar

:CLEANUP
     "callable", must be nonvar

Description
-----------

This construction can be used to ensure that CLEANUP is executed as
soon as GOAL has completed execution, no matter how it finishes.  In
more detail:

   When `call_cleanup/2' with a continuation C is called or backtracked
into, first GOAL is called or backtracked into.  Then there are four
possibilities:

  1. GOAL succeeds determinately, possibly leaving some blocked
     subgoals.  CLEANUP is executed with continuation C.

  2. GOAL succeeds with some alternatives outstanding.  Execution
     proceeds to C.  If a cut that removes the outstanding alternatives
     is encountered, CLEANUP is executed with continuation to proceed
     after the cut.  Also, if an exception E that will be caught by an
     ancestor of the `call_cleanup/2' GOAL is raised, CLEANUP is
     executed with continuation `raise_exception(E)'.

  3. GOAL fails.  CLEANUP is executed with continuation `fail'.

  4. GOAL raises an exception E.  CLEANUP is executed with continuation
     `raise_exception(E)'.

   In a typical use of `call_cleanup/2', CLEANUP succeeds determinately
after performing some side-effect; otherwise, unexpected behavior may
result.

   Note that the Prolog top-level operates as a read-execute-fail loop,
which backtracks into or cuts the query when the user types `;' or
<RET> respectively.  Also, some predicates, such as `halt/[0,1]' and
`abort/0', are implemented in terms of exceptions.  All of these
circumstances can trigger the execution of CLEANUP.

Backtracking
------------

Depends on the arguments.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-call_residue_vars,  Next: mpg-ref-callable,  Prev: mpg-ref-call_cleanup,  Up: mpg-bpr

11.3.32 `call_residue_vars/2'
-----------------------------

`call_residue_vars(+GOAL, -VARS)'

Synopsis
--------

Executes the procedure call GOAL, unifying VARS with the list of
residual variables that have blocked goals or attributes attached to
them.

Arguments
---------

:GOAL
     "callable", must be nonvar

VARS
     "list of var"

Description
-----------

GOAL is executed as if by `call/1'.  VARS is unified with the list of
new variables created during the call that remain unbound and have
blocked goals or attributes attached to them.  For example:

     | ?- call_residue_vars((dif(X,f(Y)), X=f(Z)), Vars).

     X = f(Z),
     Vars = [Z,Y],
     prolog:dif(f(Z),f(Y)) ?

Backtracking
------------

Depends on GOAL.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-callable,  Next: mpg-ref-catch,  Prev: mpg-ref-call_residue_vars,  Up: mpg-bpr

11.3.33 `callable/1'   "[ISO]"
------------------------------

Synopsis
--------

`callable(+TERM)'

   Succeeds if TERM is currently instantiated to an atom or a compound
term.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- callable(a).

     yes
     | ?- callable(a(1,2,3)).

     yes
     | ?- callable([1,2,3]).

     yes
     | ?- callable(1.1).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-catch,  Next: mpg-ref-char_code,  Prev: mpg-ref-callable,  Up: mpg-bpr

11.3.34 `catch/3'   "[ISO]"
---------------------------

Synopsis
--------

`catch(+PROTECTEDGOAL, -EXCEPTION, +HANDLER)'

   Specify an exception handler for PROTECTEDGOAL, and call
PROTECTEDGOAL, as described in *note ref-ere::.

Arguments
---------

:PROTECTEDGOAL
     "callable", must be nonvar

EXCEPTION
     "term"

:HANDLER
     "callable", must be nonvar

Examples
--------

Fail on exception:
     :- meta_predicate fail_on_exception(0).
     fail_on_exception(C):-
         catch(C, E, print_exception_then_fail(C, E)).

     print_exception_then_fail(C, E) :-
         format(user_error, 'Exception occured while calling ~q:~n', [C]),
         print_message(warning, E),
         fail.

Backtracking
------------

Depends on PROTECTEDGOAL and HANDLER.

Exceptions
----------

None.

See Also
--------

*note ref-ere::.


File: sicstus.info,  Node: mpg-ref-char_code,  Next: mpg-ref-char_conversion,  Prev: mpg-ref-catch,  Up: mpg-bpr

11.3.35 `char_code/2'   "[ISO]"
-------------------------------

Synopsis
--------

`char_code(+CHAR, -CODE)'

   `char_code(-CHAR, +CODE)'

   CODE is the character code comprising the printed representation of
CHAR.

Arguments
---------

CHAR
     "char"

     The "char" whose code is CODE.

CODE
     "code"

     The "code" corresponding to CHAR.

Description
-----------

Initially, at least one argument must be instantiated.

Exceptions
----------

`instantiation_error'
     CHAR and CODE are both uninstantiated

`type_error'
     CHAR is not a "char" or CODE is not an integer.

`representation_error'
     CODE is not a "code".

See Also
--------

`atom_codes/2', `number_codes/2'.


File: sicstus.info,  Node: mpg-ref-char_conversion,  Next: mpg-ref-character_count,  Prev: mpg-ref-char_code,  Up: mpg-bpr

11.3.36 `char_conversion/2'   "[ISO]"
-------------------------------------

Synopsis
--------

`char_conversion(+INCHAR, +OUTCHAR)'

   The mapping of INCHAR to OUTCHAR is added to the
character-conversion mapping.

Arguments
---------

INCHAR
     "char", must be nonvar

OUTCHAR
     "char", must be nonvar

Description
-----------

The mapping of INCHAR to OUTCHAR is added to the character-conversion
mapping. This means that in all subsequent term and program input
operations any _unquoted_ occurrence of INCHAR will be replaced by
OUTCHAR. The rationale for providing this facility is that in some
extended character sets (such as Japanese JIS character sets) the same
character can appear several times and thus have several codes, which
the users normally expect to be equivalent. It is advisable to always
quote the arguments of `char_conversion/2'.

   Any previous mapping of INCHAR is replaced by the new one.

   *Please note*: the mapping is _global_, as opposed to being local to
the current module, Prolog text, or otherwise.

Exceptions
----------

`instantiation_error'
     An argument is uninstantiated

`type_error'
     An argument is not a "char"

See Also
--------

*note Glossary::.


File: sicstus.info,  Node: mpg-ref-character_count,  Next: mpg-ref-clause,  Prev: mpg-ref-char_conversion,  Up: mpg-bpr

11.3.37 `character_count/2'
---------------------------

Synopsis
--------

`character_count(+STREAM, -COUNT)'

   Obtains the total number of characters either input from or output to
the open text stream STREAM and unifies it with COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _text_ stream

COUNT
     "integer"

     The resulting character count of the stream


Description
-----------

A freshly opened text stream has a character count of 0.  When a
character is input from or output to a non-interactive Prolog stream,
the character count of the Prolog stream is increased by one.
Character count for an interactive stream reflects the total character
input from or output to any interactive stream, i.e. all interactive
streams share the same counter.

   A `nl/[0,1]' operation also increases the character count of a
stream by one.

   The count is reset by `set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`byte_count/2', `line_count/2', `line_position/2', `stream_position/2',
`set_stream_position/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-clause,  Next: mpg-ref-close,  Prev: mpg-ref-character_count,  Up: mpg-bpr

11.3.38 `clause/[2,3]'   "[ISO]"
--------------------------------

Synopsis
--------

`clause(+HEAD, -BODY)'

   `clause(+HEAD, -BODY, -REF)'

   `clause(-HEAD, -BODY, +REF)'

   Searches the database for a clause whose head matches HEAD and whose
body matches BODY.

Arguments
---------

:HEAD
     "callable"

     A term whose functor names a dynamic procedure.

BODY
     "callable"

REF
     "db_reference"

Description
-----------

Initially, at least one of HEAD and REF must be instantiated.

   In the case of unit-clauses, BODY is unified with `true'.

   If a procedure consists entirely of unit-clauses then there is no
point in calling `clause/2' on it.  It is simpler and faster to call
the procedure.

   In `clause/3', either HEAD or REF must be instantiated.  If REF is
instantiated, `(HEAD :- BODY)' is unified with the clause identified by
REF.  (If this clause is a unit-clause, BODY is unified with `true'.)

   If the predicate did not previously exist, then it is created as a
dynamic predicate and `clause/2' fails.  If REF is not instantiated,
`clause/3' behaves exactly like `clause/2' except that the database
reference is returned.

   By default, clauses are accessed with respect to the source module.

Backtracking
------------

Can be used to backtrack through all the clauses matching a given HEAD
and BODY.  It fails when there are no (or no further) matching clauses
in the database.

Exceptions
----------

`instantiation_error'
     Neither HEAD nor REF is instantiated.

`type_error'
     HEAD is not a callable, or REF is not a well-formed db_reference

`permission_error'
     Procedure is not dynamic.

`existence_error'
     REF is a well-formed db_reference but does not correspond to an
     existing clause or record.

Comments
--------

If `clause/[2,3]' is called on an undefined procedure it fails, but
before failing it makes the procedure dynamic.  This can be useful if
you wish to prevent unknown procedure catching from happening on a call
to that procedure.

   It is not a limitation that HEAD is required to be instantiated in
`clause(HEAD, BODY)', because if you want to backtrack through all
clauses for all dynamic procedures this can be achieved by:
     | ?- predicate_property(P,dynamic), clause(P,B).

   If there are clauses with a given name and arity in several
different modules, or if the module for some clauses is not known, the
clauses can be accessed by first finding the module(s) by means of
`current_predicate/2'.  For example, if the procedure is `f/1':
     | ?- current_predicate(_,M:f(_)), clause(M:f(X),B).

   `clause/3' will only access clauses that are defined in, or imported
into, the source module, except that the source module can be
overridden by explicitly naming the appropriate module.  For example:
     | ?- assert(foo:bar,R).

     R = '$ref'(771292,1)

     | ?- clause(H,B,'$ref'(771292,1)).

     no
     | ?- clause(foo:H,B,'$ref'(771292,1)).

     H = bar,
     B = true

   Accessing a clause using `clause/2' uses first argument indexing when
possible, in just the same way that calling a procedure uses first
argument indexing.  See *note Indexing::.

   `clause/2' is part of the ISO Prolog standard; `clause/3' is not.

See Also
--------

`instance/2', `assert/[1,2]', `dynamic/1', `retract/1', *note
ref-mdb-acl::.


File: sicstus.info,  Node: mpg-ref-close,  Next: mpg-ref-compare,  Prev: mpg-ref-clause,  Up: mpg-bpr

11.3.39 `close/[1,2]'   "[ISO]"
-------------------------------

Synopsis
--------

`close(+STREAM)'

   `close(+STREAM, +OPTIONS)'

   closes the stream corresponding to STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     Stream or file specification.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following:

    `force(BOOLEAN)'
          Specifies whether SICStus Prolog is to close the stream
          forcefully, even in the presence of errors (`true'), or not
          (`false'). The latter is the default. Currently this option
          has no effect.

    `direction(+DIRECTION)'
          DIRECTION is an atom specifying the direction or directions to
          close.

          One of:
         `input'
               Close only the input direction, if open.

         `output'
               Close only the output direction, if open.

         `all'
               Close all directions. This is the default.
          if stream is not open in the specified direction then the
          call to `open/4' does nothing.

          Closing a single direction is mainly useful when dealing with
          bidirectional streams, such as sockets.


Description
-----------

If STREAM is a stream object, then if the corresponding stream is open,
it will be closed in the specified directions; otherwise, an error
exception is raised.

   If STREAM is a file specification, the corresponding stream will be
closed in the specified directions, provided that the file was opened by
`see/1' or `tell/1'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
     OPTIONS is not instantiated enough.

`type_error'
     OPTIONS is not a proper list.

`domain_error'
     OPTIONS contains an invalid option.

`permission_error'
     File not opened by `see/1' or `tell/1'.

`domain_error'
     STREAM is neither a filename nor a stream.

Examples
--------

In this example, `foo' will be closed:
     see(foo),
     ...
     close(foo)

   However, in this example, a permission error will be raised and `foo'
will not be closed:
     open(foo, read, S),
     ...
     close(foo)

   Here, `close(S)' should have been used.

See Also
--------

`see/1', `tell/1', `open/[3,4]', *note ref-iou-sfh::,  *note
lib-sockets::.


File: sicstus.info,  Node: mpg-ref-compare,  Next: mpg-ref-compile,  Prev: mpg-ref-close,  Up: mpg-bpr

11.3.40 `compare/3'   "[ISO]"
-----------------------------

Synopsis
--------

`compare(-ORDER, +TERM1, +TERM2)'

   succeeds if the result of comparing terms TERM1 and TERM2 is ORDER

Arguments
---------

ORDER
     "order"

    `='
          if TERM1 is identical to TERM2,

    `<'
          if TERM1 is before TERM2 in the standard order,

    `>'
          if TERM1 is after TERM2 in the standard order.

TERM1
     "term"

TERM2
     "term"

Description
-----------

The standard order is described in *note ref-lte-cte::. Note that the
standard order is not, in general, well defined for cyclic terms.

   The goal (A) is equivalent to (B):
     | ?- compare(=, Term1, Term2).  (A)

     |?- (Term1 == Term2).  (B)

   The following query succeeds, binding R to `<', because 1 comes
before 2 in the standard order.
      | ?- compare(R, 1, 2).

     R = <

   If ORDER is supplied, and is not one of `<', `>', or `=', then an
error is thrown, as follows.

Exceptions
----------

`type_error(atom, Order)'
     if ORDER is neither a variable nor an atom.

`domain_error(order, Order)'
     if ORDER is an atom but not `<', `=', or `>'.

   These errors were added in SICStus Prolog 4.3 for alignment with the
ISO Prolog standard. Previous versions of SICStus Prolog simply failed
instead of reporting an error.

See Also
--------

`@</2', `@=</2', `@>/2', `@>=/2', `SP_compare()', *note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-compile,  Next: mpg-ref-compound,  Prev: mpg-ref-compare,  Up: mpg-bpr

11.3.41 `compile/1'
-------------------

Synopsis
--------

`compile(+FILES)'

   Compiles the specified Prolog source file(s) into memory.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

Description
-----------

This predicate is defined as if by:
     compile(Files) :-
             load_files(Files, [load_type(source),compilation_mode(compile)]).

Exceptions
----------

See `load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-compound,  Next: mpg-ref-consult,  Prev: mpg-ref-compile,  Up: mpg-bpr

11.3.42 `compound/1'   "[ISO]"
------------------------------

Synopsis
--------

`compound(+TERM)'

   TERM is currently instantiated to a compound term.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- compound(9).

     no
     | ?- compound(a(1,2,3)).

     yes
     | ?- compound("a").

     yes
     | ?- compound([1,2]).

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-consult,  Next: mpg-ref-copy_term,  Prev: mpg-ref-compound,  Up: mpg-bpr

11.3.43 `consult/1'
-------------------

Synopsis
--------

`consult(+FILES)'

   Consults the specified Prolog source file(s) into memory.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

Description
-----------

This predicate is defined as if by:
     consult(Files) :-
             load_files(Files, [load_type(source),compilation_mode(consult)]).

Exceptions
----------

See `load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-copy_term,  Next: mpg-ref-coverage_data,  Prev: mpg-ref-consult,  Up: mpg-bpr

11.3.44 `copy_term/[2,3]'   "[ISO]"
-----------------------------------

Synopsis
--------

`copy_term(+TERM, -COPY)'

   Unifies COPY with a copy of TERM in which all variables have been
replaced by brand new variables, and all mutables by brand new mutables.

   `copy_term(+TERM, -COPY, -BODY)'

   Furthermore, if TERM contains variables with goals blocked on them,
or variables with attributes that can be interpreted as a goal (*note
lib-atts::), then BODY is unified with the conjunction of such goals.
If no such goals are present, BODY is unified with the atom `true'.
The idea is that executing BODY will reinstate blocked goals and
attributes on the variables in COPY equivalent to those on the
variables in TERM.

Arguments
---------

TERM
     "term"

COPY
     "term"

BODY
     "callable"

Description
-----------

Independent copies are substituted for any mutable terms in TERM.  It
behaves as if defined by:

     copy_term(X, Y) :-
             assert('copy of'(X)),
             retract('copy of'(Y)).

   The implementation of `copy_term/2' endeavors to conserve space by
not copying ground subterms.

   When you call `clause/[2,3]' or `instance/2', you get a new copy of
the term stored in the database, in precisely the same sense that
`copy_term/2' gives you a new copy.

Examples
--------

   * A naive way to attempt to find out whether one term is a copy of
     another:

          identical_but_for_variables(X, Y) :-
             \+ \+ (
                numbervars(X, 0, N),
                numbervars(Y, 0, N),
                X = Y
             ).

     This solution is sometimes sufficient, but will not work if the two
     terms have any variables in common.

   * If you want the test to succeed even when the two terms do have
     some variables in common, you need to copy one of them; for
     example,
          identical_but_for_variables(X, Y) :-
             \+ \+ (
                copy_term(X, Z),
                numbervars(Z, 0, N),
                numbervars(Y, 0, N),
                Z = Y
             ).

   * An example of `copy_term/3'.  Suppose that you want to make
     `copy_term/3' aware of the attribute `tfs/1' in some module.  Then
     with the module-file:

          :- module(foo, []).

          :- use_module(library(atts)).
          :- attribute tfs/1.

          attribute_goal(X, put_atts(X,tfs(Y))) :-
              get_atts(X, tfs(Y)).

     the following query works:

          | ?- foo:put_atts(X, tfs(ind)), copy_term(f(X), Copy, Body).
          Body = foo:put_atts(_A,tfs(ind)),
          Copy = f(_A),
          put_atts(X,tfs(ind)) ? <RET>
          yes


Comments
--------

`copy_term/2' is part of the ISO Prolog standard; `copy_term/3' is not.

Exceptions
----------

None.

See Also
--------

*note ref-lte-cpt::.


File: sicstus.info,  Node: mpg-ref-coverage_data,  Next: mpg-ref-create_mutable,  Prev: mpg-ref-copy_term,  Up: mpg-bpr

11.3.45 `coverage_data/1'   "[development]"
-------------------------------------------

Synopsis
--------

`coverage_data(-DATA)'   "since release 4.2"

   DATA is the coverage data accumulated so far.

Arguments
---------

DATA
     "list of coverage_pair"

     where:

     COVERAGE_PAIR     ::=
                       `counter(FILENAME,PRED_SPEC,CLAUSENO,LINENO)-TAGGED_HITS'
     FILENAME          ::= ATOM {file containing coverage site}
     CLAUSENO          ::= INTEGER {file relative clause number
                       containing coverage site}
     LINENO            ::= INTEGER {line of code containing coverage
                       site}
     TAGGED_HITS       ::= `det(HITS)' {no nondet calls made from site}
                       | `nondet(HITS)' {some nondet calls made from
                       site}
     HITS              ::= INTEGER {number of times that coverage site
                       was hit}

Description
-----------

The coverage data accumulated so far is collected into a term of type
"list of coverage_pair" and unified with DATA.

   *Please note*: A given line of code can contain more than one
coverage site.

Exceptions
----------

None.

See Also
--------

*note Coverage Analysis::.


File: sicstus.info,  Node: mpg-ref-create_mutable,  Next: mpg-ref-current_atom,  Prev: mpg-ref-coverage_data,  Up: mpg-bpr

11.3.46 `create_mutable/2'
--------------------------

Synopsis
--------

`create_mutable(+DATUM, -MUTABLE)'

   MUTABLE is a new mutable term with initial value DATUM.

Arguments
---------

DATUM
     "term", must be nonvar

MUTABLE
     "mutable"

Exceptions
----------

`instantiation_error'
     DATUM is uninstantiated

See Also
--------

*note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-current_atom,  Next: mpg-ref-current_breakpoint,  Prev: mpg-ref-create_mutable,  Up: mpg-bpr

11.3.47 `current_atom/1'
------------------------

Synopsis
--------

`current_atom(?ATOM)'

   ATOM is a currently existing atom.

Arguments
---------

ATOM
     "atom"

Backtracking
------------

If ATOM is uninstantiated, `current_atom/1' can be used to enumerate
all known atoms.  The order in which atoms are bound to ATOM on
backtracking corresponds to the times of their creation.

Comments
--------

Note that the predicate `atom/1' is recommended for determining whether
a term is an atom, as `current_atom/1' will succeed if ATOM is
uninstantiated as well.

Exceptions
----------

None.

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-current_breakpoint,  Next: mpg-ref-current_char_conversion,  Prev: mpg-ref-current_atom,  Up: mpg-bpr

11.3.48 `current_breakpoint/5'   "[development]"
------------------------------------------------

Synopsis
--------

`current_breakpoint(-CONDITIONS, -BID, -STATUS, -KIND, -TYPE)'

   There is a breakpoint with conditions CONDITIONS, identifier BID,
enabledness STATUS, kind KIND, and type TYPE.

Arguments
---------

:CONDITIONS
     "term"

     Breakpoint conditions.

BID
     "integer"

     Breakpoint identifier.

STATUS
     "one of `[on,off]'"

     `on' for enabled breakpoints and `off' for disabled ones

KIND
     "one of `[plain(MFUNC),conditional(MFUNC),generic]'"

     MFUNC is the module qualified functor of the specific breakpoint.

TYPE
     "one of `[debugger,advice]'"

Exceptions
----------

`instantiation_error'
     CONDITIONS not instantiated enough.

`type_error'
     CONDITIONS not a proper list of callable term.

`domain_error'
     CONDITIONS not a proper list of valid breakpoint conditions

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-current_char_conversion,  Next: mpg-ref-current_input,  Prev: mpg-ref-current_breakpoint,  Up: mpg-bpr

11.3.49 `current_char_conversion/2'   "[ISO]"
---------------------------------------------

Synopsis
--------

`current_char_conversion(?INCHAR, ?OUTCHAR)'

   INCHAR is currently mapped to OUTCHAR in the character-conversion
mapping, where the two are distinct.

Arguments
---------

INCHAR
     "char"

OUTCHAR
     "char"

Exceptions
----------

`type_error'
     An argument is instantiated not to a "char".

See Also
--------

*note Glossary::.


File: sicstus.info,  Node: mpg-ref-current_input,  Next: mpg-ref-current_key,  Prev: mpg-ref-current_char_conversion,  Up: mpg-bpr

11.3.50 `current_input/1'   "[ISO]"
-----------------------------------

Synopsis
--------

`current_input(-STREAM)'

   unifies STREAM with the current input stream.

Arguments
---------

STREAM
     "stream_object"

Description
-----------

STREAM is the current input stream.  The current input stream is also
accessed by the C variable `SP_curin'.

Exceptions
----------

`domain_error'
     STREAM is instantiated not to a valid stream.

See Also
--------

`open/[3,4]', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-current_key,  Next: mpg-ref-current_module,  Prev: mpg-ref-current_input,  Up: mpg-bpr

11.3.51 `current_key/2'
-----------------------

Synopsis
--------

`current_key(?KEYNAME, ?KEYTERM)'

   Succeeds when KEYNAME is the name of KEYTERM, and KEYTERM is a
recorded key.

Arguments
---------

KEYNAME
     "atomic"

     One of:
        * KEYTERM, if KEYTERM is atomic; or

        * the principal functor of KEYTERM, if KEYTERM is a compound
          term.

KEYTERM
     "term"

     The most general form of the key for a currently recorded term.


Description
-----------

This predicate can be used to enumerate in undefined order all keys for
currently recorded terms through backtracking.

Backtracking
------------

Enumerates all keys through backtracking.

Exceptions
----------

None.

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-current_module,  Next: mpg-ref-current_op,  Prev: mpg-ref-current_key,  Up: mpg-bpr

11.3.52 `current_module/[1,2]'
------------------------------

Synopsis
--------

`current_module(?MODULENAME)'

   Queries whether a module is "current" or backtracks through all of
the current modules.

   `current_module(?MODULENAME, ?ABSFILE)'

   Associates modules with their module-files.

Arguments
---------

MODULENAME
     "atom"

ABSFILE
     "atom"

     Absolute filename in which the module is defined.

Description
-----------

A loaded module becomes "current" as soon as some predicate is defined
in it, and a module can never lose the property of being current.

   It is possible for a current module to have no associated file, in
which case `current_module/1' will succeed on it but `current_module/2'
will fail.  This arises for the special module `user' and for
dynamically-created modules (*note ref-mod::).

   If its arguments are not correct, or if MODULE has no associated
file, `current_module/2' simply fails.

Backtracking
------------

`current_module/1' backtracks through all of the current modules.  The
following command will print out all current modules:
     | ?- current_module(Module), writeq(Module), nl, fail.

   `current_module/2' backtracks through all of the current modules and
their associated files.

Exceptions
----------

`type_error'

Examples
--------

     | ?- findall(M,current_module(M),Ms).
     Ms = [chr,user,prolog,'SU_messages',clpfd] ? <RET>
     yes
     | ?- findall(M-F,current_module(M,F),MFs).
     MFs = ['SU_messages'-'/src/sicstus/matsc/sicstus4/Utils/x86-linux-glibc2.3/bin/sp-4.1.0/sicstus-4.1.0/library/SU_messages.pl'] ?
     yes

See Also
--------

*note ref-mod-ilm::.


File: sicstus.info,  Node: mpg-ref-current_op,  Next: mpg-ref-current_output,  Prev: mpg-ref-current_module,  Up: mpg-bpr

11.3.53 `current_op/3'   "[ISO]"
--------------------------------

Synopsis
--------

`current_op(?PRECEDENCE, ?TYPE, ?NAME)'

   Succeeds when the atom NAME is currently an operator of type TYPE
and precedence PRECEDENCE.

Arguments
---------

PRECEDENCE
     "integer", in the range 1-1200

TYPE
     "one of `[`xfx', `xfy', `yfx', `fx', `xf', `yf']'"

NAME
     "atom"

Description
-----------

None of the arguments need be instantiated at the time of the call;
that is, this predicate can be used to find the precedence or type of
an operator or to backtrack through all operators.

   To add or remove an operator, use `op/3'.

Exceptions
----------

`type_error'
     NAME not an atom or TYPE not an atom or PRECEDENCE not an integer.

`domain_error'
     PRECEDENCE not between 1-1200, or TYPE not one of listed atoms.

Examples
--------

See Also
--------

`op/3', *note ref-syn-ops::.


File: sicstus.info,  Node: mpg-ref-current_output,  Next: mpg-ref-current_predicate,  Prev: mpg-ref-current_op,  Up: mpg-bpr

11.3.54 `current_output/1'   "[ISO]"
------------------------------------

Synopsis
--------

`current_output(-STREAM)'

   unifies STREAM with the current output stream.

Arguments
---------

STREAM
     "stream_object"

Description
-----------

STREAM is the current output stream.  The current output stream is also
accessed by the C variable `SP_curout'.

Exceptions
----------

`domain_error'
     STREAM is instantiated not to a valid stream.

See Also
--------

`open/[3,4]', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-current_predicate,  Next: mpg-ref-current_prolog_flag,  Prev: mpg-ref-current_output,  Up: mpg-bpr

11.3.55 `current_predicate/[1,2]'   "[ISO]"
-------------------------------------------

Synopsis
--------

`current_predicate(?PREDSPEC)'

   Unifies PREDSPEC with a predicate specifications of the form
NAME/ARITY.

   `current_predicate(?NAME, ?TERM)'

   Unifies NAME with the name of a user-defined predicate, and TERM
with the most general term corresponding to that predicate.

Arguments
---------

:PREDSPEC
     "pred_spec"

NAME
     "atom"

:TERM
     "callable"

Description
-----------

If you have loaded the predicates `foo/1' and `foo/3' into Prolog,
`current_predicate/2' would return the following:
      | ?- current_predicate(foo, T).

     T = foo(_A) ;

     T = foo(_A,_B,_C) ;

     no

Examples
--------

   * The following goals can be used to backtrack through every
     predicate in your program.

          | ?- current_predicate(Name, Module:Term).

          | ?- current_predicate(Module:PredSpec).

   * If a module is specified, `current_predicate/[1,2]' only succeeds
     for those predicates that are _defined_ in the module.  It fails
     for those predicates that are imported into a module.

          | ?- current_predicate(m:P).

     will backtrack through all predicates `P' that are defined in
     module `m'.  To backtrack through all predicates imported by a
     module use `predicate_property/2' (*note ref-lps-ove::).

   To find out whether a predicate is built-in, use
`predicate_property/2'.

     % Is there a callable predicate named `gc'?

     | ?- current_predicate(gc, Term).

     no
     | ?- predicate_property(gc, Prop)

     Prop = built_in

Exceptions
----------

`instantiation_error'
`type_error'
     in PREDSPEC

Comments
--------

`current_predicate/1' is part of the ISO Prolog standard;
`current_predicate/2' is not.

See Also
--------

`predicate_property/2', *note ref-lps-ove::.


File: sicstus.info,  Node: mpg-ref-current_prolog_flag,  Next: mpg-ref-current_stream,  Prev: mpg-ref-current_predicate,  Up: mpg-bpr

11.3.56 `current_prolog_flag/2'   "[ISO]"
-----------------------------------------

Synopsis
--------

`current_prolog_flag(?FLAGNAME, ?VALUE)'

   same as `prolog_flag(FLAGNAME, VALUE)', except that
`current_prolog_flag(FLAGNAME, VALUE)' type checks FLAGNAME.

Arguments
---------

FLAGNAME
     "atom"

VALUE
     "term"

Exceptions
----------

`type_error'
     FLAGNAME is not an atom.

`domain_error'
     FLAGNAME is not a valid flag name.

See Also
--------

`prolog_flag/2'.


File: sicstus.info,  Node: mpg-ref-current_stream,  Next: mpg-ref-db_reference,  Prev: mpg-ref-current_prolog_flag,  Up: mpg-bpr

11.3.57 `current_stream/3'
--------------------------

Synopsis
--------

`current_stream(?ABSFILE, ?MODE, ?STREAM)'

   STREAM is a stream, which is currently open on file ABSFILE in mode
MODE.

Arguments
---------

ABSFILE
     "atom"

     Absolute filename.

MODE
     for streams opened with `open/[3,4]' this is "one of `[read,
     write, append]'".  For other streams MODE may have other values.

STREAM
     "stream_object"

Description
-----------

   * None of the arguments need be initially instantiated.

   *  Ignores certain pre-defined streams, e.g. the streams initially
     associated with `user_input', `user_output' and `user_error' will
     not be recognized or generated by `current_stream/3'.

     This is unlike `stream_property/3', which can backtrack over all
     streams, including the pre-defined ones.


Backtracking
------------

Can be used to backtrack through all open streams.

Exceptions
----------

None.

See Also
--------

`open/[3,4]', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-cut,  Next: mpg-ref-and,  Up: mpg-bpr

11.3.58 `!/0'   "[ISO]"
-----------------------

Synopsis
--------

`!'

   Cut.

Description
-----------

When first encountered as a goal, cut succeeds immediately.  If
backtracking should later return to the cut, the parent goal will fail
(the parent goal is the one that matched the head of the clause
containing the cut).

Exceptions
----------

None.

See Also
--------

*note ref-sem-ctr-cut::.


File: sicstus.info,  Node: mpg-ref-db_reference,  Next: mpg-ref-debug,  Prev: mpg-ref-current_stream,  Up: mpg-bpr

11.3.59 `db_reference/1'
------------------------

Synopsis
--------

`db_reference(+TERM)'   "since release 4.1"

   TERM is currently instantiated to a compound term with principal
functor `'$ref'/2' denoting a unique reference to a dynamic clause.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- db_reference(9).

     no

     | ?- db_reference(_X).

     no

     | ?- assertz(foo(a), R), db_reference(R).

     R = '$ref'(1816730,128)

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-debug,  Next: mpg-ref-debugger_command_hook,  Prev: mpg-ref-db_reference,  Up: mpg-bpr

11.3.60 `debug/0'   "[development]"
-----------------------------------

Synopsis
--------

`debug'

   Turns on the debugger in debug mode.

Description
-----------

`debug/0' turns the debugger on and sets it to debug mode.  Turning the
debugger on in debug mode means that it will stop at the next spypoint
encountered in the current execution.

   The effect of this predicate can also be achieved by typing the
letter `d' after a `^C' interrupt (*note Execution::).

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-debugger_command_hook,  Next: mpg-ref-debugging,  Prev: mpg-ref-debug,  Up: mpg-bpr

11.3.61 `debugger_command_hook/2'   "[development,hook]"
--------------------------------------------------------

Synopsis
--------

`:- multifile user:debugger_command_hook/2.'

   `user:debugger_command_hook(+DCOMMAND, -ACTIONS)'

   Allows the interactive debugger to be extended with user-defined
commands. *Note Debug Commands::.

Arguments
---------

DCOMMAND
     "term"

ACTIONS
     "term"

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

*note Breakpoint Predicates::.


File: sicstus.info,  Node: mpg-ref-debugging,  Next: mpg-ref-dif,  Prev: mpg-ref-debugger_command_hook,  Up: mpg-bpr

11.3.62 `debugging/0'   "[development]"
---------------------------------------

Synopsis
--------

`debugging'

   Prints out current debugging state

Description
-----------

`debugging/0' displays information on the terminal about the current
debugging state.  It shows
   * The top-level state of the debugger, which is one of

    `debug'
          The debugger is on but will not show anything or stop for user
          interaction until a spypoint is reached.

    `trace'
          The debugger is on and will show everything.  As soon as you
          type a goal, you will start seeing a debugging trace.  After
          printing each trace message, the debugger may or may not stop
          for user interaction:  this depends on the type of leashing
          in force (see below).

    `zip'
          The debugger is on but will not show anything or stop for user
          interaction until a spypoint is reached. The debugger does
          not even keep any information of the execution of the goal
          till the spypoint is reached and hence you will not be able
          to see the ancestors of the goal when you reach the spypoint.

    `off'
          The debugger is off.

     The top-level state can be controlled by the predicates `debug/0',
     `nodebug/0', `trace/0', `notrace/0' `zip/0', `nozip/0', and
     `prolog_flag/3'.

   * The type of leashing in force.  When the debugger prints a message
     saying that it is passing through a particular port (one of Call,
     Exit, Redo, Fail, or Exception) of a particular procedure, it
     stops for user interaction only if that port is leashed.  The
     predicate `leash/1' can be used to select which of the seven ports
     you want to be leashed.

   * All the current spypoints.  Spypoints are controlled by the
     predicates `spy/[1,2]', `nospy/1', `nospyall/0',
     `add_breakpoint/2', `disable_breakpoints/1',
     `enable_breakpoints/1', and `remove_breakpoints/1'.

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-dif,  Next: mpg-ref-disable_breakpoints,  Prev: mpg-ref-debugging,  Up: mpg-bpr

11.3.63 `dif/2'
---------------

Synopsis
--------

`dif(+X,+Y)'

   Constrains X and Y to represent different terms i.e.  to be
non-unifiable.

Arguments
---------

X
     "term"

Y
     "term"

Description
-----------

Calls to `dif/2' either succeed, fail, or are blocked depending on
whether X and Y are sufficiently instantiated.  It is defined as if by:

     dif(X, Y) :- when(?=(X,Y), X\==Y).

Exceptions
----------

None.

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-disable_breakpoints,  Next: mpg-ref-discontiguous,  Prev: mpg-ref-dif,  Up: mpg-bpr

11.3.64 `disable_breakpoints/1'   "[development]"
-------------------------------------------------

Synopsis
--------

`disable_breakpoints(+BIDS)'

   Disables the breakpoints specified by BIDS.

Arguments
---------

BIDS
     "list of integer", must be ground

     Breakpoint identifiers.

Exceptions
----------

`instantiation_error'
`type_error'
     in BIDS

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-discontiguous,  Next: mpg-ref-display,  Prev: mpg-ref-disable_breakpoints,  Up: mpg-bpr

11.3.65 `discontiguous/1'   "[ISO,declaration]"
-----------------------------------------------

Synopsis
--------

`:- discontiguous +PREDSPECS'

   Declares the clauses of the predicates defined by PREDSPECS to be
discontiguous in the source file (suppresses compile-time warnings).

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of
     such separated by commas.

Comments
--------

`discontiguous' is not an ISO predefined prefix operator.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

`instantiation_error'
     PREDSPECS not ground.

`type_error'
     PREDSPECS not a valid "pred_spec_forest".

`domain_error'
     Some arity is an integer < 0.

`representation_error'
     Some arity is an integer > 255.

`context_error'
     Declaration appeared in a goal.

`permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Discontiguous Declarations::.


File: sicstus.info,  Node: mpg-ref-display,  Next: mpg-ref-do,  Prev: mpg-ref-discontiguous,  Up: mpg-bpr

11.3.66 `display/1'
-------------------

Synopsis
--------

`display(+TERM)'

   Writes TERM on the standard output stream, without quoting atoms,
without operator notation, without treating `'$VAR'/1' terms specially.

   Since quoting is never used, even when needed for reading the term
back in, the standard predicate `write_canonical/1' is often preferable.

Arguments
---------

TERM
     "term"

Description
-----------

`display(Term)' is equivalent to:

     write_term(Term, [ignore_ops(true)])

Examples
--------

     | ?- display(a+b).
     +(a,b)
     yes

     | ?- read(X), display(X), nl.
     |: a + b * c.
     +(a,*(b,c))

     X = a+b*c

     | ?-

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-do,  Next: mpg-ref-dynamic,  Prev: mpg-ref-display,  Up: mpg-bpr

11.3.67 `do/2'
--------------

Synopsis
--------

`(+ITERATOR do +BODY)'

Arguments
---------

+ITERATOR
     "iterator", must be nonvar

:BODY
     "callable", must be nonvar

Description
-----------

This control structure reduces the need to write auxiliary predicates
performing simple iterations.  A "iterator" is a term of one of the
following forms:

`fromto(FIRST,IN,OUT,LAST)'
     Iterate BODY starting with IN=FIRST until OUT=LAST. IN and OUT are
     local variables in BODY.

`foreach(X,LIST)'
     Iterate BODY with X ranging over all elements of LIST. X is a
     local variable in BODY. Can also be used for constructing a list.

`foreacharg(X,STRUCT)'
`foreacharg(X,STRUCT,I)'
     Iterate BODY with X ranging over all arguments of STRUCT and I
     ranging over the argument number, 1-based.  X and I are local
     variable in BODY. Cannot be used for constructing a term.

`count(I,MIN,MAX)'
     Iterate BODY with I ranging over integers from MIN up to MAX. I is
     a local variable in BODY. Can be used for controlling iteration as
     well as counting, i.e. MAX can be a variable.

`for(I,MIN,MAX)'
     Iterate BODY with I ranging over integers from MIN to MAX. I is a
     local variable in BODY. MIN and MAX can be arithmetic expressions.
     Can be used only for controlling iteration, i.e. MAX cannot be
     uninstantiated.

`param(X)'
     For declaring variables in BODY global, ie shared with the context.
     X can be a single variable, or a list of them.

`"iterator","iterator"'
     The iterators are iterated synchronously; that is, they all take
     their first "value" for the first execution of BODY, their second
     "value" for the second execution of BODY, etc. The order in which
     they are written does not matter, and the set of local variables in
     BODY is the union of those of the iterators. When multiple
     iteration specifiers are given in this way, typically not all of
     them will impose a termination condition on the loop (e.g.
     `foreach' with an uninstantiated list and count with an
     uninstantiated maximum do not impose a termination condition), but
     at least one of them should do so. If several specifiers impose
     termination conditions, then these conditions must coincide, i.e.
     specify the same number of iterations.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-ctr-dol::.


File: sicstus.info,  Node: mpg-ref-dynamic,  Next: mpg-ref-enable_breakpoints,  Prev: mpg-ref-do,  Up: mpg-bpr

11.3.68 `dynamic/1'   "[ISO,declaration]"
-----------------------------------------

Synopsis
--------

`:- dynamic +PREDSPECS'

   Declares the clauses of the predicates defined by PREDSPECS to be
dynamic.

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of
     such separated by commas.

Comments
--------

`dynamic' is not an ISO predefined prefix operator.

   To declare a grammar rule GRAM/N dynamic, the arity of PREDSPECS
must be N+2.

   Exceptions in the context of loading code are printed as error
messages.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

`instantiation_error'
     PREDSPECS not ground.

`type_error'
     PREDSPECS not a valid "pred_spec_forest".

`domain_error'
     Some arity is an integer < 0.

`representation_error'
     Some arity is an integer > 255.

`context_error'
     Declaration appeared in a goal.

`permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Dynamic Declarations::.


File: sicstus.info,  Node: mpg-ref-enable_breakpoints,  Next: mpg-ref-ensure_loaded,  Prev: mpg-ref-dynamic,  Up: mpg-bpr

11.3.69 `enable_breakpoints/1'   "[development]"
------------------------------------------------

Synopsis
--------

`enable_breakpoints(+BIDS)'

   Enables the breakpoints specified by BIDS.

Arguments
---------

BIDS
     "list of integer", must be ground

     Breakpoint identifiers.

Exceptions
----------

`instantiation_error'
`type_error'
     in BIDS

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-ensure_loaded,  Next: mpg-ref-erase,  Prev: mpg-ref-enable_breakpoints,  Up: mpg-bpr

11.3.70 `ensure_loaded/1'   "[ISO]"
-----------------------------------

Synopsis
--------

`ensure_loaded(+FILES)'

   Loads the specified Prolog source and/or object file(s) into memory,
if not already loaded and up to date.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extension
     optional.

Description
-----------

The recommended style is to use this predicate for non-module-files
only, but if any module-files are encountered, their public predicates
are imported.

   This predicate is defined as if by:
     ensure_loaded(Files) :-
             load_files(Files, [if(changed)]).

Exceptions
----------

See `load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-equal_to,  Next: mpg-ref-not_greater_than,  Prev: mpg-ref-unify,  Up: mpg-bpr

11.3.71 `=:=/2'   "[ISO]"
-------------------------

Synopsis
--------

+EXPR1 `=:=' +EXPR2

   Succeeds if the results of evaluating EXPR1 and EXPR2 _are equal_.

Arguments
---------

EXPR1
     "expr", must be ground

EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 1.0 + 1.0 =:= 2.

     yes

     | ?- "a" =:= 97.

     yes

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-erase,  Next: mpg-ref-error_exception,  Prev: mpg-ref-ensure_loaded,  Up: mpg-bpr

11.3.72 `erase/1'
-----------------

Synopsis
--------

`erase(+REF)'

   Erases from the database the dynamic clause or recorded term
referenced by REF.

Arguments
---------

REF
     "db_reference", must be nonvar

Description
-----------

Erases from the database the dynamic clause or recorded term referenced
by REF.

   REF must be a database reference to an existing clause or recorded
term.

   `erase/1' is not sensitive to the source module; that is, it can
erase a clause even if that clause is neither defined in nor imported
into the source module.

Exceptions
----------

`instantiation_error'
     If REF is not instantiated.

`type_error'
     If REF is not a database reference.

`existence_error'
     if REF is not a database reference to an existing clause or
     recorded term.

Examples
--------

See Also
--------

*note ref-mdb-rcd::.


File: sicstus.info,  Node: mpg-ref-error_exception,  Next: mpg-ref-execution_state,  Prev: mpg-ref-erase,  Up: mpg-bpr

11.3.73 `error_exception/1'   "[development,hook]"
--------------------------------------------------

Synopsis
--------

`:- multifile user:error_exception/1.'

   `user:error_exception(+EXCEPTION)'

   Tells the debugger to enter trace mode on exceptions matching
EXCEPTION.

Arguments
---------

EXCEPTION
     "term"

Exceptions
----------

None.

See Also
--------

*note Exceptions Debug::.


File: sicstus.info,  Node: mpg-ref-execution_state,  Next: mpg-ref-expand_term,  Prev: mpg-ref-error_exception,  Up: mpg-bpr

11.3.74 `execution_state/[1,2]'   "[development]"
-------------------------------------------------

Synopsis
--------

`execution_state(+TESTS)'

   TESTS are satisfied in the current state of the execution.

   `execution_state(+FOCUSCONDITIONS, +TESTS)'

   TESTS are satisfied in the state of the execution pointed to by
FOCUSCONDITIONS.

Arguments
---------

FOCUSCONDITIONS
     "term"

:TESTS
     "term"

Exceptions
----------

`instantiation_error'
     An argument not instantiated enough.

`type_error'
     An argument not a proper list of callable term.

`domain_error'
     An argument not a proper list of valid conditions and tests.

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-exists,  Next: mpg-ref-abolish,  Prev: mpg-ref-term_not_equal_to,  Up: mpg-bpr

11.3.75 `^/2'
-------------

Synopsis
--------

+X `^' +P

   Equivalent to "there exists an X such that P is true", thus X is
normally an unbound variable. The use of the explicit existential
quantifier outside `setof/3' and `bagof/3' is superfluous.

Arguments
---------

X
     "term"

:P
     "callable", must be nonvar

Description
-----------

Equivalent to simply calling P.

Backtracking
------------

Depends on P.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

Using `bagof/3' without and with the existential quantifier:
     | ?- bagof(X, foo(X,Y), L).

     X = _3342,
     Y = 2,
     L = [1,1] ;

     X = _3342,
     Y = 3,
     L = [2] ;

     no

     | ?- bagof(X, Y^foo(X,Y), L).

     X = _3342,
     Y = _3361,
     L = [1,1,2] ;

     no

See Also
--------

`setof/3', `bagof/3', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-expand_term,  Next: mpg-ref-fail,  Prev: mpg-ref-execution_state,  Up: mpg-bpr

11.3.76 `expand_term/2'   "[hookable]"
--------------------------------------

Synopsis
--------

`expand_term(+TERM1, -TERM2)'

   Transforms source file terms into Prolog clauses before they are
compiled.  Normally called by the compiler, but can be called directly.
The transform can be customized by defining `user:term_expansion/6'.

   When a source file is loaded, except by `:- include',
`expand_term/2' is called with the virtual clauses `beginning_of_file'
before and `end_of_file' after the real Prolog clauses, to give
`user:term_expansion/6' an opportunity to perform some action at the
beginning and end of a source file. *Please note*: the virtual clause
`beginning_of_file' is "seen" _before_ any module declaration, i.e.
before the source module has been updated.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Description
-----------

Usually called by the built-in predicates that read code and not
directly by user programs.

   in particular used to translate grammar rules, written with `-->/2',
into ordinary Prolog clauses, written with `:-/2'.  If TERM1 is a
grammar rule, then TERM2 is the corresponding clause.  Otherwise TERM2
is simply TERM1 unchanged.

   Calls `user:term_expansion/6'.

Exceptions
----------

Prints messages for exceptions raised by `user:term_expansion/6'.

See Also
--------

`phrase/[2,3]', `-->/2', *note ref-lod-exp::.


File: sicstus.info,  Node: mpg-ref-fail,  Next: mpg-ref-false,  Prev: mpg-ref-expand_term,  Up: mpg-bpr

11.3.77 `fail/0'   "[ISO]"
--------------------------

Synopsis
--------

`fail'

   Always fails.

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-false,  Next: mpg-ref-file_search_path,  Prev: mpg-ref-fail,  Up: mpg-bpr

11.3.78 `false/0'   "[ISO]"
---------------------------

Synopsis
--------

`false'

   Always fails (same as `fail/0').

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-file_search_path,  Next: mpg-ref-findall,  Prev: mpg-ref-false,  Up: mpg-bpr

11.3.79 `file_search_path/2'   "[hook]"
---------------------------------------

Synopsis
--------

`:- multifile user:file_search_path/2.'

   `user:file_search_path(+PATHALIAS, +DIRSPEC)'

   Defines a symbolic name for a directory or a path.  Used by
predicates taking "file_spec" as input argument.

Arguments
---------

PATHALIAS
     "atom"

     An atom that represents the path given by DIRSPEC.

DIRSPEC
     "file_spec"

     Either an atom giving the path to a file or directory, or
     PATHALIAS(DIRSPEC), where PATHALIAS is defined by another
     `file_search_path/2' rule.

Description
-----------

The `file_search_path' mechanism provides an extensible way of
specifying a sequence of directories to search to locate a file.  For
instance, if a filename is given as a structure term,
`library(between)'.  The principle functor of the term, `library', is
taken to be another `file_search_path/2' definition of the form
     file_search_path(library, LibPath)

   and file `between' is assumed to be relative to the path given by
LIBPATH.  LIBPATH may also be another structure term, in which case
another `file_search_path/2' fact gives its definition.  The search
continues until the path is resolved to an atom.

   There may also be several definitions for the same PATHALIAS.
Certain predicates, such as `load_files/[1,2]' and
`absolute_file_name/[2,3]', search all these definitions until the path
resolves to an existing file.

   There are several predefined search paths, such as `application',
`runtime', `library', `system'.  These are tried before the
user-defined ones.

   The predicate is undefined at startup, but behaves as if it were a
multifile predicate with the following clauses.  The system properties
`SP_APP_DIR' and `SP_RT_DIR' expand respectively to the absolute path
of the directory that contains the executable and the directory that
contains the SICStus runtime (*note System Properties and Environment
Variables::), `SP_TEMP_DIR' expand to a directory suitable for storing
temporary files.

     file_search_path(library, Path) :-
             library_directory(Path).
     file_search_path(system, Platform) :-
             prolog_flag(host_type, Platform).
     file_search_path(application, '$SP_APP_DIR').
     file_search_path(runtime, '$SP_RT_DIR').
     file_search_path(temp, '$SP_TEMP_DIR').
     file_search_path(path, Dir) :-
             ... backtracks through the $PATH environment variable ...

Examples
--------

     | ?- [user].
     % compiling user...
     | :- multifile user:file_search_path/2.
     | user:file_search_path(home, '/usr/joe_bob').
     | user:file_search_path(review, home('movie/review')).
     | end_of_file.
     % compiled user in module user, 0 msec 768 bytes
     yes
     | ?- compile(review(blob)).
     % compiling /usr/joe_bob/movie/review/blob.pl

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

`absolute_file_name/[2,3]', `library_directory/1', `load_files/[1,2]',
*note ref-fdi::, *note ref-lps-flg::, *note System Properties and
Environment Variables::.


File: sicstus.info,  Node: mpg-ref-findall,  Next: mpg-ref-float,  Prev: mpg-ref-file_search_path,  Up: mpg-bpr

11.3.80 `findall/[3,4]'   "[ISO]"
---------------------------------

Synopsis
--------

`findall(+TEMPLATE, +GENERATOR, -LIST)'

   `findall(+TEMPLATE, +GENERATOR, -LIST, +REMAINDER)'

   LIST is the list of all the instances of TEMPLATE for which the goal
GENERATOR succeeds, appended to REMAINDER.  REMAINDER defaults to the
empty list.

Arguments
---------

TEMPLATE
     "term"

:GENERATOR
     "callable", must be nonvar

     A goal to be proved as if by `call/1'.

LIST
     "list of term"

REMAINDER
     "list of term"

Description
-----------

A special case of `bagof/3', where all free variables in the generator
are taken to be existentially quantified, as if by means of the `^'
operator. Contrary to `bagof/3' and `setof/3', if there are no
instances of TEMPLATE such that GENERATOR succeeds, then LIST =
REMAINDER.

   Because `findall/[3,4]' avoids the relatively expensive variable
analysis done by `bagof/3', using `findall/[3,4]' where appropriate
rather than `bagof/3' can be considerably more efficient.

   *Please note*: If the instances being gathered contain attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
those variables are replaced by brand new variables, without
attributes, in LIST.  To retain the attributes, you can use
`copy_term/3' (*note ref-lte-cpt::).

Backtracking
------------

`bagof/3' can succeed nondeterminately, generating alternative values
for SET corresponding to different instantiations of the free variables
of GENERATOR.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

To illustrate the differences among `findall/3', `setof/3', and
`bagof/3':
     | ?- [user].
     | foo(1,2).
     | foo(1,2).
     | foo(2,3).
     |
     % user compiled in module user, 0.100 sec 352 bytes

     yes
     | ?- bagof(X, foo(X,Y), L).

     Y = 2,
     L = [1,1] ? ;

     Y = 3,
     L = [2] ? ;

     no

     | ?- bagof(X, Y^foo(X,Y), L).

     L = [1,1,2] ? ;

     no

     | ?- findall(X, foo(X,Y), L).

     L = [1,1,2] ? ;

     no
     | ?- findall(X, foo(X,Y), L, S).

     L = [1,1,2|S] ? ;

     no

     | ?- setof(X, foo(X,Y), L).

     X = _3342,
     Y = 2,
     L = [1] ;

     X = _3342,
     Y = 3,
     L = [2] ;

     no

Comments
--------

`findall/3' is part of the ISO Prolog standard; `findall/4' is not.

See Also
--------

`bagof/3', `setof/3', `^/2', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-float,  Next: mpg-ref-flush_output,  Prev: mpg-ref-findall,  Up: mpg-bpr

11.3.81 `float/1'   "[ISO]"
---------------------------

Synopsis
--------

`float(+TERM)'

   TERM is currently instantiated to a float.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- float(Term1).

     no
     | ?- float(5.2).

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-flush_output,  Next: mpg-ref-foreign,  Prev: mpg-ref-float,  Up: mpg-bpr

11.3.82 `flush_output/[0,1]'   "[ISO]"
--------------------------------------

Synopsis
--------

`flush_output'

   `flush_output(+STREAM)'

   Forces the buffered output of the stream STREAM (defaults to the
current output stream) to be sent to the associated device.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog stream, defaults to the current output stream.

Description
-----------

Sends the current buffered output of an output stream STREAM to the
actual output device, which is usually a disk or a tty device.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`permission_error'
     An error occurred in flushing out the buffered output.

Examples
--------

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-foreign,  Next: mpg-ref-foreign_resource,  Prev: mpg-ref-flush_output,  Up: mpg-bpr

11.3.83 `foreign/[2,3]'   "[hook]"
----------------------------------

Synopsis
--------

`:- discontiguous foreign/2, foreign/3.'

   `foreign(+ROUTINE, +FOREIGNSPEC)'

   `foreign(+ROUTINE, +LANGUAGE, +FOREIGNSPEC)'

   Describes the interface between Prolog and the foreign ROUTINE.
Used by `load_foreign_resource/1'.

Arguments
---------

ROUTINE
     "atom", must be nonvar

     An atom that names a foreign code ROUTINE.

LANGUAGE
     "atom", must be nonvar

     An atom that names the LANGUAGE in which ROUTINE is written. Can
     only be `c'.

FOREIGNSPEC
     "foreign_spec", must be ground

     A ground term of the form PREDNAME(ARGSPEC, ..., ARGSPEC) as
     described in *note Conversions between Prolog Arguments and C
     Types::.  Each ARGSPEC should be a "foreign_arg".


Description
-----------

The user has to define a `foreign/[2,3]' fact for every foreign
function that is to be called from Prolog. Note that ROUTINE does not
have to be the same as PREDICATENAME. Arguments are passed to the
foreign function as specified in FOREIGNSPEC.

+TYPE
     specifies that an argument is to be passed to the foreign function.

-TYPE
     specifies that an argument is to be received from the foreign
     function.

[-TYPE]
     argument is used to obtain the return value of a foreign function
     call.  At most one "return value" argument can be specified.

   The `foreign/[2,3]' facts are used only in the context of a
`load_foreign_resource/1' command and can be removed once the foreign
files are loaded.

   Contrary to most hook predicates which reside in the `user' module,
`foreign/[2,3]' facts will only be looked up in the source module of
the loading command.

Exceptions
----------

Error handling is performed by `load_foreign_resource/1'.

See Also
--------

`load_foreign_resource/1', *note Calling C from Prolog::.


File: sicstus.info,  Node: mpg-ref-foreign_resource,  Next: mpg-ref-format,  Prev: mpg-ref-foreign,  Up: mpg-bpr

11.3.84 `foreign_resource/2'   "[hook]"
---------------------------------------

Synopsis
--------

`:- discontiguous foreign_resource/2.'

   `foreign_resource(+RESOURCENAME, +FOREIGNFUNCTIONS)'

   Describes the foreign functions in RESOURCENAME to interface to.

Arguments
---------

RESOURCENAME
     "atom", must be nonvar

FOREIGNFUNCTIONS
     "list of atom", must be ground

     A list of foreign function symbols that will be obtained from
     RESOURCENAME.

Description
-----------

The user has to define a `foreign_resource/2' fact for every foreign
resource that is to be loaded into Prolog. The FOREIGNFUNCTIONS gives
the list of foreign symbols that are to be found in the given foreign
resource.  When a foreign resource is loaded using
`load_foreign_resource/1', Prolog looks for a `foreign_resource/2' fact
for that foreign resource and finds the address of each symbol listed
in that fact.  Prolog also expects a `foreign/[2,3]' definition for
each symbol in the second argument of that fact.

   The `foreign_resource/2' facts are used only in the context of a
`load_foreign_resource/1' command and can be removed once the foreign
resource has been loaded.

   Contrary to most hook predicates which reside in the `user' module,
`load_foreign_resource/1' will look for `foreign_resource/2' facts
defined in its source module.

Exceptions
----------

Error handling is performed by `load_foreign_resource/1'.

See Also
--------

`load_foreign_resource/1', `foreign/[2,3]', *note Calling C from
Prolog::.

